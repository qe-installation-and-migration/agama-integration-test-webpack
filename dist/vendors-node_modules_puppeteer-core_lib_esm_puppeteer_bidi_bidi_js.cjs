#! /usr/bin/env -S node --enable-source-maps --test-timeout=60000
exports.id = "vendors-node_modules_puppeteer-core_lib_esm_puppeteer_bidi_bidi_js";
exports.ids = ["vendors-node_modules_puppeteer-core_lib_esm_puppeteer_bidi_bidi_js"];
exports.modules = {

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutgoingMessage = exports.EventEmitter = exports.BidiServer = void 0;
/**
 * @fileoverview The entry point to the BiDi Mapper namespace.
 * Other modules should only access exports defined in this file.
 * XXX: Add ESlint rule for this (https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/no-restricted-paths.md)
 */
var BidiServer_js_1 = __webpack_require__(/*! ./BidiServer.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js");
Object.defineProperty(exports, "BidiServer", ({ enumerable: true, get: function () { return BidiServer_js_1.BidiServer; } }));
var EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
Object.defineProperty(exports, "EventEmitter", ({ enumerable: true, get: function () { return EventEmitter_js_1.EventEmitter; } }));
var OutgoingMessage_js_1 = __webpack_require__(/*! ./OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
Object.defineProperty(exports, "OutgoingMessage", ({ enumerable: true, get: function () { return OutgoingMessage_js_1.OutgoingMessage; } }));
//# sourceMappingURL=BidiMapper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BidiNoOpParser = void 0;
class BidiNoOpParser {
    // Browser domain
    // keep-sorted start block=yes
    parseRemoveUserContextParams(params) {
        return params;
    }
    // keep-sorted end
    // Browsing Context domain
    // keep-sorted start block=yes
    parseActivateParams(params) {
        return params;
    }
    parseCaptureScreenshotParams(params) {
        return params;
    }
    parseCloseParams(params) {
        return params;
    }
    parseCreateParams(params) {
        return params;
    }
    parseGetTreeParams(params) {
        return params;
    }
    parseHandleUserPromptParams(params) {
        return params;
    }
    parseLocateNodesParams(params) {
        return params;
    }
    parseNavigateParams(params) {
        return params;
    }
    parsePrintParams(params) {
        return params;
    }
    parseReloadParams(params) {
        return params;
    }
    parseSetViewportParams(params) {
        return params;
    }
    parseTraverseHistoryParams(params) {
        return params;
    }
    // keep-sorted end
    // CDP domain
    // keep-sorted start block=yes
    parseGetSessionParams(params) {
        return params;
    }
    parseResolveRealmParams(params) {
        return params;
    }
    parseSendCommandParams(params) {
        return params;
    }
    // keep-sorted end
    // Script domain
    // keep-sorted start block=yes
    parseAddPreloadScriptParams(params) {
        return params;
    }
    parseCallFunctionParams(params) {
        return params;
    }
    parseDisownParams(params) {
        return params;
    }
    parseEvaluateParams(params) {
        return params;
    }
    parseGetRealmsParams(params) {
        return params;
    }
    parseRemovePreloadScriptParams(params) {
        return params;
    }
    // keep-sorted end
    // Input domain
    // keep-sorted start block=yes
    parsePerformActionsParams(params) {
        return params;
    }
    parseReleaseActionsParams(params) {
        return params;
    }
    parseSetFilesParams(params) {
        return params;
    }
    // keep-sorted end
    // Network domain
    // keep-sorted start block=yes
    parseAddInterceptParams(params) {
        return params;
    }
    parseContinueRequestParams(params) {
        return params;
    }
    parseContinueResponseParams(params) {
        return params;
    }
    parseContinueWithAuthParams(params) {
        return params;
    }
    parseFailRequestParams(params) {
        return params;
    }
    parseProvideResponseParams(params) {
        return params;
    }
    parseRemoveInterceptParams(params) {
        return params;
    }
    // keep-sorted end
    // Permissions domain
    // keep-sorted start block=yes
    parseSetPermissionsParams(params) {
        return params;
    }
    // keep-sorted end
    // Session domain
    // keep-sorted start block=yes
    parseSubscribeParams(params) {
        return params;
    }
    // keep-sorted end
    // Storage domain
    // keep-sorted start block=yes
    parseDeleteCookiesParams(params) {
        return params;
    }
    parseGetCookiesParams(params) {
        return params;
    }
    parseSetCookieParams(params) {
        return params;
    }
}
exports.BidiNoOpParser = BidiNoOpParser;
//# sourceMappingURL=BidiNoOpParser.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BidiServer = void 0;
const EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const log_js_1 = __webpack_require__(/*! ../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const ProcessingQueue_js_1 = __webpack_require__(/*! ../utils/ProcessingQueue.js */ "./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js");
const CommandProcessor_js_1 = __webpack_require__(/*! ./CommandProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js");
const CdpTargetManager_js_1 = __webpack_require__(/*! ./modules/cdp/CdpTargetManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js");
const BrowsingContextStorage_js_1 = __webpack_require__(/*! ./modules/context/BrowsingContextStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js");
const NetworkStorage_js_1 = __webpack_require__(/*! ./modules/network/NetworkStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js");
const PreloadScriptStorage_js_1 = __webpack_require__(/*! ./modules/script/PreloadScriptStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js");
const RealmStorage_js_1 = __webpack_require__(/*! ./modules/script/RealmStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js");
const EventManager_js_1 = __webpack_require__(/*! ./modules/session/EventManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js");
class BidiServer extends EventEmitter_js_1.EventEmitter {
    #messageQueue;
    #transport;
    #commandProcessor;
    #eventManager;
    #browsingContextStorage = new BrowsingContextStorage_js_1.BrowsingContextStorage();
    #realmStorage = new RealmStorage_js_1.RealmStorage();
    #preloadScriptStorage = new PreloadScriptStorage_js_1.PreloadScriptStorage();
    #logger;
    #handleIncomingMessage = (message) => {
        void this.#commandProcessor.processCommand(message).catch((error) => {
            this.#logger?.(log_js_1.LogType.debugError, error);
        });
    };
    #processOutgoingMessage = async (messageEntry) => {
        const message = messageEntry.message;
        if (messageEntry.channel !== null) {
            message['channel'] = messageEntry.channel;
        }
        await this.#transport.sendMessage(message);
    };
    constructor(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger) {
        super();
        this.#logger = logger;
        this.#messageQueue = new ProcessingQueue_js_1.ProcessingQueue(this.#processOutgoingMessage, this.#logger);
        this.#transport = bidiTransport;
        this.#transport.setOnMessage(this.#handleIncomingMessage);
        this.#eventManager = new EventManager_js_1.EventManager(this.#browsingContextStorage);
        const networkStorage = new NetworkStorage_js_1.NetworkStorage(this.#eventManager, this.#browsingContextStorage, browserCdpClient, logger);
        this.#commandProcessor = new CommandProcessor_js_1.CommandProcessor(cdpConnection, browserCdpClient, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, this.#preloadScriptStorage, networkStorage, parser, async (options) => {
            // This is required to ignore certificate errors when service worker is fetched.
            await browserCdpClient.sendCommand('Security.setIgnoreCertificateErrors', {
                ignore: options.acceptInsecureCerts ?? false,
            });
            new CdpTargetManager_js_1.CdpTargetManager(cdpConnection, browserCdpClient, selfTargetId, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, networkStorage, this.#preloadScriptStorage, defaultUserContextId, options?.unhandledPromptBehavior, logger);
            // Needed to get events about new targets.
            await browserCdpClient.sendCommand('Target.setDiscoverTargets', {
                discover: true,
            });
            // Needed to automatically attach to new targets.
            await browserCdpClient.sendCommand('Target.setAutoAttach', {
                autoAttach: true,
                waitForDebuggerOnStart: true,
                flatten: true,
            });
            await this.#topLevelContextsLoaded();
        }, this.#logger);
        this.#eventManager.on("event" /* EventManagerEvents.Event */, ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
        });
        this.#commandProcessor.on("response" /* CommandProcessorEvents.Response */, ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
        });
    }
    /**
     * Creates and starts BiDi Mapper instance.
     */
    static async createAndStart(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, parser, logger) {
        // The default context is not exposed in Target.getBrowserContexts but can
        // be observed via Target.getTargets. To determine the default browser
        // context, we check which one is mentioned in Target.getTargets and not in
        // Target.getBrowserContexts.
        const [{ browserContextIds }, { targetInfos }] = await Promise.all([
            browserCdpClient.sendCommand('Target.getBrowserContexts'),
            browserCdpClient.sendCommand('Target.getTargets'),
        ]);
        let defaultUserContextId = 'default';
        for (const info of targetInfos) {
            if (info.browserContextId &&
                !browserContextIds.includes(info.browserContextId)) {
                defaultUserContextId = info.browserContextId;
                break;
            }
        }
        const server = new BidiServer(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger);
        return server;
    }
    /**
     * Sends BiDi message.
     */
    emitOutgoingMessage(messageEntry, event) {
        this.#messageQueue.add(messageEntry, event);
    }
    close() {
        this.#transport.close();
    }
    async #topLevelContextsLoaded() {
        await Promise.all(this.#browsingContextStorage
            .getTopLevelContexts()
            .map((c) => c.lifecycleLoaded()));
    }
}
exports.BidiServer = BidiServer;
//# sourceMappingURL=BidiServer.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const log_js_1 = __webpack_require__(/*! ../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BidiNoOpParser_js_1 = __webpack_require__(/*! ./BidiNoOpParser.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js");
const BrowserProcessor_js_1 = __webpack_require__(/*! ./modules/browser/BrowserProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js");
const CdpProcessor_js_1 = __webpack_require__(/*! ./modules/cdp/CdpProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js");
const BrowsingContextProcessor_js_1 = __webpack_require__(/*! ./modules/context/BrowsingContextProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js");
const InputProcessor_js_1 = __webpack_require__(/*! ./modules/input/InputProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js");
const NetworkProcessor_js_1 = __webpack_require__(/*! ./modules/network/NetworkProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js");
const PermissionsProcessor_js_1 = __webpack_require__(/*! ./modules/permissions/PermissionsProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js");
const ScriptProcessor_js_1 = __webpack_require__(/*! ./modules/script/ScriptProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js");
const SessionProcessor_js_1 = __webpack_require__(/*! ./modules/session/SessionProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js");
const StorageProcessor_js_1 = __webpack_require__(/*! ./modules/storage/StorageProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js");
const OutgoingMessage_js_1 = __webpack_require__(/*! ./OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
class CommandProcessor extends EventEmitter_js_1.EventEmitter {
    // keep-sorted start
    #browserProcessor;
    #browsingContextProcessor;
    #cdpProcessor;
    #inputProcessor;
    #networkProcessor;
    #permissionsProcessor;
    #scriptProcessor;
    #sessionProcessor;
    #storageProcessor;
    // keep-sorted end
    #parser;
    #logger;
    constructor(cdpConnection, browserCdpClient, eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, networkStorage, parser = new BidiNoOpParser_js_1.BidiNoOpParser(), initConnection, logger) {
        super();
        this.#parser = parser;
        this.#logger = logger;
        // keep-sorted start block=yes
        this.#browserProcessor = new BrowserProcessor_js_1.BrowserProcessor(browserCdpClient);
        this.#browsingContextProcessor = new BrowsingContextProcessor_js_1.BrowsingContextProcessor(browserCdpClient, browsingContextStorage, eventManager);
        this.#cdpProcessor = new CdpProcessor_js_1.CdpProcessor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient);
        this.#inputProcessor = new InputProcessor_js_1.InputProcessor(browsingContextStorage);
        this.#networkProcessor = new NetworkProcessor_js_1.NetworkProcessor(browsingContextStorage, networkStorage);
        this.#permissionsProcessor = new PermissionsProcessor_js_1.PermissionsProcessor(browserCdpClient);
        this.#scriptProcessor = new ScriptProcessor_js_1.ScriptProcessor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, logger);
        this.#sessionProcessor = new SessionProcessor_js_1.SessionProcessor(eventManager, browserCdpClient, initConnection);
        this.#storageProcessor = new StorageProcessor_js_1.StorageProcessor(browserCdpClient, browsingContextStorage, logger);
        // keep-sorted end
    }
    async #processCommand(command) {
        switch (command.method) {
            case 'session.end':
                // TODO: Implement.
                break;
            // Browser domain
            // keep-sorted start block=yes
            case 'browser.close':
                return this.#browserProcessor.close();
            case 'browser.createUserContext':
                return await this.#browserProcessor.createUserContext(command.params);
            case 'browser.getUserContexts':
                return await this.#browserProcessor.getUserContexts();
            case 'browser.removeUserContext':
                return await this.#browserProcessor.removeUserContext(this.#parser.parseRemoveUserContextParams(command.params));
            // keep-sorted end
            // Browsing Context domain
            // keep-sorted start block=yes
            case 'browsingContext.activate':
                return await this.#browsingContextProcessor.activate(this.#parser.parseActivateParams(command.params));
            case 'browsingContext.captureScreenshot':
                return await this.#browsingContextProcessor.captureScreenshot(this.#parser.parseCaptureScreenshotParams(command.params));
            case 'browsingContext.close':
                return await this.#browsingContextProcessor.close(this.#parser.parseCloseParams(command.params));
            case 'browsingContext.create':
                return await this.#browsingContextProcessor.create(this.#parser.parseCreateParams(command.params));
            case 'browsingContext.getTree':
                return this.#browsingContextProcessor.getTree(this.#parser.parseGetTreeParams(command.params));
            case 'browsingContext.handleUserPrompt':
                return await this.#browsingContextProcessor.handleUserPrompt(this.#parser.parseHandleUserPromptParams(command.params));
            case 'browsingContext.locateNodes':
                return await this.#browsingContextProcessor.locateNodes(this.#parser.parseLocateNodesParams(command.params));
            case 'browsingContext.navigate':
                return await this.#browsingContextProcessor.navigate(this.#parser.parseNavigateParams(command.params));
            case 'browsingContext.print':
                return await this.#browsingContextProcessor.print(this.#parser.parsePrintParams(command.params));
            case 'browsingContext.reload':
                return await this.#browsingContextProcessor.reload(this.#parser.parseReloadParams(command.params));
            case 'browsingContext.setViewport':
                return await this.#browsingContextProcessor.setViewport(this.#parser.parseSetViewportParams(command.params));
            case 'browsingContext.traverseHistory':
                return await this.#browsingContextProcessor.traverseHistory(this.#parser.parseTraverseHistoryParams(command.params));
            // keep-sorted end
            // CDP domain
            // keep-sorted start block=yes
            case 'cdp.getSession':
                return this.#cdpProcessor.getSession(this.#parser.parseGetSessionParams(command.params));
            case 'cdp.resolveRealm':
                return this.#cdpProcessor.resolveRealm(this.#parser.parseResolveRealmParams(command.params));
            case 'cdp.sendCommand':
                return await this.#cdpProcessor.sendCommand(this.#parser.parseSendCommandParams(command.params));
            // keep-sorted end
            // Input domain
            // keep-sorted start block=yes
            case 'input.performActions':
                return await this.#inputProcessor.performActions(this.#parser.parsePerformActionsParams(command.params));
            case 'input.releaseActions':
                return await this.#inputProcessor.releaseActions(this.#parser.parseReleaseActionsParams(command.params));
            case 'input.setFiles':
                return await this.#inputProcessor.setFiles(this.#parser.parseSetFilesParams(command.params));
            // keep-sorted end
            // Network domain
            // keep-sorted start block=yes
            case 'network.addIntercept':
                return await this.#networkProcessor.addIntercept(this.#parser.parseAddInterceptParams(command.params));
            case 'network.continueRequest':
                return await this.#networkProcessor.continueRequest(this.#parser.parseContinueRequestParams(command.params));
            case 'network.continueResponse':
                return await this.#networkProcessor.continueResponse(this.#parser.parseContinueResponseParams(command.params));
            case 'network.continueWithAuth':
                return await this.#networkProcessor.continueWithAuth(this.#parser.parseContinueWithAuthParams(command.params));
            case 'network.failRequest':
                return await this.#networkProcessor.failRequest(this.#parser.parseFailRequestParams(command.params));
            case 'network.provideResponse':
                return await this.#networkProcessor.provideResponse(this.#parser.parseProvideResponseParams(command.params));
            case 'network.removeIntercept':
                return await this.#networkProcessor.removeIntercept(this.#parser.parseRemoveInterceptParams(command.params));
            case 'network.setCacheBehavior':
                throw new protocol_js_1.UnknownErrorException("Method 'network.setCacheBehavior' is not implemented.");
            // keep-sorted end
            // Permissions domain
            // keep-sorted start block=yes
            case 'permissions.setPermission':
                return await this.#permissionsProcessor.setPermissions(this.#parser.parseSetPermissionsParams(command.params));
            // keep-sorted end
            // Script domain
            // keep-sorted start block=yes
            case 'script.addPreloadScript':
                return await this.#scriptProcessor.addPreloadScript(this.#parser.parseAddPreloadScriptParams(command.params));
            case 'script.callFunction':
                return await this.#scriptProcessor.callFunction(this.#parser.parseCallFunctionParams(this.#processTargetParams(command.params)));
            case 'script.disown':
                return await this.#scriptProcessor.disown(this.#parser.parseDisownParams(this.#processTargetParams(command.params)));
            case 'script.evaluate':
                return await this.#scriptProcessor.evaluate(this.#parser.parseEvaluateParams(this.#processTargetParams(command.params)));
            case 'script.getRealms':
                return this.#scriptProcessor.getRealms(this.#parser.parseGetRealmsParams(command.params));
            case 'script.removePreloadScript':
                return await this.#scriptProcessor.removePreloadScript(this.#parser.parseRemovePreloadScriptParams(command.params));
            // keep-sorted end
            // Session domain
            // keep-sorted start block=yes
            case 'session.new':
                return await this.#sessionProcessor.new(command.params);
            case 'session.status':
                return this.#sessionProcessor.status();
            case 'session.subscribe':
                return await this.#sessionProcessor.subscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
            case 'session.unsubscribe':
                return await this.#sessionProcessor.unsubscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
            // keep-sorted end
            // Storage domain
            // keep-sorted start block=yes
            case 'storage.deleteCookies':
                return await this.#storageProcessor.deleteCookies(this.#parser.parseDeleteCookiesParams(command.params));
            case 'storage.getCookies':
                return await this.#storageProcessor.getCookies(this.#parser.parseGetCookiesParams(command.params));
            case 'storage.setCookie':
                return await this.#storageProcessor.setCookie(this.#parser.parseSetCookieParams(command.params));
            // keep-sorted end
        }
        // Intentionally kept outside the switch statement to ensure that
        // ESLint @typescript-eslint/switch-exhaustiveness-check triggers if a new
        // command is added.
        throw new protocol_js_1.UnknownCommandException(`Unknown command '${command.method}'.`);
    }
    // Workaround for as zod.union always take the first schema
    // https://github.com/w3c/webdriver-bidi/issues/635
    #processTargetParams(params) {
        if (typeof params === 'object' &&
            params &&
            'target' in params &&
            typeof params.target === 'object' &&
            params.target &&
            'context' in params.target) {
            delete params.target['realm'];
        }
        return params;
    }
    async processCommand(command) {
        try {
            const result = await this.#processCommand(command);
            const response = {
                type: 'success',
                id: command.id,
                result,
            };
            this.emit("response" /* CommandProcessorEvents.Response */, {
                message: OutgoingMessage_js_1.OutgoingMessage.createResolved(response, command.channel),
                event: command.method,
            });
        }
        catch (e) {
            if (e instanceof protocol_js_1.Exception) {
                this.emit("response" /* CommandProcessorEvents.Response */, {
                    message: OutgoingMessage_js_1.OutgoingMessage.createResolved(e.toErrorResponse(command.id), command.channel),
                    event: command.method,
                });
            }
            else {
                const error = e;
                this.#logger?.(log_js_1.LogType.bidi, error);
                this.emit("response" /* CommandProcessorEvents.Response */, {
                    message: OutgoingMessage_js_1.OutgoingMessage.createResolved(new protocol_js_1.UnknownErrorException(error.message, error.stack).toErrorResponse(command.id), command.channel),
                    event: command.method,
                });
            }
        }
    }
}
exports.CommandProcessor = CommandProcessor;
//# sourceMappingURL=CommandProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutgoingMessage = void 0;
class OutgoingMessage {
    #message;
    #channel;
    constructor(message, channel = null) {
        this.#message = message;
        this.#channel = channel;
    }
    static createFromPromise(messagePromise, channel) {
        return messagePromise.then((message) => {
            if (message.kind === 'success') {
                return {
                    kind: 'success',
                    value: new OutgoingMessage(message.value, channel),
                };
            }
            return message;
        });
    }
    static createResolved(message, channel) {
        return Promise.resolve({
            kind: 'success',
            value: new OutgoingMessage(message, channel),
        });
    }
    get message() {
        return this.#message;
    }
    get channel() {
        return this.#channel;
    }
}
exports.OutgoingMessage = OutgoingMessage;
//# sourceMappingURL=OutgoingMessage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class BrowserProcessor {
    #browserCdpClient;
    constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
    }
    close() {
        // Ensure that it is put at the end of the event loop.
        // This way we send back the response before closing the tab.
        setTimeout(() => this.#browserCdpClient.sendCommand('Browser.close'), 0);
        return {};
    }
    async createUserContext(params) {
        const request = {
            proxyServer: params['goog:proxyServer'] ?? undefined,
        };
        const proxyBypassList = params['goog:proxyBypassList'] ?? undefined;
        if (proxyBypassList) {
            request.proxyBypassList = proxyBypassList.join(',');
        }
        const context = await this.#browserCdpClient.sendCommand('Target.createBrowserContext', request);
        return {
            userContext: context.browserContextId,
        };
    }
    async removeUserContext(params) {
        const userContext = params.userContext;
        if (userContext === 'default') {
            throw new protocol_js_1.InvalidArgumentException('`default` user context cannot be removed');
        }
        try {
            await this.#browserCdpClient.sendCommand('Target.disposeBrowserContext', {
                browserContextId: userContext,
            });
        }
        catch (err) {
            // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/target_handler.cc;l=1424;drc=c686e8f4fd379312469fe018f5c390e9c8f20d0d
            if (err.message.startsWith('Failed to find context with id')) {
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        return {};
    }
    async getUserContexts() {
        const result = await this.#browserCdpClient.sendCommand('Target.getBrowserContexts');
        return {
            userContexts: [
                {
                    userContext: 'default',
                },
                ...result.browserContextIds.map((id) => {
                    return {
                        userContext: id,
                    };
                }),
            ],
        };
    }
}
exports.BrowserProcessor = BrowserProcessor;
//# sourceMappingURL=BrowserProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class CdpProcessor {
    #browsingContextStorage;
    #realmStorage;
    #cdpConnection;
    #browserCdpClient;
    constructor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
    }
    getSession(params) {
        const context = params.context;
        const sessionId = this.#browsingContextStorage.getContext(context).cdpTarget.cdpSessionId;
        if (sessionId === undefined) {
            return {};
        }
        return { session: sessionId };
    }
    resolveRealm(params) {
        const context = params.realm;
        const realm = this.#realmStorage.getRealm({ realmId: context });
        if (realm === undefined) {
            throw new protocol_js_1.UnknownErrorException(`Could not find realm ${params.realm}`);
        }
        return { executionContextId: realm.executionContextId };
    }
    async sendCommand(params) {
        const client = params.session
            ? this.#cdpConnection.getCdpClient(params.session)
            : this.#browserCdpClient;
        const result = await client.sendCommand(params.method, params.params);
        return {
            result,
            session: params.session,
        };
    }
}
exports.CdpProcessor = CdpProcessor;
//# sourceMappingURL=CdpProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpTarget = void 0;
const chromium_bidi_js_1 = __webpack_require__(/*! ../../../protocol/chromium-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BrowsingContextImpl_js_1 = __webpack_require__(/*! ../context/BrowsingContextImpl.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js");
const LogManager_js_1 = __webpack_require__(/*! ../log/LogManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js");
class CdpTarget {
    #id;
    #cdpClient;
    #browserCdpClient;
    #realmStorage;
    #eventManager;
    #preloadScriptStorage;
    #browsingContextStorage;
    #networkStorage;
    #unblocked = new Deferred_js_1.Deferred();
    #unhandledPromptBehavior;
    #logger;
    #networkDomainEnabled = false;
    #fetchDomainStages = {
        request: false,
        response: false,
        auth: false,
    };
    static create(targetId, cdpClient, browserCdpClient, realmStorage, eventManager, preloadScriptStorage, browsingContextStorage, networkStorage, unhandledPromptBehavior, logger) {
        const cdpTarget = new CdpTarget(targetId, cdpClient, browserCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, unhandledPromptBehavior, logger);
        LogManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager, logger);
        cdpTarget.#setEventListeners();
        // No need to await.
        // Deferred will be resolved when the target is unblocked.
        void cdpTarget.#unblock();
        return cdpTarget;
    }
    constructor(targetId, cdpClient, browserCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, unhandledPromptBehavior, logger) {
        this.#id = targetId;
        this.#cdpClient = cdpClient;
        this.#browserCdpClient = browserCdpClient;
        this.#eventManager = eventManager;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#browsingContextStorage = browsingContextStorage;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
    }
    /** Returns a deferred that resolves when the target is unblocked. */
    get unblocked() {
        return this.#unblocked;
    }
    get id() {
        return this.#id;
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    get browserCdpClient() {
        return this.#browserCdpClient;
    }
    /** Needed for CDP escape path. */
    get cdpSessionId() {
        // SAFETY we got the client by it's id for creating
        return this.#cdpClient.sessionId;
    }
    /**
     * Enables all the required CDP domains and unblocks the target.
     */
    async #unblock() {
        try {
            await Promise.all([
                this.#cdpClient.sendCommand('Page.enable'),
                // There can be some existing frames in the target, if reconnecting to an
                // existing browser instance, e.g. via Puppeteer. Need to restore the browsing
                // contexts for the frames to correctly handle further events, like
                // `Runtime.executionContextCreated`.
                // It's important to schedule this task together with enabling domains commands to
                // prepare the tree before the events (e.g. Runtime.executionContextCreated) start
                // coming.
                // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2282
                this.#cdpClient
                    .sendCommand('Page.getFrameTree')
                    .then((frameTree) => this.#restoreFrameTreeState(frameTree.frameTree)),
                this.#cdpClient.sendCommand('Runtime.enable'),
                this.#cdpClient.sendCommand('Page.setLifecycleEventsEnabled', {
                    enabled: true,
                }),
                this.toggleNetworkIfNeeded(),
                this.#cdpClient.sendCommand('Target.setAutoAttach', {
                    autoAttach: true,
                    waitForDebuggerOnStart: true,
                    flatten: true,
                }),
                this.#initAndEvaluatePreloadScripts(),
                this.#cdpClient.sendCommand('Runtime.runIfWaitingForDebugger'),
            ]);
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, 'Failed to unblock target', error);
            // The target might have been closed before the initialization finished.
            if (!this.#cdpClient.isCloseError(error)) {
                this.#unblocked.resolve({
                    kind: 'error',
                    error,
                });
                return;
            }
        }
        this.#unblocked.resolve({
            kind: 'success',
            value: undefined,
        });
    }
    #restoreFrameTreeState(frameTree) {
        const frame = frameTree.frame;
        const maybeContext = this.#browsingContextStorage.findContext(frame.id);
        if (maybeContext !== undefined) {
            // Restoring parent of already known browsing context. This means the target is
            // OOPiF and the BiDi session was connected to already existing browser instance.
            if (maybeContext.parentId === null &&
                frame.parentId !== null &&
                frame.parentId !== undefined) {
                maybeContext.parentId = frame.parentId;
            }
        }
        if (maybeContext === undefined && frame.parentId !== undefined) {
            // Restore not yet known nested frames. The top-level frame is created when the
            // target is attached.
            const parentBrowsingContext = this.#browsingContextStorage.getContext(frame.parentId);
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(frame.id, frame.parentId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, frame.url, undefined, this.#unhandledPromptBehavior, this.#logger);
        }
        frameTree.childFrames?.map((frameTree) => this.#restoreFrameTreeState(frameTree));
    }
    async toggleFetchIfNeeded() {
        const stages = this.#networkStorage.getInterceptionStages(this.topLevelId);
        if (
        // Only toggle interception when Network is enabled
        !this.#networkDomainEnabled ||
            (this.#fetchDomainStages.request === stages.request &&
                this.#fetchDomainStages.response === stages.response &&
                this.#fetchDomainStages.auth === stages.auth)) {
            return;
        }
        const patterns = [];
        this.#fetchDomainStages = stages;
        if (stages.request || stages.auth) {
            // CDP quirk we need request interception when we intercept auth
            patterns.push({
                urlPattern: '*',
                requestStage: 'Request',
            });
        }
        if (stages.response) {
            patterns.push({
                urlPattern: '*',
                requestStage: 'Response',
            });
        }
        if (patterns.length) {
            await this.#cdpClient.sendCommand('Fetch.enable', {
                patterns,
                handleAuthRequests: stages.auth,
            });
        }
        else {
            await this.#cdpClient.sendCommand('Fetch.disable');
        }
    }
    /**
     * Toggles both Network and Fetch domains.
     */
    async toggleNetworkIfNeeded() {
        const enabled = this.isSubscribedTo(chromium_bidi_js_1.BiDiModule.Network);
        if (enabled === this.#networkDomainEnabled) {
            return;
        }
        this.#networkDomainEnabled = enabled;
        try {
            await Promise.all([
                this.#cdpClient.sendCommand(enabled ? 'Network.enable' : 'Network.disable'),
                this.toggleFetchIfNeeded(),
            ]);
        }
        catch (err) {
            this.#logger?.(log_js_1.LogType.debugError, err);
            this.#networkDomainEnabled = !enabled;
        }
    }
    #setEventListeners() {
        this.#cdpClient.on('*', (event, params) => {
            // We may encounter uses for EventEmitter other than CDP events,
            // which we want to skip.
            if (typeof event !== 'string') {
                return;
            }
            this.#eventManager.registerEvent({
                type: 'event',
                method: `cdp.${event}`,
                params: {
                    event,
                    params,
                    session: this.cdpSessionId,
                },
            }, this.id);
        });
    }
    /**
     * All the ProxyChannels from all the preload scripts of the given
     * BrowsingContext.
     */
    getChannels() {
        return this.#preloadScriptStorage
            .find()
            .flatMap((script) => script.channels);
    }
    /** Loads all top-level preload scripts. */
    async #initAndEvaluatePreloadScripts() {
        await Promise.all(this.#preloadScriptStorage
            .find({
            // Needed for OOPIF
            targetId: this.topLevelId,
            global: true,
        })
            .map((script) => {
            return script.initInTarget(this, true);
        }));
    }
    get topLevelId() {
        return (this.#browsingContextStorage.findTopLevelContextId(this.id) ?? this.id);
    }
    isSubscribedTo(moduleOrEvent) {
        return this.#eventManager.subscriptionManager.isSubscribedTo(moduleOrEvent, this.topLevelId);
    }
}
exports.CdpTarget = CdpTarget;
//# sourceMappingURL=CdpTarget.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpTargetManager = void 0;
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BrowsingContextImpl_js_1 = __webpack_require__(/*! ../context/BrowsingContextImpl.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js");
const WorkerRealm_js_1 = __webpack_require__(/*! ../script/WorkerRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js");
const CdpTarget_js_1 = __webpack_require__(/*! ./CdpTarget.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js");
const cdpToBidiTargetTypes = {
    service_worker: 'service-worker',
    shared_worker: 'shared-worker',
    worker: 'dedicated-worker',
};
class CdpTargetManager {
    #browserCdpClient;
    #cdpConnection;
    #targetKeysToBeIgnoredByAutoAttach = new Set();
    #selfTargetId;
    #eventManager;
    #browsingContextStorage;
    #networkStorage;
    #preloadScriptStorage;
    #realmStorage;
    #defaultUserContextId;
    #logger;
    #unhandledPromptBehavior;
    constructor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, preloadScriptStorage, defaultUserContextId, unhandledPromptBehavior, logger) {
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
        this.#targetKeysToBeIgnoredByAutoAttach.add(selfTargetId);
        this.#selfTargetId = selfTargetId;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#realmStorage = realmStorage;
        this.#defaultUserContextId = defaultUserContextId;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
        this.#setEventListeners(browserCdpClient);
    }
    /**
     * This method is called for each CDP session, since this class is responsible
     * for creating and destroying all targets and browsing contexts.
     */
    #setEventListeners(cdpClient) {
        cdpClient.on('Target.attachedToTarget', (params) => {
            this.#handleAttachedToTargetEvent(params, cdpClient);
        });
        cdpClient.on('Target.detachedFromTarget', this.#handleDetachedFromTargetEvent.bind(this));
        cdpClient.on('Target.targetInfoChanged', this.#handleTargetInfoChangedEvent.bind(this));
        cdpClient.on('Inspector.targetCrashed', () => {
            this.#handleTargetCrashedEvent(cdpClient);
        });
        cdpClient.on('Page.frameAttached', this.#handleFrameAttachedEvent.bind(this));
        cdpClient.on('Page.frameDetached', this.#handleFrameDetachedEvent.bind(this));
    }
    #handleFrameAttachedEvent(params) {
        const parentBrowsingContext = this.#browsingContextStorage.findContext(params.parentFrameId);
        if (parentBrowsingContext !== undefined) {
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(params.frameId, params.parentFrameId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, 
            // At this point, we don't know the URL of the frame yet, so it will be updated
            // later.
            'about:blank', undefined, this.#unhandledPromptBehavior, this.#logger);
        }
    }
    #handleFrameDetachedEvent(params) {
        // In case of OOPiF no need in deleting BrowsingContext.
        if (params.reason === 'swap') {
            return;
        }
        this.#browsingContextStorage.findContext(params.frameId)?.dispose();
    }
    #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
        const { sessionId, targetInfo } = params;
        const targetCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        const detach = async () => {
            // Detaches and resumes the target suppressing errors.
            await targetCdpClient
                .sendCommand('Runtime.runIfWaitingForDebugger')
                .then(() => parentSessionCdpClient.sendCommand('Target.detachFromTarget', params))
                .catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
        };
        if (this.#selfTargetId !== targetInfo.targetId) {
            // Service workers are special case because they attach to the
            // browser target and the page target (so twice per worker) during
            // the regular auto-attach and might hang if the CDP session on
            // the browser level is not detached. The logic to detach the
            // right session is handled in the switch below.
            const targetKey = targetInfo.type === 'service_worker'
                ? `${parentSessionCdpClient.sessionId}_${targetInfo.targetId}`
                : targetInfo.targetId;
            // Mapper generally only needs one session per target. If we
            // receive additional auto-attached sessions, that is very likely
            // coming from custom CDP sessions.
            if (this.#targetKeysToBeIgnoredByAutoAttach.has(targetKey)) {
                // Return to leave the session untouched.
                return;
            }
            this.#targetKeysToBeIgnoredByAutoAttach.add(targetKey);
        }
        switch (targetInfo.type) {
            case 'page':
            case 'iframe': {
                if (this.#selfTargetId === targetInfo.targetId) {
                    void detach();
                    return;
                }
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                const maybeContext = this.#browsingContextStorage.findContext(targetInfo.targetId);
                if (maybeContext && targetInfo.type === 'iframe') {
                    // OOPiF.
                    maybeContext.updateCdpTarget(cdpTarget);
                }
                else {
                    const userContext = targetInfo.browserContextId &&
                        targetInfo.browserContextId !== this.#defaultUserContextId
                        ? targetInfo.browserContextId
                        : 'default';
                    // New context.
                    BrowsingContextImpl_js_1.BrowsingContextImpl.create(targetInfo.targetId, null, userContext, cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, 
                    // Hack: when a new target created, CDP emits targetInfoChanged with an empty
                    // url, and navigates it to about:blank later. When the event is emitted for
                    // an existing target (reconnect), the url is already known, and navigation
                    // events will not be emitted anymore. Replacing empty url with `about:blank`
                    // allows to handle both cases in the same way.
                    // "7.3.2.1 Creating browsing contexts".
                    // https://html.spec.whatwg.org/multipage/document-sequences.html#creating-browsing-contexts
                    // TODO: check who to deal with non-null creator and its `creatorOrigin`.
                    targetInfo.url === '' ? 'about:blank' : targetInfo.url, targetInfo.openerFrameId ?? targetInfo.openerId, this.#unhandledPromptBehavior, this.#logger);
                }
                return;
            }
            case 'service_worker':
            case 'worker': {
                const realm = this.#realmStorage.findRealm({
                    cdpSessionId: parentSessionCdpClient.sessionId,
                });
                // If there is no browsing context, this worker is already terminated.
                if (!realm) {
                    void detach();
                    return;
                }
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget, realm);
                return;
            }
            // In CDP, we only emit shared workers on the browser and not the set of
            // frames that use the shared worker. If we change this in the future to
            // behave like service workers (emits on both browser and frame targets),
            // we can remove this block and merge service workers with the above one.
            case 'shared_worker': {
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget);
                return;
            }
        }
        // DevTools or some other not supported by BiDi target. Just release
        // debugger and ignore them.
        void detach();
    }
    #createCdpTarget(targetCdpClient, targetInfo) {
        this.#setEventListeners(targetCdpClient);
        const target = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, this.#browserCdpClient, this.#realmStorage, this.#eventManager, this.#preloadScriptStorage, this.#browsingContextStorage, this.#networkStorage, this.#unhandledPromptBehavior, this.#logger);
        this.#networkStorage.onCdpTargetCreated(target);
        return target;
    }
    #workers = new Map();
    #handleWorkerTarget(realmType, cdpTarget, ownerRealm) {
        cdpTarget.cdpClient.on('Runtime.executionContextCreated', (params) => {
            const { uniqueId, id, origin } = params.context;
            const workerRealm = new WorkerRealm_js_1.WorkerRealm(cdpTarget.cdpClient, this.#eventManager, id, this.#logger, (0, BrowsingContextImpl_js_1.serializeOrigin)(origin), ownerRealm ? [ownerRealm] : [], uniqueId, this.#realmStorage, realmType);
            this.#workers.set(cdpTarget.cdpSessionId, workerRealm);
        });
    }
    #handleDetachedFromTargetEvent({ sessionId, targetId, }) {
        if (targetId) {
            this.#preloadScriptStorage.find({ targetId }).map((preloadScript) => {
                preloadScript.dispose(targetId);
            });
        }
        const context = this.#browsingContextStorage.findContextBySession(sessionId);
        if (context) {
            context.dispose();
            return;
        }
        const worker = this.#workers.get(sessionId);
        if (worker) {
            this.#realmStorage.deleteRealms({
                cdpSessionId: worker.cdpClient.sessionId,
            });
        }
    }
    #handleTargetInfoChangedEvent(params) {
        const context = this.#browsingContextStorage.findContext(params.targetInfo.targetId);
        if (context) {
            context.onTargetInfoChanged(params);
        }
    }
    #handleTargetCrashedEvent(cdpClient) {
        // This is primarily used for service and shared workers. CDP tends to not
        // signal they closed gracefully and instead says they crashed to signal
        // they are closed.
        const realms = this.#realmStorage.findRealms({
            cdpSessionId: cdpClient.sessionId,
        });
        for (const realm of realms) {
            realm.dispose();
        }
    }
}
exports.CdpTargetManager = CdpTargetManager;
//# sourceMappingURL=CdpTargetManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextImpl = void 0;
exports.serializeOrigin = serializeOrigin;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const unitConversions_js_1 = __webpack_require__(/*! ../../../utils/unitConversions.js */ "./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js");
const uuid_1 = __webpack_require__(/*! ../../../utils/uuid */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const WindowRealm_js_1 = __webpack_require__(/*! ../script/WindowRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js");
class BrowsingContextImpl {
    static LOGGER_PREFIX = `${log_js_1.LogType.debug}:browsingContext`;
    /** The ID of this browsing context. */
    #id;
    userContext;
    /**
     * The ID of the parent browsing context.
     * If null, this is a top-level context.
     */
    #parentId = null;
    /** Direct children browsing contexts. */
    #children = new Set();
    #browsingContextStorage;
    #lifecycle = {
        DOMContentLoaded: new Deferred_js_1.Deferred(),
        load: new Deferred_js_1.Deferred(),
    };
    #navigation = {
        withinDocument: new Deferred_js_1.Deferred(),
    };
    #url;
    #eventManager;
    #realmStorage;
    #loaderId;
    #cdpTarget;
    // The deferred will be resolved when the default realm is created.
    #defaultRealmDeferred = new Deferred_js_1.Deferred();
    #logger;
    // Keeps track of the previously set viewport.
    #previousViewport = { width: 0, height: 0 };
    // The URL of the navigation that is currently in progress. A workaround of the CDP
    // lacking URL for the pending navigation events, e.g. `Page.frameStartedLoading`.
    // Set on `Page.navigate`, `Page.reload` commands and on deprecated CDP event
    // `Page.frameScheduledNavigation`.
    #pendingNavigationUrl;
    #virtualNavigationId = (0, uuid_1.uuidv4)();
    #originalOpener;
    // Set when the user prompt is opened. Required to provide the type in closing event.
    #lastUserPromptType;
    #unhandledPromptBehavior;
    constructor(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        this.#cdpTarget = cdpTarget;
        this.#id = id;
        this.#parentId = parentId;
        this.userContext = userContext;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
        this.#url = url;
        this.#originalOpener = originalOpener;
    }
    static create(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        const context = new BrowsingContextImpl(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger);
        context.#initListeners();
        browsingContextStorage.addContext(context);
        if (!context.isTopLevelContext()) {
            context.parent.addChild(context.id);
        }
        // Hold on the `contextCreated` event until the target is unblocked. This is required,
        // as the parent of the context can be set later in case of reconnecting to an
        // existing browser instance + OOPiF.
        eventManager.registerPromiseEvent(context.targetUnblockedOrThrow().then(() => {
            return {
                kind: 'success',
                value: {
                    type: 'event',
                    method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
                    params: context.serializeToBidiValue(),
                },
            };
        }, (error) => {
            return {
                kind: 'error',
                error,
            };
        }), context.id, protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated);
        return context;
    }
    static getTimestamp() {
        // `timestamp` from the event is MonotonicTime, not real time, so
        // the best Mapper can do is to set the timestamp to the epoch time
        // of the event arrived.
        // https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-MonotonicTime
        return new Date().getTime();
    }
    /**
     * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
     */
    get navigableId() {
        return this.#loaderId;
    }
    /**
     * Virtual navigation ID. Required, as CDP `loaderId` cannot be mapped 1:1 to all the
     * navigations (e.g. same document navigations). Updated after each navigation,
     * including same-document ones.
     */
    get virtualNavigationId() {
        return this.#virtualNavigationId;
    }
    dispose() {
        this.#deleteAllChildren();
        this.#realmStorage.deleteRealms({
            browsingContextId: this.id,
        });
        // Remove context from the parent.
        if (!this.isTopLevelContext()) {
            this.parent.#children.delete(this.id);
        }
        // Fail all ongoing navigations.
        this.#failLifecycleIfNotFinished();
        this.#eventManager.registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
            params: this.serializeToBidiValue(),
        }, this.id);
        this.#browsingContextStorage.deleteContextById(this.id);
    }
    /** Returns the ID of this context. */
    get id() {
        return this.#id;
    }
    /** Returns the parent context ID. */
    get parentId() {
        return this.#parentId;
    }
    /** Sets the parent context ID and updates parent's children. */
    set parentId(parentId) {
        if (this.#parentId !== null) {
            this.#logger?.(log_js_1.LogType.debugError, 'Parent context already set');
            // Cannot do anything except logging, as throwing will stop event processing. So
            // just return,
            return;
        }
        this.#parentId = parentId;
        if (!this.isTopLevelContext()) {
            this.parent.addChild(this.id);
        }
    }
    /** Returns the parent context. */
    get parent() {
        if (this.parentId === null) {
            return null;
        }
        return this.#browsingContextStorage.getContext(this.parentId);
    }
    /** Returns all direct children contexts. */
    get directChildren() {
        return [...this.#children].map((id) => this.#browsingContextStorage.getContext(id));
    }
    /** Returns all children contexts, flattened. */
    get allChildren() {
        const children = this.directChildren;
        return children.concat(...children.map((child) => child.allChildren));
    }
    /**
     * Returns true if this is a top-level context.
     * This is the case whenever the parent context ID is null.
     */
    isTopLevelContext() {
        return this.#parentId === null;
    }
    get top() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let topContext = this;
        let parent = topContext.parent;
        while (parent) {
            topContext = parent;
            parent = topContext.parent;
        }
        return topContext;
    }
    addChild(childId) {
        this.#children.add(childId);
    }
    #deleteAllChildren() {
        this.directChildren.map((child) => child.dispose());
    }
    get cdpTarget() {
        return this.#cdpTarget;
    }
    updateCdpTarget(cdpTarget) {
        this.#cdpTarget = cdpTarget;
        this.#initListeners();
    }
    get url() {
        return this.#url;
    }
    async lifecycleLoaded() {
        await this.#lifecycle.load;
    }
    async targetUnblockedOrThrow() {
        const result = await this.#cdpTarget.unblocked;
        if (result.kind === 'error') {
            throw result.error;
        }
    }
    async getOrCreateSandbox(sandbox) {
        if (sandbox === undefined || sandbox === '') {
            // Default realm is not guaranteed to be created at this point, so return a deferred.
            return await this.#defaultRealmDeferred;
        }
        let maybeSandboxes = this.#realmStorage.findRealms({
            browsingContextId: this.id,
            sandbox,
        });
        if (maybeSandboxes.length === 0) {
            await this.#cdpTarget.cdpClient.sendCommand('Page.createIsolatedWorld', {
                frameId: this.id,
                worldName: sandbox,
            });
            // `Runtime.executionContextCreated` should be emitted by the time the
            // previous command is done.
            maybeSandboxes = this.#realmStorage.findRealms({
                browsingContextId: this.id,
                sandbox,
            });
            (0, assert_js_1.assert)(maybeSandboxes.length !== 0);
        }
        // It's possible for more than one sandbox to be created due to provisional
        // frames. In this case, it's always the first one (i.e. the oldest one)
        // that is more relevant since the user may have set that one up already
        // through evaluation.
        return maybeSandboxes[0];
    }
    serializeToBidiValue(maxDepth = 0, addParentField = true) {
        return {
            context: this.#id,
            url: this.url,
            userContext: this.userContext,
            originalOpener: this.#originalOpener ?? null,
            children: maxDepth > 0
                ? this.directChildren.map((c) => c.serializeToBidiValue(maxDepth - 1, false))
                : null,
            ...(addParentField ? { parent: this.#parentId } : {}),
        };
    }
    onTargetInfoChanged(params) {
        this.#url = params.targetInfo.url;
    }
    #initListeners() {
        this.#cdpTarget.cdpClient.on('Page.frameNavigated', (params) => {
            if (this.id !== params.frame.id) {
                return;
            }
            this.#url = params.frame.url + (params.frame.urlFragment ?? '');
            this.#pendingNavigationUrl = undefined;
            // At the point the page is initialized, all the nested iframes from the
            // previous page are detached and realms are destroyed.
            // Remove children from context.
            this.#deleteAllChildren();
        });
        this.#cdpTarget.cdpClient.on('Page.navigatedWithinDocument', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            this.#pendingNavigationUrl = undefined;
            const timestamp = BrowsingContextImpl.getTimestamp();
            this.#url = params.url;
            this.#navigation.withinDocument.resolve();
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.FragmentNavigated,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp,
                    url: this.#url,
                },
            }, this.id);
        });
        this.#cdpTarget.cdpClient.on('Page.frameStartedLoading', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            // Generate a new virtual navigation id.
            this.#virtualNavigationId = (0, uuid_1.uuidv4)();
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp: BrowsingContextImpl.getTimestamp(),
                    // The URL of the navigation that is currently in progress. Although the URL
                    // is not yet known in case of user-initiated navigations, it is possible to
                    // provide the URL in case of BiDi-initiated navigations.
                    // TODO: provide proper URL in case of user-initiated navigations.
                    url: this.#pendingNavigationUrl ?? 'UNKNOWN',
                },
            }, this.id);
        });
        // TODO: don't use deprecated `Page.frameScheduledNavigation` event.
        this.#cdpTarget.cdpClient.on('Page.frameScheduledNavigation', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            this.#pendingNavigationUrl = params.url;
        });
        this.#cdpTarget.cdpClient.on('Page.lifecycleEvent', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            if (params.name === 'init') {
                this.#documentChanged(params.loaderId);
                return;
            }
            if (params.name === 'commit') {
                this.#loaderId = params.loaderId;
                return;
            }
            // If mapper attached to the page late, it might miss init and
            // commit events. In that case, save the first loaderId for this
            // frameId.
            if (!this.#loaderId) {
                this.#loaderId = params.loaderId;
            }
            // Ignore event from not current navigation.
            if (params.loaderId !== this.#loaderId) {
                return;
            }
            const timestamp = BrowsingContextImpl.getTimestamp();
            switch (params.name) {
                case 'DOMContentLoaded':
                    this.#eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                        params: {
                            context: this.id,
                            navigation: this.#virtualNavigationId,
                            timestamp,
                            url: this.#url,
                        },
                    }, this.id);
                    this.#lifecycle.DOMContentLoaded.resolve();
                    break;
                case 'load':
                    this.#eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.Load,
                        params: {
                            context: this.id,
                            navigation: this.#virtualNavigationId,
                            timestamp,
                            url: this.#url,
                        },
                    }, this.id);
                    this.#lifecycle.load.resolve();
                    break;
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextCreated', (params) => {
            const { auxData, name, uniqueId, id } = params.context;
            if (!auxData || auxData.frameId !== this.id) {
                return;
            }
            let origin;
            let sandbox;
            // Only these execution contexts are supported for now.
            switch (auxData.type) {
                case 'isolated':
                    sandbox = name;
                    // Sandbox should have the same origin as the context itself, but in CDP
                    // it has an empty one.
                    if (!this.#defaultRealmDeferred.isFinished) {
                        this.#logger?.(log_js_1.LogType.debugError, 'Unexpectedly, isolated realm created before the default one');
                    }
                    origin = this.#defaultRealmDeferred.isFinished
                        ? this.#defaultRealmDeferred.result.origin
                        : // This fallback is not expected to be ever reached.
                            '';
                    break;
                case 'default':
                    origin = serializeOrigin(params.context.origin);
                    break;
                default:
                    return;
            }
            const realm = new WindowRealm_js_1.WindowRealm(this.id, this.#browsingContextStorage, this.#cdpTarget.cdpClient, this.#eventManager, id, this.#logger, origin, uniqueId, this.#realmStorage, sandbox);
            if (auxData.isDefault) {
                this.#defaultRealmDeferred.resolve(realm);
                // Initialize ChannelProxy listeners for all the channels of all the
                // preload scripts related to this BrowsingContext.
                // TODO: extend for not default realms by the sandbox name.
                void Promise.all(this.#cdpTarget
                    .getChannels()
                    .map((channel) => channel.startListenerFromWindow(realm, this.#eventManager)));
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextDestroyed', (params) => {
            if (this.#defaultRealmDeferred.isFinished &&
                this.#defaultRealmDeferred.result.executionContextId ===
                    params.executionContextId) {
                this.#defaultRealmDeferred = new Deferred_js_1.Deferred();
            }
            this.#realmStorage.deleteRealms({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.executionContextId,
            });
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextsCleared', () => {
            if (!this.#defaultRealmDeferred.isFinished) {
                this.#defaultRealmDeferred.reject(new protocol_js_1.UnknownErrorException('execution contexts cleared'));
            }
            this.#defaultRealmDeferred = new Deferred_js_1.Deferred();
            this.#realmStorage.deleteRealms({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
            });
        });
        this.#cdpTarget.cdpClient.on('Page.javascriptDialogClosed', (params) => {
            const accepted = params.result;
            if (this.#lastUserPromptType === undefined) {
                this.#logger?.(log_js_1.LogType.debugError, 'Unexpectedly no opening prompt event before closing one');
            }
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
                params: {
                    context: this.id,
                    accepted,
                    // `lastUserPromptType` should never be undefined here, so fallback to
                    // `UNKNOWN`. The fallback is required to prevent tests from hanging while
                    // waiting for the closing event. The cast is required, as the `UNKNOWN` value
                    // is not standard.
                    type: this.#lastUserPromptType ??
                        'UNKNOWN',
                    userText: accepted && params.userInput ? params.userInput : undefined,
                },
            }, this.id);
            this.#lastUserPromptType = undefined;
        });
        this.#cdpTarget.cdpClient.on('Page.javascriptDialogOpening', (params) => {
            const promptType = BrowsingContextImpl.#getPromptType(params.type);
            // Set the last prompt type to provide it in closing event.
            this.#lastUserPromptType = promptType;
            const promptHandler = this.#getPromptHandler(promptType);
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
                params: {
                    context: this.id,
                    handler: promptHandler,
                    type: promptType,
                    message: params.message,
                    ...(params.type === 'prompt'
                        ? { defaultValue: params.defaultPrompt }
                        : {}),
                },
            }, this.id);
            switch (promptHandler) {
                // Based on `unhandledPromptBehavior`, check if the prompt should be handled
                // automatically (`accept`, `dismiss`) or wait for the user to do it.
                case "accept" /* Session.UserPromptHandlerType.Accept */:
                    void this.handleUserPrompt(true);
                    break;
                case "dismiss" /* Session.UserPromptHandlerType.Dismiss */:
                    void this.handleUserPrompt(false);
                    break;
                case "ignore" /* Session.UserPromptHandlerType.Ignore */:
                    break;
            }
        });
    }
    static #getPromptType(cdpType) {
        switch (cdpType) {
            case 'alert':
                return "alert" /* BrowsingContext.UserPromptType.Alert */;
            case 'beforeunload':
                return "beforeunload" /* BrowsingContext.UserPromptType.Beforeunload */;
            case 'confirm':
                return "confirm" /* BrowsingContext.UserPromptType.Confirm */;
            case 'prompt':
                return "prompt" /* BrowsingContext.UserPromptType.Prompt */;
        }
    }
    #getPromptHandler(promptType) {
        const defaultPromptHandler = "dismiss" /* Session.UserPromptHandlerType.Dismiss */;
        switch (promptType) {
            case "alert" /* BrowsingContext.UserPromptType.Alert */:
                return (this.#unhandledPromptBehavior?.alert ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
            case "beforeunload" /* BrowsingContext.UserPromptType.Beforeunload */:
                return (this.#unhandledPromptBehavior?.beforeUnload ??
                    this.#unhandledPromptBehavior?.default ??
                    "accept" /* Session.UserPromptHandlerType.Accept */);
            case "confirm" /* BrowsingContext.UserPromptType.Confirm */:
                return (this.#unhandledPromptBehavior?.confirm ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
            case "prompt" /* BrowsingContext.UserPromptType.Prompt */:
                return (this.#unhandledPromptBehavior?.prompt ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
        }
    }
    #documentChanged(loaderId) {
        // Same document navigation.
        if (loaderId === undefined || this.#loaderId === loaderId) {
            if (this.#navigation.withinDocument.isFinished) {
                this.#navigation.withinDocument = new Deferred_js_1.Deferred();
            }
            else {
                this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (navigatedWithinDocument)');
            }
            return;
        }
        this.#resetLifecycleIfFinished();
        this.#loaderId = loaderId;
    }
    #resetLifecycleIfFinished() {
        if (this.#lifecycle.DOMContentLoaded.isFinished) {
            this.#lifecycle.DOMContentLoaded = new Deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (DOMContentLoaded)');
        }
        if (this.#lifecycle.load.isFinished) {
            this.#lifecycle.load = new Deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (load)');
        }
    }
    #failLifecycleIfNotFinished() {
        if (!this.#lifecycle.DOMContentLoaded.isFinished) {
            this.#lifecycle.DOMContentLoaded.reject(new protocol_js_1.UnknownErrorException('navigation canceled'));
        }
        if (!this.#lifecycle.load.isFinished) {
            this.#lifecycle.load.reject(new protocol_js_1.UnknownErrorException('navigation canceled'));
        }
    }
    async navigate(url, wait) {
        try {
            new URL(url);
        }
        catch {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL: ${url}`);
        }
        await this.targetUnblockedOrThrow();
        // Set the pending navigation URL to provide it in `browsingContext.navigationStarted`
        // event.
        // TODO: detect navigation start not from CDP. Check if
        //  `Page.frameRequestedNavigation` can be used for this purpose.
        this.#pendingNavigationUrl = url;
        // TODO: handle loading errors.
        const cdpNavigateResult = await this.#cdpTarget.cdpClient.sendCommand('Page.navigate', {
            url,
            frameId: this.id,
        });
        if (cdpNavigateResult.errorText) {
            // If navigation failed, no pending navigation is left.
            this.#pendingNavigationUrl = undefined;
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationFailed,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp: BrowsingContextImpl.getTimestamp(),
                    url,
                },
            }, this.id);
            throw new protocol_js_1.UnknownErrorException(cdpNavigateResult.errorText);
        }
        this.#documentChanged(cdpNavigateResult.loaderId);
        switch (wait) {
            case "none" /* BrowsingContext.ReadinessState.None */:
                break;
            case "interactive" /* BrowsingContext.ReadinessState.Interactive */:
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#navigation.withinDocument;
                }
                else {
                    await this.#lifecycle.DOMContentLoaded;
                }
                break;
            case "complete" /* BrowsingContext.ReadinessState.Complete */:
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#navigation.withinDocument;
                }
                else {
                    await this.#lifecycle.load;
                }
                break;
        }
        return {
            navigation: this.#virtualNavigationId,
            // Url can change due to redirect get the latest one.
            url: wait === "none" /* BrowsingContext.ReadinessState.None */ ? url : this.#url,
        };
    }
    async reload(ignoreCache, wait) {
        await this.targetUnblockedOrThrow();
        this.#resetLifecycleIfFinished();
        await this.#cdpTarget.cdpClient.sendCommand('Page.reload', {
            ignoreCache,
        });
        switch (wait) {
            case "none" /* BrowsingContext.ReadinessState.None */:
                break;
            case "interactive" /* BrowsingContext.ReadinessState.Interactive */:
                await this.#lifecycle.DOMContentLoaded;
                break;
            case "complete" /* BrowsingContext.ReadinessState.Complete */:
                await this.#lifecycle.load;
                break;
        }
        return {
            navigation: this.#virtualNavigationId,
            url: this.url,
        };
    }
    async setViewport(viewport, devicePixelRatio) {
        if (viewport === null && devicePixelRatio === null) {
            await this.#cdpTarget.cdpClient.sendCommand('Emulation.clearDeviceMetricsOverride');
        }
        else {
            try {
                let appliedViewport;
                if (viewport === undefined) {
                    appliedViewport = this.#previousViewport;
                }
                else if (viewport === null) {
                    appliedViewport = {
                        width: 0,
                        height: 0,
                    };
                }
                else {
                    appliedViewport = viewport;
                }
                this.#previousViewport = appliedViewport;
                await this.#cdpTarget.cdpClient.sendCommand('Emulation.setDeviceMetricsOverride', {
                    width: this.#previousViewport.width,
                    height: this.#previousViewport.height,
                    deviceScaleFactor: devicePixelRatio ? devicePixelRatio : 0,
                    mobile: false,
                    dontSetVisibleSize: true,
                });
            }
            catch (err) {
                if (err.message.startsWith(
                // https://crsrc.org/c/content/browser/devtools/protocol/emulation_handler.cc;l=257;drc=2f6eee84cf98d4227e7c41718dd71b82f26d90ff
                'Width and height values must be positive')) {
                    throw new protocol_js_1.UnsupportedOperationException('Provided viewport dimensions are not supported');
                }
                throw err;
            }
        }
    }
    async handleUserPrompt(accept, userText) {
        await this.#cdpTarget.cdpClient.sendCommand('Page.handleJavaScriptDialog', {
            accept: accept ?? true,
            promptText: userText,
        });
    }
    async activate() {
        await this.#cdpTarget.cdpClient.sendCommand('Page.bringToFront');
    }
    async captureScreenshot(params) {
        if (!this.isTopLevelContext()) {
            throw new protocol_js_1.UnsupportedOperationException(`Non-top-level 'context' (${params.context}) is currently not supported`);
        }
        const formatParameters = getImageFormatParameters(params);
        // XXX: Focus the original tab after the screenshot is taken.
        // This is needed because the screenshot gets blocked until the active tab gets focus.
        await this.#cdpTarget.cdpClient.sendCommand('Page.bringToFront');
        let captureBeyondViewport = false;
        let script;
        params.origin ??= 'viewport';
        switch (params.origin) {
            case 'document': {
                script = String(() => {
                    const element = document.documentElement;
                    return {
                        x: 0,
                        y: 0,
                        width: element.scrollWidth,
                        height: element.scrollHeight,
                    };
                });
                captureBeyondViewport = true;
                break;
            }
            case 'viewport': {
                script = String(() => {
                    const viewport = window.visualViewport;
                    return {
                        x: viewport.pageLeft,
                        y: viewport.pageTop,
                        width: viewport.width,
                        height: viewport.height,
                    };
                });
                break;
            }
        }
        const realm = await this.getOrCreateSandbox(undefined);
        const originResult = await realm.callFunction(script, false);
        (0, assert_js_1.assert)(originResult.type === 'success');
        const origin = deserializeDOMRect(originResult.result);
        (0, assert_js_1.assert)(origin);
        let rect = origin;
        if (params.clip) {
            const clip = params.clip;
            if (params.origin === 'viewport' && clip.type === 'box') {
                // For viewport origin, the clip is relative to the viewport, while the CDP
                // screenshot is relative to the document. So correction for the viewport position
                // is required.
                clip.x += origin.x;
                clip.y += origin.y;
            }
            rect = getIntersectionRect(await this.#parseRect(clip), origin);
        }
        if (rect.width === 0 || rect.height === 0) {
            throw new protocol_js_1.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${rect.width}, height=${rect.height}`);
        }
        return await this.#cdpTarget.cdpClient.sendCommand('Page.captureScreenshot', {
            clip: { ...rect, scale: 1.0 },
            ...formatParameters,
            captureBeyondViewport,
        });
    }
    async print(params) {
        const cdpParams = {};
        if (params.background !== undefined) {
            cdpParams.printBackground = params.background;
        }
        if (params.margin?.bottom !== undefined) {
            cdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
        }
        if (params.margin?.left !== undefined) {
            cdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
        }
        if (params.margin?.right !== undefined) {
            cdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
        }
        if (params.margin?.top !== undefined) {
            cdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
        }
        if (params.orientation !== undefined) {
            cdpParams.landscape = params.orientation === 'landscape';
        }
        if (params.page?.height !== undefined) {
            cdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
        }
        if (params.page?.width !== undefined) {
            cdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
        }
        if (params.pageRanges !== undefined) {
            for (const range of params.pageRanges) {
                if (typeof range === 'number') {
                    continue;
                }
                const rangeParts = range.split('-');
                if (rangeParts.length < 1 || rangeParts.length > 2) {
                    throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${range} is not a valid integer range.`);
                }
                if (rangeParts.length === 1) {
                    void parseInteger(rangeParts[0] ?? '');
                    continue;
                }
                let lowerBound;
                let upperBound;
                const [rangeLowerPart = '', rangeUpperPart = ''] = rangeParts;
                if (rangeLowerPart === '') {
                    lowerBound = 1;
                }
                else {
                    lowerBound = parseInteger(rangeLowerPart);
                }
                if (rangeUpperPart === '') {
                    upperBound = Number.MAX_SAFE_INTEGER;
                }
                else {
                    upperBound = parseInteger(rangeUpperPart);
                }
                if (lowerBound > upperBound) {
                    throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${rangeLowerPart} > ${rangeUpperPart}`);
                }
            }
            cdpParams.pageRanges = params.pageRanges.join(',');
        }
        if (params.scale !== undefined) {
            cdpParams.scale = params.scale;
        }
        if (params.shrinkToFit !== undefined) {
            cdpParams.preferCSSPageSize = !params.shrinkToFit;
        }
        try {
            const result = await this.#cdpTarget.cdpClient.sendCommand('Page.printToPDF', cdpParams);
            return {
                data: result.data,
            };
        }
        catch (error) {
            // Effectively zero dimensions.
            if (error.message ===
                'invalid print parameters: content area is empty') {
                throw new protocol_js_1.UnsupportedOperationException(error.message);
            }
            throw error;
        }
    }
    /**
     * See
     * https://w3c.github.io/webdriver-bidi/#:~:text=If%20command%20parameters%20contains%20%22clip%22%3A
     */
    async #parseRect(clip) {
        switch (clip.type) {
            case 'box':
                return { x: clip.x, y: clip.y, width: clip.width, height: clip.height };
            case 'element': {
                // TODO: #1213: Use custom sandbox specifically for Chromium BiDi
                const sandbox = await this.getOrCreateSandbox(undefined);
                const result = await sandbox.callFunction(String((element) => {
                    return element instanceof Element;
                }), false, { type: 'undefined' }, [clip.element]);
                if (result.type === 'exception') {
                    throw new protocol_js_1.NoSuchElementException(`Element '${clip.element.sharedId}' was not found`);
                }
                (0, assert_js_1.assert)(result.result.type === 'boolean');
                if (!result.result.value) {
                    throw new protocol_js_1.NoSuchElementException(`Node '${clip.element.sharedId}' is not an Element`);
                }
                {
                    const result = await sandbox.callFunction(String((element) => {
                        const rect = element.getBoundingClientRect();
                        return {
                            x: rect.x,
                            y: rect.y,
                            height: rect.height,
                            width: rect.width,
                        };
                    }), false, { type: 'undefined' }, [clip.element]);
                    (0, assert_js_1.assert)(result.type === 'success');
                    const rect = deserializeDOMRect(result.result);
                    if (!rect) {
                        throw new protocol_js_1.UnableToCaptureScreenException(`Could not get bounding box for Element '${clip.element.sharedId}'`);
                    }
                    return rect;
                }
            }
        }
    }
    async close() {
        await this.#cdpTarget.cdpClient.sendCommand('Page.close');
    }
    async traverseHistory(delta) {
        if (delta === 0) {
            return;
        }
        const history = await this.#cdpTarget.cdpClient.sendCommand('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
            throw new protocol_js_1.NoSuchHistoryEntryException(`No history entry at delta ${delta}`);
        }
        await this.#cdpTarget.cdpClient.sendCommand('Page.navigateToHistoryEntry', {
            entryId: entry.id,
        });
    }
    async toggleModulesIfNeeded() {
        await this.#cdpTarget.toggleNetworkIfNeeded();
    }
    async locateNodes(params) {
        // TODO: create a dedicated sandbox instead of `#defaultRealm`.
        return await this.#locateNodesByLocator(await this.#defaultRealmDeferred, params.locator, params.startNodes ?? [], params.maxNodeCount, params.serializationOptions);
    }
    async #getLocatorDelegate(realm, locator, maxNodeCount, startNodes) {
        switch (locator.type) {
            case 'css':
                return {
                    functionDeclaration: String((cssSelector, maxNodeCount, ...startNodes) => {
                        const locateNodesUsingCss = (element) => {
                            if (!(element instanceof HTMLElement ||
                                element instanceof Document ||
                                element instanceof DocumentFragment)) {
                                throw new Error('startNodes in css selector should be HTMLElement, Document or DocumentFragment');
                            }
                            return [...element.querySelectorAll(cssSelector)];
                        };
                        startNodes = startNodes.length > 0 ? startNodes : [document];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingCss(startNode))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `cssSelector`
                        { type: 'string', value: locator.value },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'xpath':
                return {
                    functionDeclaration: String((xPathSelector, maxNodeCount, ...startNodes) => {
                        // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-xpath
                        const evaluator = new XPathEvaluator();
                        const expression = evaluator.createExpression(xPathSelector);
                        const locateNodesUsingXpath = (element) => {
                            const xPathResult = expression.evaluate(element, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
                            const returnedNodes = [];
                            for (let i = 0; i < xPathResult.snapshotLength; i++) {
                                returnedNodes.push(xPathResult.snapshotItem(i));
                            }
                            return returnedNodes;
                        };
                        startNodes = startNodes.length > 0 ? startNodes : [document];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingXpath(startNode))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `xPathSelector`
                        { type: 'string', value: locator.value },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'innerText':
                // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-inner-text
                if (locator.value === '') {
                    throw new protocol_js_1.InvalidSelectorException('innerText locator cannot be empty');
                }
                return {
                    functionDeclaration: String((innerTextSelector, fullMatch, ignoreCase, maxNodeCount, maxDepth, ...startNodes) => {
                        const searchText = ignoreCase
                            ? innerTextSelector.toUpperCase()
                            : innerTextSelector;
                        const locateNodesUsingInnerText = (node, currentMaxDepth) => {
                            const returnedNodes = [];
                            if (node instanceof DocumentFragment ||
                                node instanceof Document) {
                                const children = [...node.children];
                                children.forEach((child) => 
                                // `currentMaxDepth` is not decremented intentionally according to
                                // https://github.com/w3c/webdriver-bidi/pull/713.
                                returnedNodes.push(...locateNodesUsingInnerText(child, currentMaxDepth)));
                                return returnedNodes;
                            }
                            if (!(node instanceof HTMLElement)) {
                                return [];
                            }
                            const element = node;
                            const nodeInnerText = ignoreCase
                                ? element.innerText?.toUpperCase()
                                : element.innerText;
                            if (!nodeInnerText.includes(searchText)) {
                                return [];
                            }
                            const childNodes = [];
                            for (const child of element.children) {
                                if (child instanceof HTMLElement) {
                                    childNodes.push(child);
                                }
                            }
                            if (childNodes.length === 0) {
                                if (fullMatch && nodeInnerText === searchText) {
                                    returnedNodes.push(element);
                                }
                                else {
                                    if (!fullMatch) {
                                        // Note: `nodeInnerText.includes(searchText)` is already checked
                                        returnedNodes.push(element);
                                    }
                                }
                            }
                            else {
                                const childNodeMatches = 
                                // Don't search deeper if `maxDepth` is reached.
                                currentMaxDepth <= 0
                                    ? []
                                    : childNodes
                                        .map((child) => locateNodesUsingInnerText(child, currentMaxDepth - 1))
                                        .flat(1);
                                if (childNodeMatches.length === 0) {
                                    // Note: `nodeInnerText.includes(searchText)` is already checked
                                    if (!fullMatch || nodeInnerText === searchText) {
                                        returnedNodes.push(element);
                                    }
                                }
                                else {
                                    returnedNodes.push(...childNodeMatches);
                                }
                            }
                            // TODO: stop search early if `maxNodeCount` is reached.
                            return returnedNodes;
                        };
                        // TODO: stop search early if `maxNodeCount` is reached.
                        startNodes = startNodes.length > 0 ? startNodes : [document];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingInnerText(startNode, maxDepth))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `innerTextSelector`
                        { type: 'string', value: locator.value },
                        // `fullMatch` with default `true`.
                        { type: 'boolean', value: locator.matchType !== 'partial' },
                        // `ignoreCase` with default `false`.
                        { type: 'boolean', value: locator.ignoreCase === true },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `maxDepth` with default `1000` (same as default full serialization depth).
                        { type: 'number', value: locator.maxDepth ?? 1000 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'accessibility': {
                // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-accessibility-attributes
                if (!locator.value.name && !locator.value.role) {
                    throw new protocol_js_1.InvalidSelectorException('Either name or role has to be specified');
                }
                // The next two commands cause a11y caches for the target to be
                // preserved. We probably do not need to disable them if the
                // client is using a11y features, but we could by calling
                // Accessibility.disable.
                await Promise.all([
                    this.#cdpTarget.cdpClient.sendCommand('Accessibility.enable'),
                    this.#cdpTarget.cdpClient.sendCommand('Accessibility.getRootAXNode'),
                ]);
                const bindings = await realm.evaluate(
                /* expression=*/ '({getAccessibleName, getAccessibleRole})', 
                /* awaitPromise=*/ false, "root" /* Script.ResultOwnership.Root */, 
                /* serializationOptions= */ undefined, 
                /* userActivation=*/ false, 
                /* includeCommandLineApi=*/ true);
                if (bindings.type !== 'success') {
                    throw new Error('Could not get bindings');
                }
                if (bindings.result.type !== 'object') {
                    throw new Error('Could not get bindings');
                }
                return {
                    functionDeclaration: String((name, role, bindings, maxNodeCount, ...startNodes) => {
                        const returnedNodes = [];
                        let aborted = false;
                        function collect(contextNodes, selector) {
                            if (aborted) {
                                return;
                            }
                            for (const contextNode of contextNodes) {
                                let match = true;
                                if (selector.role) {
                                    const role = bindings.getAccessibleRole(contextNode);
                                    if (selector.role !== role) {
                                        match = false;
                                    }
                                }
                                if (selector.name) {
                                    const name = bindings.getAccessibleName(contextNode);
                                    if (selector.name !== name) {
                                        match = false;
                                    }
                                }
                                if (match) {
                                    if (maxNodeCount !== 0 &&
                                        returnedNodes.length === maxNodeCount) {
                                        aborted = true;
                                        break;
                                    }
                                    returnedNodes.push(contextNode);
                                }
                                const childNodes = [];
                                for (const child of contextNode.children) {
                                    if (child instanceof HTMLElement) {
                                        childNodes.push(child);
                                    }
                                }
                                collect(childNodes, selector);
                            }
                        }
                        startNodes =
                            startNodes.length > 0
                                ? startNodes
                                : Array.from(document.documentElement.children).filter((c) => c instanceof HTMLElement);
                        collect(startNodes, {
                            role,
                            name,
                        });
                        return returnedNodes;
                    }),
                    argumentsLocalValues: [
                        // `name`
                        { type: 'string', value: locator.value.name || '' },
                        // `role`
                        { type: 'string', value: locator.value.role || '' },
                        // `bindings`.
                        { handle: bindings.result.handle },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            }
        }
    }
    async #locateNodesByLocator(realm, locator, startNodes, maxNodeCount, serializationOptions) {
        const locatorDelegate = await this.#getLocatorDelegate(realm, locator, maxNodeCount, startNodes);
        serializationOptions = {
            ...serializationOptions,
            // The returned object is an array of nodes, so no need in deeper JS serialization.
            maxObjectDepth: 1,
        };
        const locatorResult = await realm.callFunction(locatorDelegate.functionDeclaration, false, { type: 'undefined' }, locatorDelegate.argumentsLocalValues, "none" /* Script.ResultOwnership.None */, serializationOptions);
        if (locatorResult.type !== 'success') {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Failed locateNodesByLocator', locatorResult);
            // Heuristic to detect invalid selector for different types of selectors.
            if (
            // CSS selector.
            locatorResult.exceptionDetails.text?.endsWith('is not a valid selector.') ||
                // XPath selector.
                locatorResult.exceptionDetails.text?.endsWith('is not a valid XPath expression.')) {
                throw new protocol_js_1.InvalidSelectorException(`Not valid selector ${typeof locator.value === 'string' ? locator.value : JSON.stringify(locator.value)}`);
            }
            // Heuristic to detect if the `startNode` is not an `HTMLElement` in css selector.
            if (locatorResult.exceptionDetails.text ===
                'Error: startNodes in css selector should be HTMLElement, Document or DocumentFragment') {
                throw new protocol_js_1.InvalidArgumentException('startNodes in css selector should be HTMLElement, Document or DocumentFragment');
            }
            throw new protocol_js_1.UnknownErrorException(`Unexpected error in selector script: ${locatorResult.exceptionDetails.text}`);
        }
        if (locatorResult.result.type !== 'array') {
            throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result type: ${locatorResult.result.type}`);
        }
        // Check there are no non-node elements in the result.
        const nodes = locatorResult.result.value.map((value) => {
            if (value.type !== 'node') {
                throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result element: ${value.type}`);
            }
            return value;
        });
        return { nodes };
    }
}
exports.BrowsingContextImpl = BrowsingContextImpl;
function serializeOrigin(origin) {
    // https://html.spec.whatwg.org/multipage/origin.html#ascii-serialisation-of-an-origin
    if (['://', ''].includes(origin)) {
        origin = 'null';
    }
    return origin;
}
function getImageFormatParameters(params) {
    const { quality, type } = params.format ?? {
        type: 'image/png',
    };
    switch (type) {
        case 'image/png': {
            return { format: 'png' };
        }
        case 'image/jpeg': {
            return {
                format: 'jpeg',
                ...(quality === undefined ? {} : { quality: Math.round(quality * 100) }),
            };
        }
        case 'image/webp': {
            return {
                format: 'webp',
                ...(quality === undefined ? {} : { quality: Math.round(quality * 100) }),
            };
        }
    }
    throw new protocol_js_1.InvalidArgumentException(`Image format '${type}' is not a supported format`);
}
function deserializeDOMRect(result) {
    if (result.type !== 'object' || result.value === undefined) {
        return;
    }
    const x = result.value.find(([key]) => {
        return key === 'x';
    })?.[1];
    const y = result.value.find(([key]) => {
        return key === 'y';
    })?.[1];
    const height = result.value.find(([key]) => {
        return key === 'height';
    })?.[1];
    const width = result.value.find(([key]) => {
        return key === 'width';
    })?.[1];
    if (x?.type !== 'number' ||
        y?.type !== 'number' ||
        height?.type !== 'number' ||
        width?.type !== 'number') {
        return;
    }
    return {
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value,
    };
}
/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */
function normalizeRect(box) {
    return {
        ...(box.width < 0
            ? {
                x: box.x + box.width,
                width: -box.width,
            }
            : {
                x: box.x,
                width: box.width,
            }),
        ...(box.height < 0
            ? {
                y: box.y + box.height,
                height: -box.height,
            }
            : {
                y: box.y,
                height: box.height,
            }),
    };
}
/** @see https://w3c.github.io/webdriver-bidi/#rectangle-intersection */
function getIntersectionRect(first, second) {
    first = normalizeRect(first);
    second = normalizeRect(second);
    const x = Math.max(first.x, second.x);
    const y = Math.max(first.y, second.y);
    return {
        x,
        y,
        width: Math.max(Math.min(first.x + first.width, second.x + second.width) - x, 0),
        height: Math.max(Math.min(first.y + first.height, second.y + second.height) - y, 0),
    };
}
function parseInteger(value) {
    value = value.trim();
    if (!/^[0-9]+$/.test(value)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid integer: ${value}`);
    }
    return parseInt(value);
}
//# sourceMappingURL=BrowsingContextImpl.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class BrowsingContextProcessor {
    #browserCdpClient;
    #browsingContextStorage;
    #eventManager;
    constructor(browserCdpClient, browsingContextStorage, eventManager) {
        this.#browserCdpClient = browserCdpClient;
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        this.#eventManager.addSubscribeHook(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated, this.#onContextCreatedSubscribeHook.bind(this));
    }
    getTree(params) {
        const resultContexts = params.root === undefined
            ? this.#browsingContextStorage.getTopLevelContexts()
            : [this.#browsingContextStorage.getContext(params.root)];
        return {
            contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE)),
        };
    }
    async create(params) {
        let referenceContext;
        let userContext = 'default';
        if (params.referenceContext !== undefined) {
            referenceContext = this.#browsingContextStorage.getContext(params.referenceContext);
            if (!referenceContext.isTopLevelContext()) {
                throw new protocol_js_1.InvalidArgumentException(`referenceContext should be a top-level context`);
            }
            userContext = referenceContext.userContext;
        }
        if (params.userContext !== undefined) {
            userContext = params.userContext;
        }
        const existingContexts = this.#browsingContextStorage
            .getAllContexts()
            .filter((context) => context.userContext === userContext);
        let newWindow = false;
        switch (params.type) {
            case "tab" /* BrowsingContext.CreateType.Tab */:
                newWindow = false;
                break;
            case "window" /* BrowsingContext.CreateType.Window */:
                newWindow = true;
                break;
        }
        if (!existingContexts.length) {
            // If there are no contexts in the given user context, we need to set
            // newWindow to true as newWindow=false will be rejected.
            newWindow = true;
        }
        let result;
        try {
            result = await this.#browserCdpClient.sendCommand('Target.createTarget', {
                url: 'about:blank',
                newWindow,
                browserContextId: userContext === 'default' ? undefined : userContext,
                background: params.background === true,
            });
        }
        catch (err) {
            if (
            // See https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/protocol/target_handler.cc;l=90;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message.startsWith('Failed to find browser context with id') ||
                // See https://source.chromium.org/chromium/chromium/src/+/main:headless/lib/browser/protocol/target_handler.cc;l=49;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
                err.message === 'browserContextId') {
                throw new protocol_js_1.NoSuchUserContextException(`The context ${userContext} was not found`);
            }
            throw err;
        }
        // Wait for the new tab to be loaded to avoid race conditions in the
        // `browsingContext` events, when the `browsingContext.domContentLoaded` and
        // `browsingContext.load` events from the initial `about:blank` navigation
        // are emitted after the next navigation is started.
        // Details: https://github.com/web-platform-tests/wpt/issues/35846
        const contextId = result.targetId;
        const context = this.#browsingContextStorage.getContext(contextId);
        await context.lifecycleLoaded();
        return { context: context.id };
    }
    navigate(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.navigate(params.url, params.wait ?? "none" /* BrowsingContext.ReadinessState.None */);
    }
    reload(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.reload(params.ignoreCache ?? false, params.wait ?? "none" /* BrowsingContext.ReadinessState.None */);
    }
    async activate(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException('Activation is only supported on the top-level context');
        }
        await context.activate();
        return {};
    }
    async captureScreenshot(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.captureScreenshot(params);
    }
    async print(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.print(params);
    }
    async setViewport(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException('Emulating viewport is only supported on the top-level context');
        }
        await context.setViewport(params.viewport, params.devicePixelRatio);
        return {};
    }
    async traverseHistory(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context) {
            throw new protocol_js_1.InvalidArgumentException(`No browsing context with id ${params.context}`);
        }
        await context.traverseHistory(params.delta);
        return {};
    }
    async handleUserPrompt(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        try {
            await context.handleUserPrompt(params.accept, params.userText);
        }
        catch (error) {
            // Heuristically determine the error
            // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/page_handler.cc;l=1085?q=%22No%20dialog%20is%20showing%22&ss=chromium
            if (error.message?.includes('No dialog is showing')) {
                throw new protocol_js_1.NoSuchAlertException('No dialog is showing');
            }
            throw error;
        }
        return {};
    }
    async close(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException(`Non top-level browsing context ${context.id} cannot be closed.`);
        }
        try {
            const detachedFromTargetPromise = new Promise((resolve) => {
                const onContextDestroyed = (event) => {
                    if (event.targetId === params.context) {
                        this.#browserCdpClient.off('Target.detachedFromTarget', onContextDestroyed);
                        resolve();
                    }
                };
                this.#browserCdpClient.on('Target.detachedFromTarget', onContextDestroyed);
            });
            if (params.promptUnload) {
                await context.close();
            }
            else {
                await this.#browserCdpClient.sendCommand('Target.closeTarget', {
                    targetId: params.context,
                });
            }
            // Sometimes CDP command finishes before `detachedFromTarget` event,
            // sometimes after. Wait for the CDP command to be finished, and then wait
            // for `detachedFromTarget` if it hasn't emitted.
            await detachedFromTargetPromise;
        }
        catch (error) {
            // Swallow error that arise from the page being destroyed
            // Example is navigating to faulty SSL certificate
            if (!(error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                error.message === 'Not attached to an active page')) {
                throw error;
            }
        }
        return {};
    }
    async locateNodes(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.locateNodes(params);
    }
    #onContextCreatedSubscribeHook(contextId) {
        const context = this.#browsingContextStorage.getContext(contextId);
        const contextsToReport = [
            context,
            ...this.#browsingContextStorage.getContext(contextId).allChildren,
        ];
        contextsToReport.forEach((context) => {
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
                params: context.serializeToBidiValue(),
            }, context.id);
        });
        return Promise.resolve();
    }
}
exports.BrowsingContextProcessor = BrowsingContextProcessor;
//# sourceMappingURL=BrowsingContextProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/** Container class for browsing contexts. */
class BrowsingContextStorage {
    /** Map from context ID to context implementation. */
    #contexts = new Map();
    /** Gets all top-level contexts, i.e. those with no parent. */
    getTopLevelContexts() {
        return this.getAllContexts().filter((context) => context.isTopLevelContext());
    }
    /** Gets all contexts. */
    getAllContexts() {
        return Array.from(this.#contexts.values());
    }
    /** Deletes the context with the given ID. */
    deleteContextById(id) {
        this.#contexts.delete(id);
    }
    /** Deletes the given context. */
    deleteContext(context) {
        this.#contexts.delete(context.id);
    }
    /** Tracks the given context. */
    addContext(context) {
        this.#contexts.set(context.id, context);
    }
    /** Returns true whether there is an existing context with the given ID. */
    hasContext(id) {
        return this.#contexts.has(id);
    }
    /** Gets the context with the given ID, if any. */
    findContext(id) {
        return this.#contexts.get(id);
    }
    /** Returns the top-level context ID of the given context, if any. */
    findTopLevelContextId(id) {
        if (id === null) {
            return null;
        }
        const maybeContext = this.findContext(id);
        const parentId = maybeContext?.parentId ?? null;
        if (parentId === null) {
            return id;
        }
        return this.findTopLevelContextId(parentId);
    }
    findContextBySession(sessionId) {
        for (const context of this.#contexts.values()) {
            if (context.cdpTarget.cdpSessionId === sessionId) {
                return context;
            }
        }
        return;
    }
    /** Gets the context with the given ID, if any, otherwise throws. */
    getContext(id) {
        const result = this.findContext(id);
        if (result === undefined) {
            throw new protocol_js_1.NoSuchFrameException(`Context ${id} not found`);
        }
        return result;
    }
    verifyTopLevelContextsList(contexts) {
        const foundContexts = new Set();
        if (!contexts) {
            return foundContexts;
        }
        for (const contextId of contexts) {
            const context = this.getContext(contextId);
            if (context.isTopLevelContext()) {
                foundContexts.add(context);
            }
            else {
                throw new protocol_js_1.InvalidArgumentException(`Non top-level context '${contextId}' given.`);
            }
        }
        return foundContexts;
    }
}
exports.BrowsingContextStorage = BrowsingContextStorage;
//# sourceMappingURL=BrowsingContextStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionDispatcher = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const GraphemeTools_1 = __webpack_require__(/*! ../../../utils/GraphemeTools */ "./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js");
const InputSource_js_1 = __webpack_require__(/*! ./InputSource.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js");
const keyUtils_js_1 = __webpack_require__(/*! ./keyUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js");
const USKeyboardLayout_js_1 = __webpack_require__(/*! ./USKeyboardLayout.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js");
/** https://w3c.github.io/webdriver/#dfn-center-point */
const CALCULATE_IN_VIEW_CENTER_PT_DECL = ((i) => {
    const t = i.getClientRects()[0], e = Math.max(0, Math.min(t.x, t.x + t.width)), n = Math.min(window.innerWidth, Math.max(t.x, t.x + t.width)), h = Math.max(0, Math.min(t.y, t.y + t.height)), m = Math.min(window.innerHeight, Math.max(t.y, t.y + t.height));
    return [e + ((n - e) >> 1), h + ((m - h) >> 1)];
}).toString();
const IS_MAC_DECL = (() => {
    return navigator.platform.toLowerCase().includes('mac');
}).toString();
async function getElementCenter(context, element) {
    const sandbox = await context.getOrCreateSandbox(undefined);
    const result = await sandbox.callFunction(CALCULATE_IN_VIEW_CENTER_PT_DECL, false, { type: 'undefined' }, [element]);
    if (result.type === 'exception') {
        throw new protocol_js_1.NoSuchElementException(`Origin element ${element.sharedId} was not found`);
    }
    (0, assert_js_1.assert)(result.result.type === 'array');
    (0, assert_js_1.assert)(result.result.value?.[0]?.type === 'number');
    (0, assert_js_1.assert)(result.result.value?.[1]?.type === 'number');
    const { result: { value: [{ value: x }, { value: y }], }, } = result;
    return { x: x, y: y };
}
class ActionDispatcher {
    static isMacOS = async (context) => {
        const result = await (await context.getOrCreateSandbox(undefined)).callFunction(IS_MAC_DECL, false);
        (0, assert_js_1.assert)(result.type !== 'exception');
        (0, assert_js_1.assert)(result.result.type === 'boolean');
        return result.result.value;
    };
    #tickStart = 0;
    #tickDuration = 0;
    #inputState;
    #context;
    #isMacOS;
    constructor(inputState, context, isMacOS) {
        this.#inputState = inputState;
        this.#context = context;
        this.#isMacOS = isMacOS;
    }
    async dispatchActions(optionsByTick) {
        await this.#inputState.queue.run(async () => {
            for (const options of optionsByTick) {
                await this.dispatchTickActions(options);
            }
        });
    }
    async dispatchTickActions(options) {
        this.#tickStart = performance.now();
        this.#tickDuration = 0;
        for (const { action } of options) {
            if ('duration' in action && action.duration !== undefined) {
                this.#tickDuration = Math.max(this.#tickDuration, action.duration);
            }
        }
        const promises = [
            new Promise((resolve) => setTimeout(resolve, this.#tickDuration)),
        ];
        for (const option of options) {
            // In theory we have to wait for each action to happen, but CDP is serial,
            // so as an optimization, we queue all CDP commands at once and await all
            // of them.
            promises.push(this.#dispatchAction(option));
        }
        await Promise.all(promises);
    }
    async #dispatchAction({ id, action }) {
        const source = this.#inputState.get(id);
        const keyState = this.#inputState.getGlobalKeyState();
        switch (action.type) {
            case 'keyDown': {
                // SAFETY: The source is validated before.
                await this.#dispatchKeyDownAction(source, action);
                this.#inputState.cancelList.push({
                    id,
                    action: {
                        ...action,
                        type: 'keyUp',
                    },
                });
                break;
            }
            case 'keyUp': {
                // SAFETY: The source is validated before.
                await this.#dispatchKeyUpAction(source, action);
                break;
            }
            case 'pause': {
                // TODO: Implement waiting on the input source.
                break;
            }
            case 'pointerDown': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerDownAction(source, keyState, action);
                this.#inputState.cancelList.push({
                    id,
                    action: {
                        ...action,
                        type: 'pointerUp',
                    },
                });
                break;
            }
            case 'pointerMove': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerMoveAction(source, keyState, action);
                break;
            }
            case 'pointerUp': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerUpAction(source, keyState, action);
                break;
            }
            case 'scroll': {
                // SAFETY: The source is validated before.
                await this.#dispatchScrollAction(source, keyState, action);
                break;
            }
        }
    }
    async #dispatchPointerDownAction(source, keyState, action) {
        const { button } = action;
        if (source.pressed.has(button)) {
            return;
        }
        source.pressed.add(button);
        const { x, y, subtype: pointerType } = source;
        const { width, height, pressure, twist, tangentialPressure } = action;
        const { tiltX, tiltY } = getTilt(action);
        // --- Platform-specific code begins here ---
        const { modifiers } = keyState;
        const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
        switch (pointerType) {
            case "mouse" /* Input.PointerType.Mouse */:
            case "pen" /* Input.PointerType.Pen */:
                // TODO: Implement width and height when available.
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mousePressed',
                    x,
                    y,
                    modifiers,
                    button: getCdpButton(button),
                    buttons: source.buttons,
                    clickCount: source.setClickCount(button, new InputSource_js_1.PointerSource.ClickContext(x, y, performance.now())),
                    pointerType,
                    tangentialPressure,
                    tiltX,
                    tiltY,
                    twist,
                    force: pressure,
                });
                break;
            case "touch" /* Input.PointerType.Touch */:
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                    type: 'touchStart',
                    touchPoints: [
                        {
                            x,
                            y,
                            radiusX,
                            radiusY,
                            tangentialPressure,
                            tiltX,
                            tiltY,
                            twist,
                            force: pressure,
                            id: source.pointerId,
                        },
                    ],
                    modifiers,
                });
                break;
        }
        source.radiusX = radiusX;
        source.radiusY = radiusY;
        source.force = pressure;
        // --- Platform-specific code ends here ---
    }
    #dispatchPointerUpAction(source, keyState, action) {
        const { button } = action;
        if (!source.pressed.has(button)) {
            return;
        }
        source.pressed.delete(button);
        const { x, y, force, radiusX, radiusY, subtype: pointerType } = source;
        // --- Platform-specific code begins here ---
        const { modifiers } = keyState;
        switch (pointerType) {
            case "mouse" /* Input.PointerType.Mouse */:
            case "pen" /* Input.PointerType.Pen */:
                // TODO: Implement width and height when available.
                return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mouseReleased',
                    x,
                    y,
                    modifiers,
                    button: getCdpButton(button),
                    buttons: source.buttons,
                    clickCount: source.getClickCount(button),
                    pointerType,
                });
            case "touch" /* Input.PointerType.Touch */:
                return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                    type: 'touchEnd',
                    touchPoints: [
                        {
                            x,
                            y,
                            id: source.pointerId,
                            force,
                            radiusX,
                            radiusY,
                        },
                    ],
                    modifiers,
                });
        }
        // --- Platform-specific code ends here ---
    }
    async #dispatchPointerMoveAction(source, keyState, action) {
        const { x: startX, y: startY, subtype: pointerType } = source;
        const { width, height, pressure, twist, tangentialPressure, x: offsetX, y: offsetY, origin = 'viewport', duration = this.#tickDuration, } = action;
        const { tiltX, tiltY } = getTilt(action);
        const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
        const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY);
        if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
        }
        let last;
        do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let x;
            let y;
            if (last) {
                x = targetX;
                y = targetY;
            }
            else {
                x = Math.round(ratio * (targetX - startX) + startX);
                y = Math.round(ratio * (targetY - startY) + startY);
            }
            if (source.x !== x || source.y !== y) {
                // --- Platform-specific code begins here ---
                const { modifiers } = keyState;
                switch (pointerType) {
                    case "mouse" /* Input.PointerType.Mouse */:
                        // TODO: Implement width and height when available.
                        await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                            type: 'mouseMoved',
                            x,
                            y,
                            modifiers,
                            clickCount: 0,
                            button: getCdpButton(source.pressed.values().next().value ?? 5),
                            buttons: source.buttons,
                            pointerType,
                            tangentialPressure,
                            tiltX,
                            tiltY,
                            twist,
                            force: pressure,
                        });
                        break;
                    case "pen" /* Input.PointerType.Pen */:
                        if (source.pressed.size !== 0) {
                            // Empty `source.pressed.size` means the pen is not detected by digitizer.
                            // Dispatch a mouse event for the pen only if either:
                            // 1. the pen is hovering over the digitizer (0);
                            // 2. the pen is in contact with the digitizer (1);
                            // 3. the pen has at least one button pressed (2, 4, etc).
                            // https://www.w3.org/TR/pointerevents/#the-buttons-property
                            // TODO: Implement width and height when available.
                            await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                                type: 'mouseMoved',
                                x,
                                y,
                                modifiers,
                                clickCount: 0,
                                button: getCdpButton(source.pressed.values().next().value ?? 5),
                                buttons: source.buttons,
                                pointerType,
                                tangentialPressure,
                                tiltX,
                                tiltY,
                                twist,
                                force: pressure ?? 0.5,
                            });
                        }
                        break;
                    case "touch" /* Input.PointerType.Touch */:
                        if (source.pressed.size !== 0) {
                            await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                                type: 'touchMove',
                                touchPoints: [
                                    {
                                        x,
                                        y,
                                        radiusX,
                                        radiusY,
                                        tangentialPressure,
                                        tiltX,
                                        tiltY,
                                        twist,
                                        force: pressure,
                                        id: source.pointerId,
                                    },
                                ],
                                modifiers,
                            });
                        }
                        break;
                }
                // --- Platform-specific code ends here ---
                source.x = x;
                source.y = y;
                source.radiusX = radiusX;
                source.radiusY = radiusY;
                source.force = pressure;
            }
        } while (!last);
    }
    async #getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY) {
        let targetX;
        let targetY;
        switch (origin) {
            case 'viewport':
                targetX = offsetX;
                targetY = offsetY;
                break;
            case 'pointer':
                targetX = startX + offsetX;
                targetY = startY + offsetY;
                break;
            default: {
                const { x: posX, y: posY } = await getElementCenter(this.#context, origin.element);
                // SAFETY: These can never be special numbers.
                targetX = posX + offsetX;
                targetY = posY + offsetY;
                break;
            }
        }
        return { targetX, targetY };
    }
    async #dispatchScrollAction(_source, keyState, action) {
        const { deltaX: targetDeltaX, deltaY: targetDeltaY, x: offsetX, y: offsetY, origin = 'viewport', duration = this.#tickDuration, } = action;
        if (origin === 'pointer') {
            throw new protocol_js_1.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
        }
        const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, 0, 0);
        if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
        }
        let currentDeltaX = 0;
        let currentDeltaY = 0;
        let last;
        do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let deltaX;
            let deltaY;
            if (last) {
                deltaX = targetDeltaX - currentDeltaX;
                deltaY = targetDeltaY - currentDeltaY;
            }
            else {
                deltaX = Math.round(ratio * targetDeltaX - currentDeltaX);
                deltaY = Math.round(ratio * targetDeltaY - currentDeltaY);
            }
            if (deltaX !== 0 || deltaY !== 0) {
                // --- Platform-specific code begins here ---
                const { modifiers } = keyState;
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mouseWheel',
                    deltaX,
                    deltaY,
                    x: targetX,
                    y: targetY,
                    modifiers,
                });
                // --- Platform-specific code ends here ---
                currentDeltaX += deltaX;
                currentDeltaY += deltaY;
            }
        } while (!last);
    }
    async #dispatchKeyDownAction(source, action) {
        const rawKey = action.value;
        if (!(0, GraphemeTools_1.isSingleGrapheme)(rawKey)) {
            // https://w3c.github.io/webdriver/#dfn-process-a-key-action
            // WebDriver spec allows a grapheme to be used.
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
        }
        const isGrapheme = (0, GraphemeTools_1.isSingleComplexGrapheme)(rawKey);
        const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
        const repeat = source.pressed.has(key);
        const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
        const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
        switch (key) {
            case 'Alt':
                source.alt = true;
                break;
            case 'Shift':
                source.shift = true;
                break;
            case 'Control':
                source.ctrl = true;
                break;
            case 'Meta':
                source.meta = true;
                break;
        }
        source.pressed.add(key);
        const { modifiers } = source;
        // --- Platform-specific code begins here ---
        // The spread is a little hack so JS gives us an array of unicode characters
        // to measure.
        const unmodifiedText = getKeyEventUnmodifiedText(key, source, isGrapheme);
        const text = getKeyEventText(code ?? '', source) ?? unmodifiedText;
        let command;
        // The following commands need to be declared because Chromium doesn't
        // handle them. See
        // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:third_party/blink/renderer/core/editing/editing_behavior.cc;l=169;drc=b8143cf1dfd24842890fcd831c4f5d909bef4fc4;bpv=0;bpt=1.
        if (this.#isMacOS && source.meta) {
            switch (code) {
                case 'KeyA':
                    command = 'SelectAll';
                    break;
                case 'KeyC':
                    command = 'Copy';
                    break;
                case 'KeyV':
                    command = source.shift ? 'PasteAndMatchStyle' : 'Paste';
                    break;
                case 'KeyX':
                    command = 'Cut';
                    break;
                case 'KeyZ':
                    command = source.shift ? 'Redo' : 'Undo';
                    break;
                default:
                // Intentionally empty.
            }
        }
        const promises = [
            this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchKeyEvent', {
                type: text ? 'keyDown' : 'rawKeyDown',
                windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
                key,
                code,
                text,
                unmodifiedText,
                autoRepeat: repeat,
                isSystemKey: source.alt || undefined,
                location: location < 3 ? location : undefined,
                isKeypad: location === 3,
                modifiers,
                commands: command ? [command] : undefined,
            }),
        ];
        // Drag cancelling happens on escape.
        if (key === 'Escape') {
            if (!source.alt &&
                ((this.#isMacOS && !source.ctrl && !source.meta) || !this.#isMacOS)) {
                promises.push(this.#context.cdpTarget.cdpClient.sendCommand('Input.cancelDragging'));
            }
        }
        await Promise.all(promises);
        // --- Platform-specific code ends here ---
    }
    #dispatchKeyUpAction(source, action) {
        const rawKey = action.value;
        if (!(0, GraphemeTools_1.isSingleGrapheme)(rawKey)) {
            // https://w3c.github.io/webdriver/#dfn-process-a-key-action
            // WebDriver spec allows a grapheme to be used.
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
        }
        const isGrapheme = (0, GraphemeTools_1.isSingleComplexGrapheme)(rawKey);
        const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
        if (!source.pressed.has(key)) {
            return;
        }
        const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
        const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
        switch (key) {
            case 'Alt':
                source.alt = false;
                break;
            case 'Shift':
                source.shift = false;
                break;
            case 'Control':
                source.ctrl = false;
                break;
            case 'Meta':
                source.meta = false;
                break;
        }
        source.pressed.delete(key);
        const { modifiers } = source;
        // --- Platform-specific code begins here ---
        // The spread is a little hack so JS gives us an array of unicode characters
        // to measure.
        const unmodifiedText = getKeyEventUnmodifiedText(key, source, isGrapheme);
        const text = getKeyEventText(code ?? '', source) ?? unmodifiedText;
        return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchKeyEvent', {
            type: 'keyUp',
            windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
            key,
            code,
            text,
            unmodifiedText,
            location: location < 3 ? location : undefined,
            isSystemKey: source.alt || undefined,
            isKeypad: location === 3,
            modifiers,
        });
        // --- Platform-specific code ends here ---
    }
}
exports.ActionDispatcher = ActionDispatcher;
/**
 * Translates a non-grapheme key to either an `undefined` for a special keys, or a single
 * character modified by shift if needed.
 */
const getKeyEventUnmodifiedText = (key, source, isGrapheme) => {
    if (isGrapheme) {
        // Graphemes should be presented as text in the CDP command.
        return key;
    }
    if (key === 'Enter') {
        return '\r';
    }
    // If key is not a single character, it is a normalized key value, and should be
    // presented as key, not text in the CDP command.
    return [...key].length === 1
        ? source.shift
            ? key.toLocaleUpperCase('en-US')
            : key
        : undefined;
};
const getKeyEventText = (code, source) => {
    if (source.ctrl) {
        switch (code) {
            case 'Digit2':
                if (source.shift) {
                    return '\x00';
                }
                break;
            case 'KeyA':
                return '\x01';
            case 'KeyB':
                return '\x02';
            case 'KeyC':
                return '\x03';
            case 'KeyD':
                return '\x04';
            case 'KeyE':
                return '\x05';
            case 'KeyF':
                return '\x06';
            case 'KeyG':
                return '\x07';
            case 'KeyH':
                return '\x08';
            case 'KeyI':
                return '\x09';
            case 'KeyJ':
                return '\x0A';
            case 'KeyK':
                return '\x0B';
            case 'KeyL':
                return '\x0C';
            case 'KeyM':
                return '\x0D';
            case 'KeyN':
                return '\x0E';
            case 'KeyO':
                return '\x0F';
            case 'KeyP':
                return '\x10';
            case 'KeyQ':
                return '\x11';
            case 'KeyR':
                return '\x12';
            case 'KeyS':
                return '\x13';
            case 'KeyT':
                return '\x14';
            case 'KeyU':
                return '\x15';
            case 'KeyV':
                return '\x16';
            case 'KeyW':
                return '\x17';
            case 'KeyX':
                return '\x18';
            case 'KeyY':
                return '\x19';
            case 'KeyZ':
                return '\x1A';
            case 'BracketLeft':
                return '\x1B';
            case 'Backslash':
                return '\x1C';
            case 'BracketRight':
                return '\x1D';
            case 'Digit6':
                if (source.shift) {
                    return '\x1E';
                }
                break;
            case 'Minus':
                return '\x1F';
        }
        return '';
    }
    if (source.alt) {
        return '';
    }
    return;
};
function getCdpButton(button) {
    // https://www.w3.org/TR/pointerevents/#the-button-property
    switch (button) {
        case 0:
            return 'left';
        case 1:
            return 'middle';
        case 2:
            return 'right';
        case 3:
            return 'back';
        case 4:
            return 'forward';
        default:
            return 'none';
    }
}
function getTilt(action) {
    // https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle
    const altitudeAngle = action.altitudeAngle ?? Math.PI / 2;
    const azimuthAngle = action.azimuthAngle ?? 0;
    let tiltXRadians = 0;
    let tiltYRadians = 0;
    if (altitudeAngle === 0) {
        // the pen is in the X-Y plane
        if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {
            // pen is on positive X axis
            tiltXRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI / 2) {
            // pen is on positive Y axis
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI) {
            // pen is on negative X axis
            tiltXRadians = -Math.PI / 2;
        }
        if (azimuthAngle === (3 * Math.PI) / 2) {
            // pen is on negative Y axis
            tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI && azimuthAngle < (3 * Math.PI) / 2) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > (3 * Math.PI) / 2 && azimuthAngle < 2 * Math.PI) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
        }
    }
    if (altitudeAngle !== 0) {
        const tanAlt = Math.tan(altitudeAngle);
        tiltXRadians = Math.atan(Math.cos(azimuthAngle) / tanAlt);
        tiltYRadians = Math.atan(Math.sin(azimuthAngle) / tanAlt);
    }
    const factor = 180 / Math.PI;
    return {
        tiltX: Math.round(tiltXRadians * factor),
        tiltY: Math.round(tiltYRadians * factor),
    };
}
function getRadii(width, height) {
    return {
        radiusX: width ? width / 2 : 0.5,
        radiusY: height ? height / 2 : 0.5,
    };
}
//# sourceMappingURL=ActionDispatcher.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputProcessor = void 0;
/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const ActionDispatcher_js_1 = __webpack_require__(/*! ../input/ActionDispatcher.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js");
const InputStateManager_js_1 = __webpack_require__(/*! ../input/InputStateManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js");
class InputProcessor {
    #browsingContextStorage;
    #inputStateManager = new InputStateManager_js_1.InputStateManager();
    constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
    }
    async performActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const inputState = this.#inputStateManager.get(context.top);
        const actionsByTick = this.#getActionsByTick(params, inputState);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchActions(actionsByTick);
        return {};
    }
    async releaseActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const topContext = context.top;
        const inputState = this.#inputStateManager.get(topContext);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
        this.#inputStateManager.delete(topContext);
        return {};
    }
    async setFiles(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const realm = await context.getOrCreateSandbox(undefined);
        let result;
        try {
            result = await realm.callFunction(String(function getFiles(fileListLength) {
                if (!(this instanceof HTMLInputElement)) {
                    if (this instanceof Element) {
                        return 1 /* ErrorCode.Element */;
                    }
                    return 0 /* ErrorCode.Node */;
                }
                if (this.type !== 'file') {
                    return 2 /* ErrorCode.Type */;
                }
                if (this.disabled) {
                    return 3 /* ErrorCode.Disabled */;
                }
                if (fileListLength > 1 && !this.multiple) {
                    return 4 /* ErrorCode.Multiple */;
                }
                return;
            }), false, params.element, [{ type: 'number', value: params.files.length }]);
        }
        catch {
            throw new protocol_js_1.NoSuchNodeException(`Could not find element ${params.element.sharedId}`);
        }
        (0, assert_js_1.assert)(result.type === 'success');
        if (result.result.type === 'number') {
            switch (result.result.value) {
                case 0 /* ErrorCode.Node */: {
                    throw new protocol_js_1.NoSuchElementException(`Could not find element ${params.element.sharedId}`);
                }
                case 1 /* ErrorCode.Element */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Element ${params.element.sharedId} is not a input`);
                }
                case 2 /* ErrorCode.Type */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is not a file type`);
                }
                case 3 /* ErrorCode.Disabled */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is disabled`);
                }
                case 4 /* ErrorCode.Multiple */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Cannot set multiple files on a non-multiple input element`);
                }
            }
        }
        /**
         * The zero-length array is a special case, it seems that
         * DOM.setFileInputFiles does not actually update the files in that case, so
         * the solution is to eval the element value to a new FileList directly.
         */
        if (params.files.length === 0) {
            // XXX: These events should converted to trusted events. Perhaps do this
            // in `DOM.setFileInputFiles`?
            await realm.callFunction(String(function dispatchEvent() {
                if (this.files?.length === 0) {
                    this.dispatchEvent(new Event('cancel', {
                        bubbles: true,
                    }));
                    return;
                }
                this.files = new DataTransfer().files;
                // Dispatch events for this case because it should behave akin to a user action.
                this.dispatchEvent(new Event('input', { bubbles: true, composed: true }));
                this.dispatchEvent(new Event('change', { bubbles: true }));
            }), false, params.element);
            return {};
        }
        // Our goal here is to iterate over the input element files and get their
        // file paths.
        const paths = [];
        for (let i = 0; i < params.files.length; ++i) {
            const result = await realm.callFunction(String(function getFiles(index) {
                return this.files?.item(index);
            }), false, params.element, [{ type: 'number', value: 0 }], "root" /* Script.ResultOwnership.Root */);
            (0, assert_js_1.assert)(result.type === 'success');
            if (result.result.type !== 'object') {
                break;
            }
            const { handle } = result.result;
            (0, assert_js_1.assert)(handle !== undefined);
            const { path } = await realm.cdpClient.sendCommand('DOM.getFileInfo', {
                objectId: handle,
            });
            paths.push(path);
            // Cleanup the handle.
            void realm.disown(handle).catch(undefined);
        }
        paths.sort();
        // We create a new array so we preserve the order of the original files.
        const sortedFiles = [...params.files].sort();
        if (paths.length !== params.files.length ||
            sortedFiles.some((path, index) => {
                return paths[index] !== path;
            })) {
            const { objectId } = await realm.deserializeForCdp(params.element);
            // This cannot throw since this was just used in `callFunction` above.
            (0, assert_js_1.assert)(objectId !== undefined);
            await realm.cdpClient.sendCommand('DOM.setFileInputFiles', {
                files: params.files,
                objectId,
            });
        }
        else {
            // XXX: We should dispatch a trusted event.
            await realm.callFunction(String(function dispatchEvent() {
                this.dispatchEvent(new Event('cancel', {
                    bubbles: true,
                }));
            }), false, params.element);
        }
        return {};
    }
    #getActionsByTick(params, inputState) {
        const actionsByTick = [];
        for (const action of params.actions) {
            switch (action.type) {
                case "pointer" /* SourceType.Pointer */: {
                    action.parameters ??= { pointerType: "mouse" /* Input.PointerType.Mouse */ };
                    action.parameters.pointerType ??= "mouse" /* Input.PointerType.Mouse */;
                    const source = inputState.getOrCreate(action.id, "pointer" /* SourceType.Pointer */, action.parameters.pointerType);
                    if (source.subtype !== action.parameters.pointerType) {
                        throw new protocol_js_1.InvalidArgumentException(`Expected input source ${action.id} to be ${source.subtype}; got ${action.parameters.pointerType}.`);
                    }
                    break;
                }
                default:
                    inputState.getOrCreate(action.id, action.type);
            }
            const actions = action.actions.map((item) => ({
                id: action.id,
                action: item,
            }));
            for (let i = 0; i < actions.length; i++) {
                if (actionsByTick.length === i) {
                    actionsByTick.push([]);
                }
                actionsByTick[i].push(actions[i]);
            }
        }
        return actionsByTick;
    }
}
exports.InputProcessor = InputProcessor;
//# sourceMappingURL=InputProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js":
/*!************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WheelSource = exports.PointerSource = exports.KeySource = exports.NoneSource = void 0;
class NoneSource {
    type = "none" /* SourceType.None */;
}
exports.NoneSource = NoneSource;
class KeySource {
    type = "key" /* SourceType.Key */;
    pressed = new Set();
    // This is a bitfield that matches the modifiers parameter of
    // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent
    #modifiers = 0;
    get modifiers() {
        return this.#modifiers;
    }
    get alt() {
        return (this.#modifiers & 1) === 1;
    }
    set alt(value) {
        this.#setModifier(value, 1);
    }
    get ctrl() {
        return (this.#modifiers & 2) === 2;
    }
    set ctrl(value) {
        this.#setModifier(value, 2);
    }
    get meta() {
        return (this.#modifiers & 4) === 4;
    }
    set meta(value) {
        this.#setModifier(value, 4);
    }
    get shift() {
        return (this.#modifiers & 8) === 8;
    }
    set shift(value) {
        this.#setModifier(value, 8);
    }
    #setModifier(value, bit) {
        if (value) {
            this.#modifiers |= bit;
        }
        else {
            this.#modifiers &= ~bit;
        }
    }
}
exports.KeySource = KeySource;
class PointerSource {
    type = "pointer" /* SourceType.Pointer */;
    subtype;
    pointerId;
    pressed = new Set();
    x = 0;
    y = 0;
    radiusX;
    radiusY;
    force;
    constructor(id, subtype) {
        this.pointerId = id;
        this.subtype = subtype;
    }
    // This is a bitfield that matches the buttons parameter of
    // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent
    get buttons() {
        let buttons = 0;
        for (const button of this.pressed) {
            switch (button) {
                case 0:
                    buttons |= 1;
                    break;
                case 1:
                    buttons |= 4;
                    break;
                case 2:
                    buttons |= 2;
                    break;
                case 3:
                    buttons |= 8;
                    break;
                case 4:
                    buttons |= 16;
                    break;
            }
        }
        return buttons;
    }
    // --- Platform-specific code starts here ---
    // Input.dispatchMouseEvent doesn't know the concept of double click, so we
    // need to create the logic, similar to how it's done for OSes:
    // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:ui/events/event.cc;l=479
    static ClickContext = class ClickContext {
        static #DOUBLE_CLICK_TIME_MS = 500;
        static #MAX_DOUBLE_CLICK_RADIUS = 2;
        count = 0;
        #x;
        #y;
        #time;
        constructor(x, y, time) {
            this.#x = x;
            this.#y = y;
            this.#time = time;
        }
        compare(context) {
            return (
            // The click needs to be within a certain amount of ms.
            context.#time - this.#time > ClickContext.#DOUBLE_CLICK_TIME_MS ||
                // The click needs to be within a certain square radius.
                Math.abs(context.#x - this.#x) >
                    ClickContext.#MAX_DOUBLE_CLICK_RADIUS ||
                Math.abs(context.#y - this.#y) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS);
        }
    };
    #clickContexts = new Map();
    setClickCount(button, context) {
        let storedContext = this.#clickContexts.get(button);
        if (!storedContext || storedContext.compare(context)) {
            storedContext = context;
        }
        ++storedContext.count;
        this.#clickContexts.set(button, storedContext);
        return storedContext.count;
    }
    getClickCount(button) {
        return this.#clickContexts.get(button)?.count ?? 0;
    }
}
exports.PointerSource = PointerSource;
class WheelSource {
    type = "wheel" /* SourceType.Wheel */;
}
exports.WheelSource = WheelSource;
//# sourceMappingURL=InputSource.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputState = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Mutex_js_1 = __webpack_require__(/*! ../../../utils/Mutex.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js");
const InputSource_js_1 = __webpack_require__(/*! ./InputSource.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js");
class InputState {
    cancelList = [];
    #sources = new Map();
    #mutex = new Mutex_js_1.Mutex();
    getOrCreate(id, type, subtype) {
        let source = this.#sources.get(id);
        if (!source) {
            switch (type) {
                case "none" /* SourceType.None */:
                    source = new InputSource_js_1.NoneSource();
                    break;
                case "key" /* SourceType.Key */:
                    source = new InputSource_js_1.KeySource();
                    break;
                case "pointer" /* SourceType.Pointer */: {
                    let pointerId = subtype === "mouse" /* Input.PointerType.Mouse */ ? 0 : 2;
                    const pointerIds = new Set();
                    for (const [, source] of this.#sources) {
                        if (source.type === "pointer" /* SourceType.Pointer */) {
                            pointerIds.add(source.pointerId);
                        }
                    }
                    while (pointerIds.has(pointerId)) {
                        ++pointerId;
                    }
                    source = new InputSource_js_1.PointerSource(pointerId, subtype);
                    break;
                }
                case "wheel" /* SourceType.Wheel */:
                    source = new InputSource_js_1.WheelSource();
                    break;
                default:
                    throw new protocol_js_1.InvalidArgumentException(`Expected "${"none" /* SourceType.None */}", "${"key" /* SourceType.Key */}", "${"pointer" /* SourceType.Pointer */}", or "${"wheel" /* SourceType.Wheel */}". Found unknown source type ${type}.`);
            }
            this.#sources.set(id, source);
            return source;
        }
        if (source.type !== type) {
            throw new protocol_js_1.InvalidArgumentException(`Input source type of ${id} is ${source.type}, but received ${type}.`);
        }
        return source;
    }
    get(id) {
        const source = this.#sources.get(id);
        if (!source) {
            throw new protocol_js_1.UnknownErrorException(`Internal error.`);
        }
        return source;
    }
    getGlobalKeyState() {
        const state = new InputSource_js_1.KeySource();
        for (const [, source] of this.#sources) {
            if (source.type !== "key" /* SourceType.Key */) {
                continue;
            }
            for (const pressed of source.pressed) {
                state.pressed.add(pressed);
            }
            state.alt ||= source.alt;
            state.ctrl ||= source.ctrl;
            state.meta ||= source.meta;
            state.shift ||= source.shift;
        }
        return state;
    }
    get queue() {
        return this.#mutex;
    }
}
exports.InputState = InputState;
//# sourceMappingURL=InputState.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputStateManager = void 0;
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const InputState_js_1 = __webpack_require__(/*! ./InputState.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js");
// We use a weak map here as specified here:
// https://www.w3.org/TR/webdriver/#dfn-browsing-context-input-state-map
class InputStateManager extends WeakMap {
    get(context) {
        (0, assert_js_1.assert)(context.isTopLevelContext());
        if (!this.has(context)) {
            this.set(context, new InputState_js_1.InputState());
        }
        return super.get(context);
    }
}
exports.InputStateManager = InputStateManager;
//# sourceMappingURL=InputStateManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyToKeyCode = void 0;
// TODO: Remove this once https://crrev.com/c/4548290 is stably in Chromium.
// `Input.dispatchKeyboardEvent` will automatically handle these conversions.
exports.KeyToKeyCode = {
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    Abort: 3,
    Help: 6,
    Backspace: 8,
    Tab: 9,
    Numpad5: 12,
    NumpadEnter: 13,
    Enter: 13,
    '\\r': 13,
    '\\n': 13,
    ShiftLeft: 16,
    ShiftRight: 16,
    ControlLeft: 17,
    ControlRight: 17,
    AltLeft: 18,
    AltRight: 18,
    Pause: 19,
    CapsLock: 20,
    Escape: 27,
    Convert: 28,
    NonConvert: 29,
    Space: 32,
    Numpad9: 33,
    PageUp: 33,
    Numpad3: 34,
    PageDown: 34,
    End: 35,
    Numpad1: 35,
    Home: 36,
    Numpad7: 36,
    ArrowLeft: 37,
    Numpad4: 37,
    Numpad8: 38,
    ArrowUp: 38,
    ArrowRight: 39,
    Numpad6: 39,
    Numpad2: 40,
    ArrowDown: 40,
    Select: 41,
    Open: 43,
    PrintScreen: 44,
    Insert: 45,
    Numpad0: 45,
    Delete: 46,
    NumpadDecimal: 46,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    KeyA: 65,
    KeyB: 66,
    KeyC: 67,
    KeyD: 68,
    KeyE: 69,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyI: 73,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    KeyM: 77,
    KeyN: 78,
    KeyO: 79,
    KeyP: 80,
    KeyQ: 81,
    KeyR: 82,
    KeyS: 83,
    KeyT: 84,
    KeyU: 85,
    KeyV: 86,
    KeyW: 87,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90,
    MetaLeft: 91,
    MetaRight: 92,
    ContextMenu: 93,
    NumpadMultiply: 106,
    NumpadAdd: 107,
    NumpadSubtract: 109,
    NumpadDivide: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    F13: 124,
    F14: 125,
    F15: 126,
    F16: 127,
    F17: 128,
    F18: 129,
    F19: 130,
    F20: 131,
    F21: 132,
    F22: 133,
    F23: 134,
    F24: 135,
    NumLock: 144,
    ScrollLock: 145,
    AudioVolumeMute: 173,
    AudioVolumeDown: 174,
    AudioVolumeUp: 175,
    MediaTrackNext: 176,
    MediaTrackPrevious: 177,
    MediaStop: 178,
    MediaPlayPause: 179,
    Semicolon: 186,
    Equal: 187,
    NumpadEqual: 187,
    Comma: 188,
    Minus: 189,
    Period: 190,
    Slash: 191,
    Backquote: 192,
    BracketLeft: 219,
    Backslash: 220,
    BracketRight: 221,
    Quote: 222,
    AltGraph: 225,
    Props: 247,
    Cancel: 3,
    Clear: 12,
    Shift: 16,
    Control: 17,
    Alt: 18,
    Accept: 30,
    ModeChange: 31,
    ' ': 32,
    Print: 42,
    Execute: 43,
    '\\u0000': 46,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    Meta: 91,
    '*': 106,
    '+': 107,
    '-': 109,
    '/': 111,
    ';': 186,
    '=': 187,
    ',': 188,
    '.': 190,
    '`': 192,
    '[': 219,
    '\\\\': 220,
    ']': 221,
    "'": 222,
    Attn: 246,
    CrSel: 247,
    ExSel: 248,
    EraseEof: 249,
    Play: 250,
    ZoomOut: 251,
    ')': 48,
    '!': 49,
    '@': 50,
    '#': 51,
    $: 52,
    '%': 53,
    '^': 54,
    '&': 55,
    '(': 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    ':': 186,
    '<': 188,
    _: 189,
    '>': 190,
    '?': 191,
    '~': 192,
    '{': 219,
    '|': 220,
    '}': 221,
    '"': 222,
    Camera: 44,
    EndCall: 95,
    VolumeDown: 182,
    VolumeUp: 183,
};
//# sourceMappingURL=USKeyboardLayout.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNormalizedKey = getNormalizedKey;
exports.getKeyCode = getKeyCode;
exports.getKeyLocation = getKeyLocation;
/**
 * Returns the normalized key value for a given key according to the table:
 * https://w3c.github.io/webdriver/#dfn-normalized-key-value
 */
function getNormalizedKey(value) {
    switch (value) {
        case '\uE000':
            return 'Unidentified';
        case '\uE001':
            return 'Cancel';
        case '\uE002':
            return 'Help';
        case '\uE003':
            return 'Backspace';
        case '\uE004':
            return 'Tab';
        case '\uE005':
            return 'Clear';
        // Specification declares the '\uE006' to be `Return`, but it is not supported by
        // Chrome, so fall back to `Enter`, which aligns with WPT.
        case '\uE006':
        case '\uE007':
            return 'Enter';
        case '\uE008':
            return 'Shift';
        case '\uE009':
            return 'Control';
        case '\uE00A':
            return 'Alt';
        case '\uE00B':
            return 'Pause';
        case '\uE00C':
            return 'Escape';
        case '\uE00D':
            return ' ';
        case '\uE00E':
            return 'PageUp';
        case '\uE00F':
            return 'PageDown';
        case '\uE010':
            return 'End';
        case '\uE011':
            return 'Home';
        case '\uE012':
            return 'ArrowLeft';
        case '\uE013':
            return 'ArrowUp';
        case '\uE014':
            return 'ArrowRight';
        case '\uE015':
            return 'ArrowDown';
        case '\uE016':
            return 'Insert';
        case '\uE017':
            return 'Delete';
        case '\uE018':
            return ';';
        case '\uE019':
            return '=';
        case '\uE01A':
            return '0';
        case '\uE01B':
            return '1';
        case '\uE01C':
            return '2';
        case '\uE01D':
            return '3';
        case '\uE01E':
            return '4';
        case '\uE01F':
            return '5';
        case '\uE020':
            return '6';
        case '\uE021':
            return '7';
        case '\uE022':
            return '8';
        case '\uE023':
            return '9';
        case '\uE024':
            return '*';
        case '\uE025':
            return '+';
        case '\uE026':
            return ',';
        case '\uE027':
            return '-';
        case '\uE028':
            return '.';
        case '\uE029':
            return '/';
        case '\uE031':
            return 'F1';
        case '\uE032':
            return 'F2';
        case '\uE033':
            return 'F3';
        case '\uE034':
            return 'F4';
        case '\uE035':
            return 'F5';
        case '\uE036':
            return 'F6';
        case '\uE037':
            return 'F7';
        case '\uE038':
            return 'F8';
        case '\uE039':
            return 'F9';
        case '\uE03A':
            return 'F10';
        case '\uE03B':
            return 'F11';
        case '\uE03C':
            return 'F12';
        case '\uE03D':
            return 'Meta';
        case '\uE040':
            return 'ZenkakuHankaku';
        case '\uE050':
            return 'Shift';
        case '\uE051':
            return 'Control';
        case '\uE052':
            return 'Alt';
        case '\uE053':
            return 'Meta';
        case '\uE054':
            return 'PageUp';
        case '\uE055':
            return 'PageDown';
        case '\uE056':
            return 'End';
        case '\uE057':
            return 'Home';
        case '\uE058':
            return 'ArrowLeft';
        case '\uE059':
            return 'ArrowUp';
        case '\uE05A':
            return 'ArrowRight';
        case '\uE05B':
            return 'ArrowDown';
        case '\uE05C':
            return 'Insert';
        case '\uE05D':
            return 'Delete';
        default:
            return value;
    }
}
/**
 * Returns the key code for a given key according to the table:
 * https://w3c.github.io/webdriver/#dfn-shifted-character
 */
function getKeyCode(key) {
    switch (key) {
        case '`':
        case '~':
            return 'Backquote';
        case '\\':
        case '|':
            return 'Backslash';
        case '\uE003':
            return 'Backspace';
        case '[':
        case '{':
            return 'BracketLeft';
        case ']':
        case '}':
            return 'BracketRight';
        case ',':
        case '<':
            return 'Comma';
        case '0':
        case ')':
            return 'Digit0';
        case '1':
        case '!':
            return 'Digit1';
        case '2':
        case '@':
            return 'Digit2';
        case '3':
        case '#':
            return 'Digit3';
        case '4':
        case '$':
            return 'Digit4';
        case '5':
        case '%':
            return 'Digit5';
        case '6':
        case '^':
            return 'Digit6';
        case '7':
        case '&':
            return 'Digit7';
        case '8':
        case '*':
            return 'Digit8';
        case '9':
        case '(':
            return 'Digit9';
        case '=':
        case '+':
            return 'Equal';
        // The spec declares the '<' to be `IntlBackslash` as well, but it is already covered
        // in the `Comma` above.
        case '>':
            return 'IntlBackslash';
        case 'a':
        case 'A':
            return 'KeyA';
        case 'b':
        case 'B':
            return 'KeyB';
        case 'c':
        case 'C':
            return 'KeyC';
        case 'd':
        case 'D':
            return 'KeyD';
        case 'e':
        case 'E':
            return 'KeyE';
        case 'f':
        case 'F':
            return 'KeyF';
        case 'g':
        case 'G':
            return 'KeyG';
        case 'h':
        case 'H':
            return 'KeyH';
        case 'i':
        case 'I':
            return 'KeyI';
        case 'j':
        case 'J':
            return 'KeyJ';
        case 'k':
        case 'K':
            return 'KeyK';
        case 'l':
        case 'L':
            return 'KeyL';
        case 'm':
        case 'M':
            return 'KeyM';
        case 'n':
        case 'N':
            return 'KeyN';
        case 'o':
        case 'O':
            return 'KeyO';
        case 'p':
        case 'P':
            return 'KeyP';
        case 'q':
        case 'Q':
            return 'KeyQ';
        case 'r':
        case 'R':
            return 'KeyR';
        case 's':
        case 'S':
            return 'KeyS';
        case 't':
        case 'T':
            return 'KeyT';
        case 'u':
        case 'U':
            return 'KeyU';
        case 'v':
        case 'V':
            return 'KeyV';
        case 'w':
        case 'W':
            return 'KeyW';
        case 'x':
        case 'X':
            return 'KeyX';
        case 'y':
        case 'Y':
            return 'KeyY';
        case 'z':
        case 'Z':
            return 'KeyZ';
        case '-':
        case '_':
            return 'Minus';
        case '.':
            return 'Period';
        case "'":
        case '"':
            return 'Quote';
        case ';':
        case ':':
            return 'Semicolon';
        case '/':
        case '?':
            return 'Slash';
        case '\uE00A':
            return 'AltLeft';
        case '\uE052':
            return 'AltRight';
        case '\uE009':
            return 'ControlLeft';
        case '\uE051':
            return 'ControlRight';
        case '\uE006':
            return 'Enter';
        case '\uE00B':
            return 'Pause';
        case '\uE03D':
            return 'MetaLeft';
        case '\uE053':
            return 'MetaRight';
        case '\uE008':
            return 'ShiftLeft';
        case '\uE050':
            return 'ShiftRight';
        case ' ':
        case '\uE00D':
            return 'Space';
        case '\uE004':
            return 'Tab';
        case '\uE017':
            return 'Delete';
        case '\uE010':
            return 'End';
        case '\uE002':
            return 'Help';
        case '\uE011':
            return 'Home';
        case '\uE016':
            return 'Insert';
        case '\uE00F':
            return 'PageDown';
        case '\uE00E':
            return 'PageUp';
        case '\uE015':
            return 'ArrowDown';
        case '\uE012':
            return 'ArrowLeft';
        case '\uE014':
            return 'ArrowRight';
        case '\uE013':
            return 'ArrowUp';
        case '\uE00C':
            return 'Escape';
        case '\uE031':
            return 'F1';
        case '\uE032':
            return 'F2';
        case '\uE033':
            return 'F3';
        case '\uE034':
            return 'F4';
        case '\uE035':
            return 'F5';
        case '\uE036':
            return 'F6';
        case '\uE037':
            return 'F7';
        case '\uE038':
            return 'F8';
        case '\uE039':
            return 'F9';
        case '\uE03A':
            return 'F10';
        case '\uE03B':
            return 'F11';
        case '\uE03C':
            return 'F12';
        case '\uE019':
            return 'NumpadEqual';
        case '\uE01A':
        case '\uE05C':
            return 'Numpad0';
        case '\uE01B':
        case '\uE056':
            return 'Numpad1';
        case '\uE01C':
        case '\uE05B':
            return 'Numpad2';
        case '\uE01D':
        case '\uE055':
            return 'Numpad3';
        case '\uE01E':
        case '\uE058':
            return 'Numpad4';
        case '\uE01F':
            return 'Numpad5';
        case '\uE020':
        case '\uE05A':
            return 'Numpad6';
        case '\uE021':
        case '\uE057':
            return 'Numpad7';
        case '\uE022':
        case '\uE059':
            return 'Numpad8';
        case '\uE023':
        case '\uE054':
            return 'Numpad9';
        case '\uE025':
            return 'NumpadAdd';
        case '\uE026':
            return 'NumpadComma';
        case '\uE028':
        case '\uE05D':
            return 'NumpadDecimal';
        case '\uE029':
            return 'NumpadDivide';
        case '\uE007':
            return 'NumpadEnter';
        case '\uE024':
            return 'NumpadMultiply';
        case '\uE027':
            return 'NumpadSubtract';
        default:
            return;
    }
}
/**
 * Returns the location of the key according to the table:
 * https://w3c.github.io/webdriver/#dfn-key-location
 */
function getKeyLocation(key) {
    switch (key) {
        case '\uE007':
        case '\uE008':
        case '\uE009':
        case '\uE00A':
        case '\uE03D':
            return 1;
        case '\uE019':
        case '\uE01A':
        case '\uE01B':
        case '\uE01C':
        case '\uE01D':
        case '\uE01E':
        case '\uE01F':
        case '\uE020':
        case '\uE021':
        case '\uE022':
        case '\uE023':
        case '\uE024':
        case '\uE025':
        case '\uE026':
        case '\uE027':
        case '\uE028':
        case '\uE029':
        case '\uE054':
        case '\uE055':
        case '\uE056':
        case '\uE057':
        case '\uE058':
        case '\uE059':
        case '\uE05A':
        case '\uE05B':
        case '\uE05C':
        case '\uE05D':
            return 3;
        case '\uE050':
        case '\uE051':
        case '\uE052':
        case '\uE053':
            return 2;
        default:
            return 0;
    }
}
//# sourceMappingURL=keyUtils.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogManager = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const logHelper_js_1 = __webpack_require__(/*! ./logHelper.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js");
/** Converts CDP StackTrace object to BiDi StackTrace object. */
function getBidiStackTrace(cdpStackTrace) {
    const stackFrames = cdpStackTrace?.callFrames.map((callFrame) => {
        return {
            columnNumber: callFrame.columnNumber,
            functionName: callFrame.functionName,
            lineNumber: callFrame.lineNumber,
            url: callFrame.url,
        };
    });
    return stackFrames ? { callFrames: stackFrames } : undefined;
}
function getLogLevel(consoleApiType) {
    if (["error" /* Log.Level.Error */, 'assert'].includes(consoleApiType)) {
        return "error" /* Log.Level.Error */;
    }
    if (["debug" /* Log.Level.Debug */, 'trace'].includes(consoleApiType)) {
        return "debug" /* Log.Level.Debug */;
    }
    if (["warn" /* Log.Level.Warn */, 'warning'].includes(consoleApiType)) {
        return "warn" /* Log.Level.Warn */;
    }
    return "info" /* Log.Level.Info */;
}
class LogManager {
    #eventManager;
    #realmStorage;
    #cdpTarget;
    #logger;
    constructor(cdpTarget, realmStorage, eventManager, logger) {
        this.#cdpTarget = cdpTarget;
        this.#realmStorage = realmStorage;
        this.#eventManager = eventManager;
        this.#logger = logger;
    }
    static create(cdpTarget, realmStorage, eventManager, logger) {
        const logManager = new LogManager(cdpTarget, realmStorage, eventManager, logger);
        logManager.#initializeEntryAddedEventListener();
        return logManager;
    }
    #initializeEntryAddedEventListener() {
        this.#cdpTarget.cdpClient.on('Runtime.consoleAPICalled', (params) => {
            // Try to find realm by `cdpSessionId` and `executionContextId`,
            // if provided.
            const realm = this.#realmStorage.findRealm({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.executionContextId,
            });
            if (realm === undefined) {
                // Ignore exceptions not attached to any realm.
                this.#logger?.(log_js_1.LogType.cdp, params);
                return;
            }
            const argsPromise = realm === undefined
                ? Promise.resolve(params.args)
                : // Properly serialize arguments if possible.
                    Promise.all(params.args.map((arg) => {
                        return realm.serializeCdpObject(arg, "none" /* Script.ResultOwnership.None */);
                    }));
            for (const browsingContext of realm.associatedBrowsingContexts) {
                this.#eventManager.registerPromiseEvent(argsPromise.then((args) => ({
                    kind: 'success',
                    value: {
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                        params: {
                            level: getLogLevel(params.type),
                            source: realm.source,
                            text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
                            timestamp: Math.round(params.timestamp),
                            stackTrace: getBidiStackTrace(params.stackTrace),
                            type: 'console',
                            // Console method is `warn`, not `warning`.
                            method: params.type === 'warning' ? 'warn' : params.type,
                            args,
                        },
                    },
                }), (error) => ({
                    kind: 'error',
                    error,
                })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.exceptionThrown', (params) => {
            // Try to find realm by `cdpSessionId` and `executionContextId`,
            // if provided.
            const realm = this.#realmStorage.findRealm({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.exceptionDetails.executionContextId,
            });
            if (realm === undefined) {
                // Ignore exceptions not attached to any realm.
                this.#logger?.(log_js_1.LogType.cdp, params);
                return;
            }
            for (const browsingContext of realm.associatedBrowsingContexts) {
                this.#eventManager.registerPromiseEvent(LogManager.#getExceptionText(params, realm).then((text) => ({
                    kind: 'success',
                    value: {
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                        params: {
                            level: "error" /* Log.Level.Error */,
                            source: realm.source,
                            text,
                            timestamp: Math.round(params.timestamp),
                            stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
                            type: 'javascript',
                        },
                    },
                }), (error) => ({
                    kind: 'error',
                    error,
                })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
            }
        });
    }
    /**
     * Try the best to get the exception text.
     */
    static async #getExceptionText(params, realm) {
        if (!params.exceptionDetails.exception) {
            return params.exceptionDetails.text;
        }
        if (realm === undefined) {
            return JSON.stringify(params.exceptionDetails.exception);
        }
        return await realm.stringifyObject(params.exceptionDetails.exception);
    }
}
exports.LogManager = LogManager;
//# sourceMappingURL=LogManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logMessageFormatter = logMessageFormatter;
exports.getRemoteValuesText = getRemoteValuesText;
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const specifiers = ['%s', '%d', '%i', '%f', '%o', '%O', '%c'];
function isFormatSpecifier(str) {
    return specifiers.some((spec) => str.includes(spec));
}
/**
 * @param args input remote values to be format printed
 * @return parsed text of the remote values in specific format
 */
function logMessageFormatter(args) {
    let output = '';
    const argFormat = args[0].value.toString();
    const argValues = args.slice(1, undefined);
    const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join('|'), 'g'));
    for (const token of tokens) {
        if (token === undefined || token === '') {
            continue;
        }
        if (isFormatSpecifier(token)) {
            const arg = argValues.shift();
            // raise an exception when less value is provided
            (0, assert_js_1.assert)(arg, `Less value is provided: "${getRemoteValuesText(args, false)}"`);
            if (token === '%s') {
                output += stringFromArg(arg);
            }
            else if (token === '%d' || token === '%i') {
                if (arg.type === 'bigint' ||
                    arg.type === 'number' ||
                    arg.type === 'string') {
                    output += parseInt(arg.value.toString(), 10);
                }
                else {
                    output += 'NaN';
                }
            }
            else if (token === '%f') {
                if (arg.type === 'bigint' ||
                    arg.type === 'number' ||
                    arg.type === 'string') {
                    output += parseFloat(arg.value.toString());
                }
                else {
                    output += 'NaN';
                }
            }
            else {
                // %o, %O, %c
                output += toJson(arg);
            }
        }
        else {
            output += token;
        }
    }
    // raise an exception when more value is provided
    if (argValues.length > 0) {
        throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
    }
    return output;
}
/**
 * @param arg input remote value to be parsed
 * @return parsed text of the remote value
 *
 * input: {"type": "number", "value": 1}
 * output: 1
 *
 * input: {"type": "string", "value": "abc"}
 * output: "abc"
 *
 * input: {"type": "object",  "value": [["id", {"type": "number", "value": 1}]]}
 * output: '{"id": 1}'
 *
 * input: {"type": "object", "value": [["font-size", {"type": "string", "value": "20px"}]]}
 * output: '{"font-size": "20px"}'
 */
function toJson(arg) {
    // arg type validation
    if (arg.type !== 'array' &&
        arg.type !== 'bigint' &&
        arg.type !== 'date' &&
        arg.type !== 'number' &&
        arg.type !== 'object' &&
        arg.type !== 'string') {
        return stringFromArg(arg);
    }
    if (arg.type === 'bigint') {
        return `${arg.value.toString()}n`;
    }
    if (arg.type === 'number') {
        return arg.value.toString();
    }
    if (['date', 'string'].includes(arg.type)) {
        return JSON.stringify(arg.value);
    }
    if (arg.type === 'object') {
        return `{${arg.value
            .map((pair) => {
            return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
        })
            .join(',')}}`;
    }
    if (arg.type === 'array') {
        return `[${arg.value?.map((val) => toJson(val)).join(',') ?? ''}]`;
    }
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    throw Error(`Invalid value type: ${arg}`);
}
function stringFromArg(arg) {
    if (!Object.hasOwn(arg, 'value')) {
        return arg.type;
    }
    switch (arg.type) {
        case 'string':
        case 'number':
        case 'boolean':
        case 'bigint':
            return String(arg.value);
        case 'regexp':
            return `/${arg.value.pattern}/${arg.value.flags ?? ''}`;
        case 'date':
            return new Date(arg.value).toString();
        case 'object':
            return `Object(${arg.value?.length ?? ''})`;
        case 'array':
            return `Array(${arg.value?.length ?? ''})`;
        case 'map':
            return `Map(${arg.value?.length})`;
        case 'set':
            return `Set(${arg.value?.length})`;
        default:
            return arg.type;
    }
}
function getRemoteValuesText(args, formatText) {
    const arg = args[0];
    if (!arg) {
        return '';
    }
    // if args[0] is a format specifier, format the args as output
    if (arg.type === 'string' &&
        isFormatSpecifier(arg.value.toString()) &&
        formatText) {
        return logMessageFormatter(args);
    }
    // if args[0] is not a format specifier, just join the args with \u0020 (unicode 'SPACE')
    return args
        .map((arg) => {
        return stringFromArg(arg);
    })
        .join('\u0020');
}
//# sourceMappingURL=logHelper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const UrlPattern_js_1 = __webpack_require__(/*! ../../../utils/UrlPattern.js */ "./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js");
/** Dispatches Network domain commands. */
class NetworkProcessor {
    #browsingContextStorage;
    #networkStorage;
    constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
    }
    async addIntercept(params) {
        this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases,
            contexts: params.contexts,
        });
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context) => {
            return context.cdpTarget.toggleFetchIfNeeded();
        }));
        return {
            intercept,
        };
    }
    async continueRequest(params) {
        if (params.url !== undefined) {
            NetworkProcessor.parseUrlString(params.url);
        }
        if (params.method !== undefined) {
            if (!NetworkProcessor.isMethodValid(params.method)) {
                throw new protocol_js_1.InvalidArgumentException(`Method '${params.method}' is invalid.`);
            }
        }
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
            "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */,
        ]);
        try {
            await request.continueRequest(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async continueResponse(params) {
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
            "responseStarted" /* Network.InterceptPhase.ResponseStarted */,
        ]);
        try {
            await request.continueResponse(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async continueWithAuth(params) {
        const networkId = params.request;
        const request = this.#getBlockedRequestOrFail(networkId, [
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
        ]);
        await request.continueWithAuth(params);
        return {};
    }
    async failRequest({ request: networkId, }) {
        const request = this.#getRequestOrFail(networkId);
        if (request.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            throw new protocol_js_1.InvalidArgumentException(`Request '${networkId}' in 'authRequired' phase cannot be failed`);
        }
        if (!request.interceptPhase) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        await request.failRequest('Failed');
        return {};
    }
    async provideResponse(params) {
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
            "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */,
            "responseStarted" /* Network.InterceptPhase.ResponseStarted */,
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
        ]);
        try {
            await request.provideResponse(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context) => {
            return context.cdpTarget.toggleFetchIfNeeded();
        }));
        return {};
    }
    #getRequestOrFail(id) {
        const request = this.#networkStorage.getRequestById(id);
        if (!request) {
            throw new protocol_js_1.NoSuchRequestException(`Network request with ID '${id}' doesn't exist`);
        }
        return request;
    }
    #getBlockedRequestOrFail(id, phases) {
        const request = this.#getRequestOrFail(id);
        if (!request.interceptPhase) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${id}'`);
        }
        if (request.interceptPhase && !phases.includes(request.interceptPhase)) {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${id}' is in '${request.interceptPhase}' phase`);
        }
        return request;
    }
    /**
     * Validate https://fetch.spec.whatwg.org/#header-value
     */
    static validateHeaders(headers) {
        for (const header of headers) {
            let headerValue;
            if (header.value.type === 'string') {
                headerValue = header.value.value;
            }
            else {
                headerValue = atob(header.value.value);
            }
            if (headerValue !== headerValue.trim() ||
                headerValue.includes('\n') ||
                headerValue.includes('\0')) {
                throw new protocol_js_1.InvalidArgumentException(`Header value '${headerValue}' is not acceptable value`);
            }
        }
    }
    static isMethodValid(method) {
        // https://httpwg.org/specs/rfc9110.html#method.overview
        return /^[!#$%&'*+\-.^_`|~a-zA-Z\d]+$/.test(method);
    }
    /**
     * Attempts to parse the given url.
     * Throws an InvalidArgumentException if the url is invalid.
     */
    static parseUrlString(url) {
        try {
            return new URL(url);
        }
        catch (error) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
        }
    }
    static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
                case 'string': {
                    NetworkProcessor.parseUrlString(urlPattern.pattern);
                    return urlPattern;
                }
                case 'pattern':
                    // No params signifies intercept all
                    if (urlPattern.protocol === undefined &&
                        urlPattern.hostname === undefined &&
                        urlPattern.port === undefined &&
                        urlPattern.pathname === undefined &&
                        urlPattern.search === undefined) {
                        return urlPattern;
                    }
                    if (urlPattern.protocol) {
                        urlPattern.protocol = unescapeURLPattern(urlPattern.protocol);
                        if (!urlPattern.protocol.match(/^[a-zA-Z+-.]+$/)) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    if (urlPattern.hostname) {
                        urlPattern.hostname = unescapeURLPattern(urlPattern.hostname);
                    }
                    if (urlPattern.port) {
                        urlPattern.port = unescapeURLPattern(urlPattern.port);
                    }
                    if (urlPattern.pathname) {
                        urlPattern.pathname = unescapeURLPattern(urlPattern.pathname);
                        if (urlPattern.pathname[0] !== '/') {
                            urlPattern.pathname = `/${urlPattern.pathname}`;
                        }
                        if (urlPattern.pathname.includes('#') ||
                            urlPattern.pathname.includes('?')) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    else if (urlPattern.pathname === '') {
                        urlPattern.pathname = '/';
                    }
                    if (urlPattern.search) {
                        urlPattern.search = unescapeURLPattern(urlPattern.search);
                        if (urlPattern.search[0] !== '?') {
                            urlPattern.search = `?${urlPattern.search}`;
                        }
                        if (urlPattern.search.includes('#')) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    if (urlPattern.protocol === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                    }
                    if (urlPattern.hostname === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                    }
                    if ((urlPattern.hostname?.length ?? 0) > 0) {
                        if (urlPattern.protocol?.match(/^file/i)) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                        }
                        if (urlPattern.hostname?.includes(':')) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                        }
                    }
                    if (urlPattern.port === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                    }
                    try {
                        new UrlPattern_js_1.URLPattern(urlPattern);
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`${error}`);
                    }
                    return urlPattern;
            }
        });
    }
    static wrapInterceptionError(error) {
        // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/fetch_handler.cc;l=169
        if (error?.message.includes('Invalid header')) {
            return new protocol_js_1.InvalidArgumentException('Invalid header');
        }
        return error;
    }
}
exports.NetworkProcessor = NetworkProcessor;
/**
 * See https://w3c.github.io/webdriver-bidi/#unescape-url-pattern
 */
function unescapeURLPattern(pattern) {
    const forbidden = new Set(['(', ')', '*', '{', '}']);
    let result = '';
    let isEscaped = false;
    for (const c of pattern) {
        if (!isEscaped) {
            if (forbidden.has(c)) {
                throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
            }
            if (c === '\\') {
                isEscaped = true;
                continue;
            }
        }
        result += c;
        isEscaped = false;
    }
    return result;
}
//# sourceMappingURL=NetworkProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkRequest = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ./NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
const REALM_REGEX = /(?<=realm=").*(?=")/;
/** Abstracts one individual network request. */
class NetworkRequest {
    static unknownParameter = 'UNKNOWN';
    /**
     * Each network request has an associated request id, which is a string
     * uniquely identifying that request.
     *
     * The identifier for a request resulting from a redirect matches that of the
     * request that initiated it.
     */
    #id;
    #fetchId;
    /**
     * Indicates the network intercept phase, if the request is currently blocked.
     * Undefined necessarily implies that the request is not blocked.
     */
    #interceptPhase;
    #servedFromCache = false;
    #redirectCount;
    #request = {};
    #requestOverrides;
    #response = {};
    #eventManager;
    #networkStorage;
    #cdpTarget;
    #logger;
    #emittedEvents = {
        [protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.FetchError]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted]: false,
    };
    waitNextPhase = new Deferred_js_1.Deferred();
    constructor(id, eventManager, networkStorage, cdpTarget, redirectCount = 0, logger) {
        this.#id = id;
        this.#eventManager = eventManager;
        this.#networkStorage = networkStorage;
        this.#cdpTarget = cdpTarget;
        this.#redirectCount = redirectCount;
        this.#logger = logger;
    }
    get id() {
        return this.#id;
    }
    get fetchId() {
        return this.#fetchId;
    }
    /**
     * When blocked returns the phase for it
     */
    get interceptPhase() {
        return this.#interceptPhase;
    }
    get url() {
        const fragment = this.#request.info?.request.urlFragment ??
            this.#request.paused?.request.urlFragment ??
            '';
        const url = this.#response.info?.url ??
            this.#response.paused?.request.url ??
            this.#requestOverrides?.url ??
            this.#request.auth?.request.url ??
            this.#request.info?.request.url ??
            this.#request.paused?.request.url ??
            NetworkRequest.unknownParameter;
        return `${url}${fragment}`;
    }
    get redirectCount() {
        return this.#redirectCount;
    }
    get cdpTarget() {
        return this.#cdpTarget;
    }
    get cdpClient() {
        return this.#cdpTarget.cdpClient;
    }
    isRedirecting() {
        return Boolean(this.#request.info);
    }
    #isDataUrl() {
        return this.url.startsWith('data:');
    }
    get #method() {
        return (this.#requestOverrides?.method ??
            this.#request.info?.request.method ??
            this.#request.paused?.request.method ??
            this.#request.auth?.request.method ??
            this.#response.paused?.request.method);
    }
    get #navigationId() {
        // Heuristic to determine if this is a navigation request, and if not return null.
        if (!this.#request.info ||
            !this.#request.info.loaderId ||
            // When we navigate all CDP network events have `loaderId`
            // CDP's `loaderId` and `requestId` match when
            // that request triggered the loading
            this.#request.info.loaderId !== this.#request.info.requestId) {
            return null;
        }
        // Get virtual navigation ID from the browsing context.
        return this.#networkStorage.getVirtualNavigationId(this.#context ?? undefined);
    }
    get #cookies() {
        let cookies = [];
        if (this.#request.extraInfo) {
            cookies = this.#request.extraInfo.associatedCookies
                .filter(({ blockedReasons }) => {
                return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
            })
                .map(({ cookie }) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(cookie));
        }
        return cookies;
    }
    get #bodySize() {
        let bodySize = 0;
        if (typeof this.#requestOverrides?.bodySize === 'number') {
            bodySize = this.#requestOverrides.bodySize;
        }
        else {
            bodySize = (0, NetworkUtils_js_1.bidiBodySizeFromCdpPostDataEntries)(this.#request.info?.request.postDataEntries ?? []);
        }
        return bodySize;
    }
    get #context() {
        return (this.#response.paused?.frameId ??
            this.#request.info?.frameId ??
            this.#request.paused?.frameId ??
            this.#request.auth?.frameId ??
            null);
    }
    /** Returns the HTTP status code associated with this request if any. */
    get #statusCode() {
        return (this.#response.paused?.responseStatusCode ??
            this.#response.extraInfo?.statusCode ??
            this.#response.info?.status);
    }
    get #requestHeaders() {
        let headers = [];
        if (this.#requestOverrides?.headers) {
            headers = this.#requestOverrides.headers;
        }
        else {
            headers = [
                ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#request.info?.request.headers),
                ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#request.extraInfo?.headers),
            ];
        }
        return headers;
    }
    get #authChallenges() {
        // TODO: get headers from Fetch.requestPaused
        if (!this.#response.info) {
            return;
        }
        if (!(this.#statusCode === 401 || this.#statusCode === 407)) {
            return undefined;
        }
        const headerName = this.#statusCode === 401 ? 'WWW-Authenticate' : 'Proxy-Authenticate';
        const authChallenges = [];
        for (const [header, value] of Object.entries(this.#response.info.headers)) {
            // TODO: Do a proper match based on https://httpwg.org/specs/rfc9110.html#credentials
            // Or verify this works
            if (header.localeCompare(headerName, undefined, { sensitivity: 'base' }) === 0) {
                authChallenges.push({
                    scheme: value.split(' ').at(0) ?? '',
                    realm: value.match(REALM_REGEX)?.at(0) ?? '',
                });
            }
        }
        return authChallenges;
    }
    get #timings() {
        return {
            // TODO: Verify this is correct
            timeOrigin: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.requestTime),
            requestTime: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.requestTime),
            redirectStart: 0,
            redirectEnd: 0,
            // TODO: Verify this is correct
            // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=145
            fetchStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.requestTime),
            dnsStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.dnsStart),
            dnsEnd: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.dnsEnd),
            connectStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.connectStart),
            connectEnd: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.connectEnd),
            tlsStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.sslStart),
            requestStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.sendStart),
            // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=196
            responseStart: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.receiveHeadersStart),
            responseEnd: (0, NetworkUtils_js_1.getTiming)(this.#response.info?.timing?.receiveHeadersEnd),
        };
    }
    #phaseChanged() {
        this.waitNextPhase.resolve();
        this.waitNextPhase = new Deferred_js_1.Deferred();
    }
    #interceptsInPhase(phase) {
        if (!this.#cdpTarget.isSubscribedTo(`network.${phase}`)) {
            return new Set();
        }
        return this.#networkStorage.getInterceptsForPhase(this, phase);
    }
    #isBlockedInPhase(phase) {
        return this.#interceptsInPhase(phase).size > 0;
    }
    handleRedirect(event) {
        // TODO: use event.redirectResponse;
        // Temporary workaround to emit ResponseCompleted event for redirects
        this.#response.hasExtraInfo = false;
        this.#response.info = event.redirectResponse;
        this.#emitEventsIfReady({
            wasRedirected: true,
        });
    }
    #emitEventsIfReady(options = {}) {
        const requestExtraInfoCompleted = 
        // Flush redirects
        options.wasRedirected ||
            options.hasFailed ||
            this.#isDataUrl() ||
            Boolean(this.#request.extraInfo) ||
            // Requests from cache don't have extra info
            this.#servedFromCache ||
            // Sometimes there is no extra info and the response
            // is the only place we can find out
            Boolean(this.#response.info && !this.#response.hasExtraInfo);
        const noInterceptionExpected = 
        // We can't intercept data urls from CDP
        this.#isDataUrl() ||
            // Cached requests never hit the network
            this.#servedFromCache;
        const requestInterceptionExpected = !noInterceptionExpected &&
            this.#isBlockedInPhase("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */);
        const requestInterceptionCompleted = !requestInterceptionExpected ||
            (requestInterceptionExpected && Boolean(this.#request.paused));
        if (Boolean(this.#request.info) &&
            (requestInterceptionExpected
                ? requestInterceptionCompleted
                : requestExtraInfoCompleted)) {
            this.#emitEvent(this.#getBeforeRequestEvent.bind(this));
        }
        const responseExtraInfoCompleted = Boolean(this.#response.extraInfo) ||
            // Response from cache don't have extra info
            this.#servedFromCache ||
            // Don't expect extra info if the flag is false
            Boolean(this.#response.info && !this.#response.hasExtraInfo);
        const responseInterceptionExpected = !noInterceptionExpected &&
            this.#isBlockedInPhase("responseStarted" /* Network.InterceptPhase.ResponseStarted */);
        if (this.#response.info ||
            (responseInterceptionExpected && Boolean(this.#response.paused))) {
            this.#emitEvent(this.#getResponseStartedEvent.bind(this));
        }
        const responseInterceptionCompleted = !responseInterceptionExpected ||
            (responseInterceptionExpected && Boolean(this.#response.paused));
        if (Boolean(this.#response.info) &&
            responseExtraInfoCompleted &&
            responseInterceptionCompleted) {
            this.#emitEvent(this.#getResponseReceivedEvent.bind(this));
            this.#networkStorage.deleteRequest(this.id);
        }
    }
    onRequestWillBeSentEvent(event) {
        this.#request.info = event;
        this.#emitEventsIfReady();
    }
    onRequestWillBeSentExtraInfoEvent(event) {
        this.#request.extraInfo = event;
        this.#emitEventsIfReady();
    }
    onResponseReceivedExtraInfoEvent(event) {
        if (event.statusCode >= 300 &&
            event.statusCode <= 399 &&
            this.#request.info &&
            event.headers['location'] === this.#request.info.request.url) {
            // We received the Response Extra info for the redirect
            // Too late so we need to skip it as it will
            // fire wrongly for the last one
            return;
        }
        this.#response.extraInfo = event;
        this.#emitEventsIfReady();
    }
    onResponseReceivedEvent(event) {
        this.#response.hasExtraInfo = event.hasExtraInfo;
        this.#response.info = event.response;
        this.#emitEventsIfReady();
    }
    onServedFromCache() {
        this.#servedFromCache = true;
        this.#emitEventsIfReady();
    }
    onLoadingFailedEvent(event) {
        this.#emitEventsIfReady({
            hasFailed: true,
        });
        this.#emitEvent(() => {
            return {
                method: protocol_js_1.ChromiumBidi.Network.EventNames.FetchError,
                params: {
                    ...this.#getBaseEventParams(),
                    errorText: event.errorText,
                },
            };
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest */
    async failRequest(errorReason) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.failRequest', {
            requestId: this.#fetchId,
            errorReason,
        });
        this.#interceptPhase = undefined;
    }
    onRequestPaused(event) {
        this.#fetchId = event.requestId;
        // CDP https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-requestPaused
        if (event.responseStatusCode || event.responseErrorReason) {
            this.#response.paused = event;
            if (this.#isBlockedInPhase("responseStarted" /* Network.InterceptPhase.ResponseStarted */) &&
                // CDP may emit multiple events for a single request
                !this.#emittedEvents[protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted] &&
                // Continue all response that have not enabled Network domain
                this.#fetchId !== this.id) {
                this.#interceptPhase = "responseStarted" /* Network.InterceptPhase.ResponseStarted */;
            }
            else {
                void this.#continueResponse();
            }
        }
        else {
            this.#request.paused = event;
            if (this.#isBlockedInPhase("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */) &&
                // CDP may emit multiple events for a single request
                !this.#emittedEvents[protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent] &&
                // Continue all requests that have not enabled Network domain
                this.#fetchId !== this.id) {
                this.#interceptPhase = "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */;
            }
            else {
                void this.#continueRequest();
            }
        }
        this.#emitEventsIfReady();
    }
    onAuthRequired(event) {
        this.#fetchId = event.requestId;
        this.#request.auth = event;
        if (this.#isBlockedInPhase("authRequired" /* Network.InterceptPhase.AuthRequired */) &&
            // Continue all auth requests that have not enabled Network domain
            this.#fetchId !== this.id) {
            this.#interceptPhase = "authRequired" /* Network.InterceptPhase.AuthRequired */;
        }
        else {
            void this.#continueWithAuth({
                response: 'Default',
            });
        }
        this.#emitEvent(() => {
            return {
                method: protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired,
                params: {
                    ...this.#getBaseEventParams("authRequired" /* Network.InterceptPhase.AuthRequired */),
                    response: this.#getResponseEventParams(),
                },
            };
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest */
    async continueRequest(overrides = {}) {
        const overrideHeaders = this.#getOverrideHeader(overrides.headers, overrides.cookies);
        const headers = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const postData = getCdpBodyFromBiDiBytesValue(overrides.body);
        await this.#continueRequest({
            url: overrides.url,
            method: overrides.method,
            headers,
            postData,
        });
        this.#requestOverrides = {
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            cookies: overrides.cookies,
            bodySize: getSizeFromBiDiBytesValue(overrides.body),
        };
    }
    async #continueRequest(overrides = {}) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueRequest', {
            requestId: this.#fetchId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData,
        });
        this.#interceptPhase = undefined;
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse */
    async continueResponse(overrides = {}) {
        if (this.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            if (overrides.credentials) {
                await Promise.all([
                    this.waitNextPhase,
                    await this.#continueWithAuth({
                        response: 'ProvideCredentials',
                        username: overrides.credentials.username,
                        password: overrides.credentials.password,
                    }),
                ]);
            }
            else {
                // We need to use `ProvideCredentials`
                // As `Default` may cancel the request
                return await this.#continueWithAuth({
                    response: 'ProvideCredentials',
                });
            }
        }
        if (this.#interceptPhase === "responseStarted" /* Network.InterceptPhase.ResponseStarted */) {
            const overrideHeaders = this.#getOverrideHeader(overrides.headers, overrides.cookies);
            const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
            await this.#continueResponse({
                responseCode: overrides.statusCode,
                responsePhrase: overrides.reasonPhrase,
                responseHeaders,
            });
        }
    }
    async #continueResponse({ responseCode, responsePhrase, responseHeaders, } = {}) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueResponse', {
            requestId: this.#fetchId,
            responseCode,
            responsePhrase,
            responseHeaders,
        });
        this.#interceptPhase = undefined;
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth */
    async continueWithAuth(authChallenge) {
        let username;
        let password;
        if (authChallenge.action === 'provideCredentials') {
            const { credentials } = authChallenge;
            username = credentials.username;
            password = credentials.password;
        }
        const response = (0, NetworkUtils_js_1.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(authChallenge.action);
        await this.#continueWithAuth({
            response,
            username,
            password,
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-provideResponse */
    async provideResponse(overrides) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        // We need to pass through if the request is already in
        // AuthRequired phase
        if (this.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            // We need to use `ProvideCredentials`
            // As `Default` may cancel the request
            return await this.#continueWithAuth({
                response: 'ProvideCredentials',
            });
        }
        // If we don't modify the response
        // just continue the request
        if (!overrides.body && !overrides.headers) {
            return await this.#continueRequest();
        }
        const overrideHeaders = this.#getOverrideHeader(overrides.headers, overrides.cookies);
        const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const responseCode = overrides.statusCode ?? this.#statusCode ?? 200;
        await this.cdpClient.sendCommand('Fetch.fulfillRequest', {
            requestId: this.#fetchId,
            responseCode,
            responsePhrase: overrides.reasonPhrase,
            responseHeaders,
            body: getCdpBodyFromBiDiBytesValue(overrides.body),
        });
        this.#interceptPhase = undefined;
    }
    async #continueWithAuth(authChallengeResponse) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueWithAuth', {
            requestId: this.#fetchId,
            authChallengeResponse,
        });
        this.#interceptPhase = undefined;
    }
    #emitEvent(getEvent) {
        let event;
        try {
            event = getEvent();
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, error);
            return;
        }
        if (this.#isIgnoredEvent() ||
            (this.#emittedEvents[event.method] &&
                // Special case this event can be emitted multiple times
                event.method !== protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired)) {
            return;
        }
        this.#phaseChanged();
        this.#emittedEvents[event.method] = true;
        this.#eventManager.registerEvent(Object.assign(event, {
            type: 'event',
        }), this.#context);
    }
    #getBaseEventParams(phase) {
        const interceptProps = {
            isBlocked: false,
        };
        if (phase) {
            const blockedBy = this.#interceptsInPhase(phase);
            interceptProps.isBlocked = blockedBy.size > 0;
            if (interceptProps.isBlocked) {
                interceptProps.intercepts = [...blockedBy];
            }
        }
        return {
            context: this.#context,
            navigation: this.#navigationId,
            redirectCount: this.#redirectCount,
            request: this.#getRequestData(),
            // Timestamp should be in milliseconds, while CDP provides it in seconds.
            timestamp: Math.round((0, NetworkUtils_js_1.getTiming)(this.#request.info?.wallTime) * 1000),
            // Contains isBlocked and intercepts
            ...interceptProps,
        };
    }
    #getResponseEventParams() {
        // Chromium sends wrong extraInfo events for responses served from cache.
        // See https://github.com/puppeteer/puppeteer/issues/9965 and
        // https://crbug.com/1340398.
        if (this.#response.info?.fromDiskCache) {
            this.#response.extraInfo = undefined;
        }
        const headers = [
            ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.info?.headers),
            ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.extraInfo?.headers),
            // TODO: Verify how to dedupe these
            // ...bidiNetworkHeadersFromCdpNetworkHeadersEntries(
            //   this.#response.paused?.responseHeaders
            // ),
        ];
        const authChallenges = this.#authChallenges;
        return {
            url: this.url,
            protocol: this.#response.info?.protocol ?? '',
            status: this.#statusCode ?? -1, // TODO: Throw an exception or use some other status code?
            statusText: this.#response.info?.statusText ||
                this.#response.paused?.responseStatusText ||
                '',
            fromCache: this.#response.info?.fromDiskCache ||
                this.#response.info?.fromPrefetchCache ||
                this.#servedFromCache,
            headers,
            mimeType: this.#response.info?.mimeType || '',
            bytesReceived: this.#response.info?.encodedDataLength || 0,
            headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
            // TODO: consider removing from spec.
            bodySize: 0,
            content: {
                // TODO: consider removing from spec.
                size: 0,
            },
            ...(authChallenges ? { authChallenges } : {}),
            // @ts-expect-error this is a CDP-specific extension.
            'goog:securityDetails': this.#response.info?.securityDetails,
        };
    }
    #getRequestData() {
        const headers = this.#requestHeaders;
        return {
            request: this.#id,
            url: this.url,
            method: this.#method ?? NetworkRequest.unknownParameter,
            headers,
            cookies: this.#cookies,
            headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
            bodySize: this.#bodySize,
            timings: this.#timings,
            // @ts-expect-error CDP-specific attribute.
            'goog:postData': this.#request.info?.request?.postData,
            'goog:hasPostData': this.#request.info?.request?.hasPostData,
            'goog:resourceType': this.#request.info?.type,
        };
    }
    #getBeforeRequestEvent() {
        (0, assert_js_1.assert)(this.#request.info, 'RequestWillBeSentEvent is not set');
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent,
            params: {
                ...this.#getBaseEventParams("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */),
                initiator: {
                    type: NetworkRequest.#getInitiatorType(this.#request.info.initiator.type),
                    columnNumber: this.#request.info.initiator.columnNumber,
                    lineNumber: this.#request.info.initiator.lineNumber,
                    stackTrace: this.#request.info.initiator.stack,
                    request: this.#request.info.initiator.requestId,
                },
            },
        };
    }
    #getResponseStartedEvent() {
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted,
            params: {
                ...this.#getBaseEventParams("responseStarted" /* Network.InterceptPhase.ResponseStarted */),
                response: this.#getResponseEventParams(),
            },
        };
    }
    #getResponseReceivedEvent() {
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted,
            params: {
                ...this.#getBaseEventParams(),
                response: this.#getResponseEventParams(),
            },
        };
    }
    #isIgnoredEvent() {
        const faviconUrl = '/favicon.ico';
        return (this.#request.paused?.request.url.endsWith(faviconUrl) ??
            this.#request.info?.request.url.endsWith(faviconUrl) ??
            false);
    }
    #getOverrideHeader(headers, cookies) {
        if (!headers && !cookies) {
            return undefined;
        }
        let overrideHeaders = headers;
        const cookieHeader = (0, NetworkUtils_js_1.networkHeaderFromCookieHeaders)(cookies);
        if (cookieHeader && !overrideHeaders) {
            overrideHeaders = this.#requestHeaders;
        }
        if (cookieHeader && overrideHeaders) {
            overrideHeaders.filter((header) => header.name.localeCompare('cookie', undefined, {
                sensitivity: 'base',
            }) !== 0);
            overrideHeaders.push(cookieHeader);
        }
        return overrideHeaders;
    }
    static #getInitiatorType(initiatorType) {
        switch (initiatorType) {
            case 'parser':
            case 'script':
            case 'preflight':
                return initiatorType;
            default:
                return 'other';
        }
    }
}
exports.NetworkRequest = NetworkRequest;
function getCdpBodyFromBiDiBytesValue(body) {
    let parsedBody;
    if (body?.type === 'string') {
        parsedBody = btoa(body.value);
    }
    else if (body?.type === 'base64') {
        parsedBody = body.value;
    }
    return parsedBody;
}
function getSizeFromBiDiBytesValue(body) {
    if (body?.type === 'string') {
        return body.value.length;
    }
    else if (body?.type === 'base64') {
        return atob(body.value).length;
    }
    return 0;
}
//# sourceMappingURL=NetworkRequest.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const NetworkRequest_js_1 = __webpack_require__(/*! ./NetworkRequest.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ./NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
/** Stores network and intercept maps. */
class NetworkStorage {
    #browsingContextStorage;
    #eventManager;
    #logger;
    /**
     * A map from network request ID to Network Request objects.
     * Needed as long as information about requests comes from different events.
     */
    #requests = new Map();
    /** A map from intercept ID to track active network intercepts. */
    #intercepts = new Map();
    constructor(eventManager, browsingContextStorage, browserClient, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        browserClient.on('Target.detachedFromTarget', ({ sessionId }) => {
            this.disposeRequestMap(sessionId);
        });
        this.#logger = logger;
    }
    /**
     * Gets the network request with the given ID, if any.
     * Otherwise, creates a new network request with the given ID and cdp target.
     */
    #getOrCreateNetworkRequest(id, cdpTarget, redirectCount) {
        let request = this.getRequestById(id);
        if (request) {
            return request;
        }
        request = new NetworkRequest_js_1.NetworkRequest(id, this.#eventManager, this, cdpTarget, redirectCount, this.#logger);
        this.addRequest(request);
        return request;
    }
    onCdpTargetCreated(cdpTarget) {
        const cdpClient = cdpTarget.cdpClient;
        // TODO: Wrap into object
        const listeners = [
            [
                'Network.requestWillBeSent',
                (params) => {
                    const request = this.getRequestById(params.requestId);
                    if (request && request.isRedirecting()) {
                        request.handleRedirect(params);
                        this.deleteRequest(params.requestId);
                        this.#getOrCreateNetworkRequest(params.requestId, cdpTarget, request.redirectCount + 1).onRequestWillBeSentEvent(params);
                    }
                    else {
                        this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentEvent(params);
                    }
                },
            ],
            [
                'Network.requestWillBeSentExtraInfo',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentExtraInfoEvent(params);
                },
            ],
            [
                'Network.responseReceived',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedEvent(params);
                },
            ],
            [
                'Network.responseReceivedExtraInfo',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedExtraInfoEvent(params);
                },
            ],
            [
                'Network.requestServedFromCache',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onServedFromCache();
                },
            ],
            [
                'Network.loadingFailed',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onLoadingFailedEvent(params);
                },
            ],
            [
                'Fetch.requestPaused',
                (event) => {
                    this.#getOrCreateNetworkRequest(
                    // CDP quirk if the Network domain is not present this is undefined
                    event.networkId ?? event.requestId, cdpTarget).onRequestPaused(event);
                },
            ],
            [
                'Fetch.authRequired',
                (event) => {
                    let request = this.getRequestByFetchId(event.requestId);
                    if (!request) {
                        request = this.#getOrCreateNetworkRequest(event.requestId, cdpTarget);
                    }
                    request.onAuthRequired(event);
                },
            ],
        ];
        for (const [event, listener] of listeners) {
            cdpClient.on(event, listener);
        }
    }
    getInterceptionStages(browsingContextId) {
        const stages = {
            request: false,
            response: false,
            auth: false,
        };
        for (const intercept of this.#intercepts.values()) {
            if (intercept.contexts &&
                !intercept.contexts.includes(browsingContextId)) {
                continue;
            }
            stages.request ||= intercept.phases.includes("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */);
            stages.response ||= intercept.phases.includes("responseStarted" /* Network.InterceptPhase.ResponseStarted */);
            stages.auth ||= intercept.phases.includes("authRequired" /* Network.InterceptPhase.AuthRequired */);
        }
        return stages;
    }
    getInterceptsForPhase(request, phase) {
        if (request.url === NetworkRequest_js_1.NetworkRequest.unknownParameter) {
            return new Set();
        }
        const intercepts = new Set();
        for (const [interceptId, intercept] of this.#intercepts.entries()) {
            if (!intercept.phases.includes(phase) ||
                (intercept.contexts &&
                    !intercept.contexts.includes(request.cdpTarget.topLevelId))) {
                continue;
            }
            if (intercept.urlPatterns.length === 0) {
                intercepts.add(interceptId);
                continue;
            }
            for (const pattern of intercept.urlPatterns) {
                if ((0, NetworkUtils_js_1.matchUrlPattern)(pattern, request.url)) {
                    intercepts.add(interceptId);
                    break;
                }
            }
        }
        return intercepts;
    }
    disposeRequestMap(sessionId) {
        for (const request of this.#requests.values()) {
            if (request.cdpClient.sessionId === sessionId) {
                this.#requests.delete(request.id);
            }
        }
    }
    /**
     * Adds the given entry to the intercept map.
     * URL patterns are assumed to be parsed.
     *
     * @return The intercept ID.
     */
    addIntercept(value) {
        const interceptId = (0, uuid_js_1.uuidv4)();
        this.#intercepts.set(interceptId, value);
        return interceptId;
    }
    /**
     * Removes the given intercept from the intercept map.
     * Throws NoSuchInterceptException if the intercept does not exist.
     */
    removeIntercept(intercept) {
        if (!this.#intercepts.has(intercept)) {
            throw new protocol_js_1.NoSuchInterceptException(`Intercept '${intercept}' does not exist.`);
        }
        this.#intercepts.delete(intercept);
    }
    getRequestById(id) {
        return this.#requests.get(id);
    }
    getRequestByFetchId(fetchId) {
        for (const request of this.#requests.values()) {
            if (request.fetchId === fetchId) {
                return request;
            }
        }
        return;
    }
    addRequest(request) {
        this.#requests.set(request.id, request);
    }
    deleteRequest(id) {
        this.#requests.delete(id);
    }
    /**
     * Gets the virtual navigation ID for the given navigable ID.
     */
    getVirtualNavigationId(contextId) {
        if (contextId === undefined) {
            return null;
        }
        return (this.#browsingContextStorage.findContext(contextId)
            ?.virtualNavigationId ?? null);
    }
}
exports.NetworkStorage = NetworkStorage;
//# sourceMappingURL=NetworkStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeHeadersSize = computeHeadersSize;
exports.bidiNetworkHeadersFromCdpNetworkHeaders = bidiNetworkHeadersFromCdpNetworkHeaders;
exports.bidiNetworkHeadersFromCdpNetworkHeadersEntries = bidiNetworkHeadersFromCdpNetworkHeadersEntries;
exports.cdpNetworkHeadersFromBidiNetworkHeaders = cdpNetworkHeadersFromBidiNetworkHeaders;
exports.bidiNetworkHeadersFromCdpFetchHeaders = bidiNetworkHeadersFromCdpFetchHeaders;
exports.cdpFetchHeadersFromBidiNetworkHeaders = cdpFetchHeadersFromBidiNetworkHeaders;
exports.networkHeaderFromCookieHeaders = networkHeaderFromCookieHeaders;
exports.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction;
exports.cdpToBiDiCookie = cdpToBiDiCookie;
exports.deserializeByteValue = deserializeByteValue;
exports.bidiToCdpCookie = bidiToCdpCookie;
exports.sameSiteBiDiToCdp = sameSiteBiDiToCdp;
exports.isSpecialScheme = isSpecialScheme;
exports.matchUrlPattern = matchUrlPattern;
exports.bidiBodySizeFromCdpPostDataEntries = bidiBodySizeFromCdpPostDataEntries;
exports.getTiming = getTiming;
const ErrorResponse_js_1 = __webpack_require__(/*! ../../../protocol/ErrorResponse.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js");
const Base64_js_1 = __webpack_require__(/*! ../../../utils/Base64.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Base64.js");
const UrlPattern_js_1 = __webpack_require__(/*! ../../../utils/UrlPattern.js */ "./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js");
function computeHeadersSize(headers) {
    const requestHeaders = headers.reduce((acc, header) => {
        return `${acc}${header.name}: ${header.value.value}\r\n`;
    }, '');
    return new TextEncoder().encode(requestHeaders).length;
}
/** Converts from CDP Network domain headers to BiDi network headers. */
function bidiNetworkHeadersFromCdpNetworkHeaders(headers) {
    if (!headers) {
        return [];
    }
    return Object.entries(headers).map(([name, value]) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from CDP Fetch domain headers to BiDi network headers. */
function bidiNetworkHeadersFromCdpNetworkHeadersEntries(headers) {
    if (!headers) {
        return [];
    }
    return headers.map(({ name, value }) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from Bidi network headers to CDP Network domain headers. */
function cdpNetworkHeadersFromBidiNetworkHeaders(headers) {
    if (headers === undefined) {
        return undefined;
    }
    return headers.reduce((result, header) => {
        // TODO: Distinguish between string and bytes?
        result[header.name] = header.value.value;
        return result;
    }, {});
}
/** Converts from CDP Fetch domain header entries to Bidi network headers. */
function bidiNetworkHeadersFromCdpFetchHeaders(headers) {
    if (!headers) {
        return [];
    }
    return headers.map(({ name, value }) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from Bidi network headers to CDP Fetch domain header entries. */
function cdpFetchHeadersFromBidiNetworkHeaders(headers) {
    if (headers === undefined) {
        return undefined;
    }
    return headers.map(({ name, value }) => ({
        name,
        value: value.value,
    }));
}
function networkHeaderFromCookieHeaders(headers) {
    if (headers === undefined) {
        return undefined;
    }
    const value = headers.reduce((acc, value, index) => {
        if (index > 0) {
            acc += ';';
        }
        const cookieValue = value.value.type === 'base64'
            ? btoa(value.value.value)
            : value.value.value;
        acc += `${value.name}=${cookieValue}`;
        return acc;
    }, '');
    return {
        name: 'Cookie',
        value: {
            type: 'string',
            value,
        },
    };
}
/** Converts from Bidi auth action to CDP auth challenge response. */
function cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(action) {
    switch (action) {
        case 'default':
            return 'Default';
        case 'cancel':
            return 'CancelAuth';
        case 'provideCredentials':
            return 'ProvideCredentials';
    }
}
/**
 * Converts from CDP Network domain cookie to BiDi network cookie.
 * * https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Cookie
 * * https://w3c.github.io/webdriver-bidi/#type-network-Cookie
 */
function cdpToBiDiCookie(cookie) {
    const result = {
        name: cookie.name,
        value: { type: 'string', value: cookie.value },
        domain: cookie.domain,
        path: cookie.path,
        size: cookie.size,
        httpOnly: cookie.httpOnly,
        secure: cookie.secure,
        sameSite: cookie.sameSite === undefined
            ? "none" /* Network.SameSite.None */
            : sameSiteCdpToBiDi(cookie.sameSite),
        ...(cookie.expires >= 0 ? { expiry: cookie.expires } : undefined),
    };
    // Extending with CDP-specific properties with `goog:` prefix.
    result[`goog:session`] = cookie.session;
    result[`goog:priority`] = cookie.priority;
    result[`goog:sameParty`] = cookie.sameParty;
    result[`goog:sourceScheme`] = cookie.sourceScheme;
    result[`goog:sourcePort`] = cookie.sourcePort;
    if (cookie.partitionKey !== undefined) {
        result[`goog:partitionKey`] = cookie.partitionKey;
    }
    if (cookie.partitionKeyOpaque !== undefined) {
        result[`goog:partitionKeyOpaque`] = cookie.partitionKeyOpaque;
    }
    return result;
}
/**
 * Decodes a byte value to a string.
 * @param {Network.BytesValue} value
 * @return {string}
 */
function deserializeByteValue(value) {
    if (value.type === 'base64') {
        return (0, Base64_js_1.base64ToString)(value.value);
    }
    return value.value;
}
/**
 * Converts from BiDi set network cookie params to CDP Network domain cookie.
 * * https://w3c.github.io/webdriver-bidi/#type-network-Cookie
 * * https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-CookieParam
 */
function bidiToCdpCookie(params, partitionKey) {
    const deserializedValue = deserializeByteValue(params.cookie.value);
    const result = {
        name: params.cookie.name,
        value: deserializedValue,
        domain: params.cookie.domain,
        path: params.cookie.path ?? '/',
        secure: params.cookie.secure ?? false,
        httpOnly: params.cookie.httpOnly ?? false,
        ...(partitionKey.sourceOrigin !== undefined && {
            partitionKey: {
                hasCrossSiteAncestor: false,
                // CDP's `partitionKey.topLevelSite` is the BiDi's `partition.sourceOrigin`.
                topLevelSite: partitionKey.sourceOrigin,
            },
        }),
        ...(params.cookie.expiry !== undefined && {
            expires: params.cookie.expiry,
        }),
        ...(params.cookie.sameSite !== undefined && {
            sameSite: sameSiteBiDiToCdp(params.cookie.sameSite),
        }),
    };
    // Extending with CDP-specific properties with `goog:` prefix.
    if (params.cookie[`goog:url`] !== undefined) {
        result.url = params.cookie[`goog:url`];
    }
    if (params.cookie[`goog:priority`] !== undefined) {
        result.priority = params.cookie[`goog:priority`];
    }
    if (params.cookie[`goog:sameParty`] !== undefined) {
        result.sameParty = params.cookie[`goog:sameParty`];
    }
    if (params.cookie[`goog:sourceScheme`] !== undefined) {
        result.sourceScheme = params.cookie[`goog:sourceScheme`];
    }
    if (params.cookie[`goog:sourcePort`] !== undefined) {
        result.sourcePort = params.cookie[`goog:sourcePort`];
    }
    return result;
}
function sameSiteCdpToBiDi(sameSite) {
    switch (sameSite) {
        case 'Strict':
            return "strict" /* Network.SameSite.Strict */;
        case 'None':
            return "none" /* Network.SameSite.None */;
        case 'Lax':
            return "lax" /* Network.SameSite.Lax */;
        default:
            // Defaults to `Lax`:
            // https://web.dev/articles/samesite-cookies-explained#samesitelax_by_default
            return "lax" /* Network.SameSite.Lax */;
    }
}
function sameSiteBiDiToCdp(sameSite) {
    switch (sameSite) {
        case "strict" /* Network.SameSite.Strict */:
            return 'Strict';
        case "lax" /* Network.SameSite.Lax */:
            return 'Lax';
        case "none" /* Network.SameSite.None */:
            return 'None';
    }
    throw new ErrorResponse_js_1.InvalidArgumentException(`Unknown 'sameSite' value ${sameSite}`);
}
/**
 * Returns true if the given protocol is special.
 * Special protocols are those that have a default port.
 *
 * Example inputs: 'http', 'http:'
 *
 * @see https://url.spec.whatwg.org/#special-scheme
 */
function isSpecialScheme(protocol) {
    return ['ftp', 'file', 'http', 'https', 'ws', 'wss'].includes(protocol.replace(/:$/, ''));
}
/** Matches the given URLPattern against the given URL. */
function matchUrlPattern(urlPattern, url) {
    switch (urlPattern.type) {
        case 'string': {
            const pattern = new UrlPattern_js_1.URLPattern(urlPattern.pattern);
            return new UrlPattern_js_1.URLPattern({
                protocol: pattern.protocol,
                hostname: pattern.hostname,
                port: pattern.port,
                pathname: pattern.pathname,
                search: pattern.search,
            }).test(url);
        }
        case 'pattern':
            return new UrlPattern_js_1.URLPattern(urlPattern).test(url);
    }
}
function bidiBodySizeFromCdpPostDataEntries(entries) {
    let size = 0;
    for (const entry of entries) {
        size += atob(entry.bytes ?? '').length;
    }
    return size;
}
function getTiming(timing) {
    if (!timing) {
        return 0;
    }
    if (timing < 0) {
        return 0;
    }
    return timing;
}
//# sourceMappingURL=NetworkUtils.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class PermissionsProcessor {
    #browserCdpClient;
    constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
    }
    async setPermissions(params) {
        try {
            const userContextId = params['goog:userContext'] ||
                params.userContext;
            await this.#browserCdpClient.sendCommand('Browser.setPermission', {
                origin: params.origin,
                browserContextId: userContextId && userContextId !== 'default'
                    ? userContextId
                    : undefined,
                permission: {
                    name: params.descriptor.name,
                },
                setting: params.state,
            });
        }
        catch (err) {
            if (err.message ===
                `Permission can't be granted to opaque origins.`) {
                // Return success if the origin is not valid (does not match any
                // existing origins).
                return {};
            }
            throw new protocol_js_1.InvalidArgumentException(err.message);
        }
        return {};
    }
}
exports.PermissionsProcessor = PermissionsProcessor;
//# sourceMappingURL=PermissionsProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelProxy = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
/**
 * Used to send messages from realm to BiDi user.
 */
class ChannelProxy {
    #properties;
    #id = (0, uuid_js_1.uuidv4)();
    #logger;
    constructor(channel, logger) {
        this.#properties = channel;
        this.#logger = logger;
    }
    /**
     * Creates a channel proxy in the given realm, initialises listener and
     * returns a handle to `sendMessage` delegate.
     */
    async init(realm, eventManager) {
        const channelHandle = await ChannelProxy.#createAndGetHandleInRealm(realm);
        const sendMessageHandle = await ChannelProxy.#createSendMessageHandle(realm, channelHandle);
        void this.#startListener(realm, channelHandle, eventManager);
        return sendMessageHandle;
    }
    /** Gets a ChannelProxy from window and returns its handle. */
    async startListenerFromWindow(realm, eventManager) {
        try {
            const channelHandle = await this.#getHandleFromWindow(realm);
            void this.#startListener(realm, channelHandle, eventManager);
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, error);
        }
    }
    /**
     * Evaluation string which creates a ChannelProxy object on the client side.
     */
    static #createChannelProxyEvalStr() {
        const functionStr = String(() => {
            const queue = [];
            let queueNonEmptyResolver = null;
            return {
                /**
                 * Gets a promise, which is resolved as soon as a message occurs
                 * in the queue.
                 */
                async getMessage() {
                    const onMessage = queue.length > 0
                        ? Promise.resolve()
                        : new Promise((resolve) => {
                            queueNonEmptyResolver = resolve;
                        });
                    await onMessage;
                    return queue.shift();
                },
                /**
                 * Adds a message to the queue.
                 * Resolves the pending promise if needed.
                 */
                sendMessage(message) {
                    queue.push(message);
                    if (queueNonEmptyResolver !== null) {
                        queueNonEmptyResolver();
                        queueNonEmptyResolver = null;
                    }
                },
            };
        });
        return `(${functionStr})()`;
    }
    /** Creates a ChannelProxy in the given realm. */
    static async #createAndGetHandleInRealm(realm) {
        const createChannelHandleResult = await realm.cdpClient.sendCommand('Runtime.evaluate', {
            expression: this.#createChannelProxyEvalStr(),
            contextId: realm.executionContextId,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        if (createChannelHandleResult.exceptionDetails ||
            createChannelHandleResult.result.objectId === undefined) {
            throw new Error(`Cannot create channel`);
        }
        return createChannelHandleResult.result.objectId;
    }
    /** Gets a handle to `sendMessage` delegate from the ChannelProxy handle. */
    static async #createSendMessageHandle(realm, channelHandle) {
        const sendMessageArgResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((channelHandle) => {
                return channelHandle.sendMessage;
            }),
            arguments: [{ objectId: channelHandle }],
            executionContextId: realm.executionContextId,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        // TODO: check for exceptionDetails.
        return sendMessageArgResult.result.objectId;
    }
    /** Starts listening for the channel events of the provided ChannelProxy. */
    async #startListener(realm, channelHandle, eventManager) {
        // noinspection InfiniteLoopJS
        for (;;) {
            try {
                const message = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String(async (channelHandle) => await channelHandle.getMessage()),
                    arguments: [
                        {
                            objectId: channelHandle,
                        },
                    ],
                    awaitPromise: true,
                    executionContextId: realm.executionContextId,
                    serializationOptions: {
                        serialization: "deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */,
                        maxDepth: this.#properties.serializationOptions?.maxObjectDepth ??
                            undefined,
                    },
                });
                if (message.exceptionDetails) {
                    throw new Error('Runtime.callFunctionOn in ChannelProxy', {
                        cause: message.exceptionDetails,
                    });
                }
                for (const browsingContext of realm.associatedBrowsingContexts) {
                    eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,
                        params: {
                            channel: this.#properties.channel,
                            data: realm.cdpToBidiValue(message, this.#properties.ownership ?? "none" /* Script.ResultOwnership.None */),
                            source: realm.source,
                        },
                    }, browsingContext.id);
                }
            }
            catch (error) {
                // If an error is thrown, then the channel is permanently broken, so we
                // exit the loop.
                this.#logger?.(log_js_1.LogType.debugError, error);
                break;
            }
        }
    }
    /**
     * Returns a handle of ChannelProxy from window's property which was set there
     * by `getEvalInWindowStr`. If window property is not set yet, sets a promise
     * resolver to the window property, so that `getEvalInWindowStr` can resolve
     * the promise later on with the channel.
     * This is needed because `getEvalInWindowStr` can be called before or
     * after this method.
     */
    async #getHandleFromWindow(realm) {
        const channelHandleResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((id) => {
                const w = window;
                if (w[id] === undefined) {
                    // The channelProxy is not created yet. Create a promise, put the
                    // resolver to window property and return the promise.
                    // `getEvalInWindowStr` will resolve the promise later.
                    return new Promise((resolve) => (w[id] = resolve));
                }
                // The channelProxy is already created by `getEvalInWindowStr` and
                // is set into window property. Return it.
                const channelProxy = w[id];
                delete w[id];
                return channelProxy;
            }),
            arguments: [{ value: this.#id }],
            executionContextId: realm.executionContextId,
            awaitPromise: true,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        if (channelHandleResult.exceptionDetails !== undefined ||
            channelHandleResult.result.objectId === undefined) {
            throw new Error(`ChannelHandle not found in window["${this.#id}"]`);
        }
        return channelHandleResult.result.objectId;
    }
    /**
     * String to be evaluated to create a ProxyChannel and put it to window.
     * Returns the delegate `sendMessage`. Used to provide an argument for preload
     * script. Does the following:
     * 1. Creates a ChannelProxy.
     * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise
     *    by calling delegate stored in window['${this.#id}'].
     *    This is needed because `#getHandleFromWindow` can be called before or
     *    after this method.
     * 3. Returns the delegate `sendMessage` of the created ChannelProxy.
     */
    getEvalInWindowStr() {
        const delegate = String((id, channelProxy) => {
            const w = window;
            if (w[id] === undefined) {
                // `#getHandleFromWindow` is not initialized yet, and will get the
                // channelProxy later.
                w[id] = channelProxy;
            }
            else {
                // `#getHandleFromWindow` is already set a delegate to window property
                // and is waiting for it to be called with the channelProxy.
                w[id](channelProxy);
                delete w[id];
            }
            return channelProxy.sendMessage;
        });
        const channelProxyEval = ChannelProxy.#createChannelProxyEvalStr();
        return `(${delegate})('${this.#id}',${channelProxyEval})`;
    }
}
exports.ChannelProxy = ChannelProxy;
//# sourceMappingURL=ChannelProxy.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreloadScript = void 0;
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const ChannelProxy_js_1 = __webpack_require__(/*! ./ChannelProxy.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js");
/**
 * BiDi IDs are generated by the server and are unique within contexts.
 *
 * CDP preload script IDs are generated by the client and are unique
 * within sessions.
 *
 * The mapping between BiDi and CDP preload script IDs is 1:many.
 * BiDi IDs are needed by the mapper to keep track of potential multiple CDP IDs
 * in the client.
 */
class PreloadScript {
    /** BiDi ID, an automatically generated UUID. */
    #id = (0, uuid_js_1.uuidv4)();
    /** CDP preload scripts. */
    #cdpPreloadScripts = [];
    /** The script itself, in a format expected by the spec i.e. a function. */
    #functionDeclaration;
    /** Targets, in which the preload script is initialized. */
    #targetIds = new Set();
    /** Channels to be added as arguments to functionDeclaration. */
    #channels;
    /** The script sandbox / world name. */
    #sandbox;
    /** The browsing contexts to execute the preload scripts in, if any. */
    #contexts;
    get id() {
        return this.#id;
    }
    get targetIds() {
        return this.#targetIds;
    }
    constructor(params, logger) {
        this.#channels =
            params.arguments?.map((a) => new ChannelProxy_js_1.ChannelProxy(a.value, logger)) ?? [];
        this.#functionDeclaration = params.functionDeclaration;
        this.#sandbox = params.sandbox;
        this.#contexts = params.contexts;
    }
    /** Channels of the preload script. */
    get channels() {
        return this.#channels;
    }
    /** Contexts of the preload script, if any */
    get contexts() {
        return this.#contexts;
    }
    /**
     * String to be evaluated. Wraps user-provided function so that the following
     * steps are run:
     * 1. Create channels.
     * 2. Store the created channels in window.
     * 3. Call the user-provided function with channels as arguments.
     */
    #getEvaluateString() {
        const channelsArgStr = `[${this.channels
            .map((c) => c.getEvalInWindowStr())
            .join(', ')}]`;
        return `(()=>{(${this.#functionDeclaration})(...${channelsArgStr})})()`;
    }
    /**
     * Adds the script to the given CDP targets by calling the
     * `Page.addScriptToEvaluateOnNewDocument` command.
     */
    async initInTargets(cdpTargets, runImmediately) {
        await Promise.all(Array.from(cdpTargets).map((cdpTarget) => this.initInTarget(cdpTarget, runImmediately)));
    }
    /**
     * Adds the script to the given CDP target by calling the
     * `Page.addScriptToEvaluateOnNewDocument` command.
     */
    async initInTarget(cdpTarget, runImmediately) {
        const addCdpPreloadScriptResult = await cdpTarget.cdpClient.sendCommand('Page.addScriptToEvaluateOnNewDocument', {
            source: this.#getEvaluateString(),
            worldName: this.#sandbox,
            runImmediately,
        });
        this.#cdpPreloadScripts.push({
            target: cdpTarget,
            preloadScriptId: addCdpPreloadScriptResult.identifier,
        });
        this.#targetIds.add(cdpTarget.id);
    }
    /**
     * Removes this script from all CDP targets.
     */
    async remove() {
        await Promise.all([
            this.#cdpPreloadScripts.map(async (cdpPreloadScript) => {
                const cdpTarget = cdpPreloadScript.target;
                const cdpPreloadScriptId = cdpPreloadScript.preloadScriptId;
                return await cdpTarget.cdpClient.sendCommand('Page.removeScriptToEvaluateOnNewDocument', {
                    identifier: cdpPreloadScriptId,
                });
            }),
        ]);
    }
    /** Removes the provided cdp target from the list of cdp preload scripts. */
    dispose(cdpTargetId) {
        this.#cdpPreloadScripts = this.#cdpPreloadScripts.filter((cdpPreloadScript) => cdpPreloadScript.target?.id !== cdpTargetId);
        this.#targetIds.delete(cdpTargetId);
    }
}
exports.PreloadScript = PreloadScript;
//# sourceMappingURL=PreloadScript.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreloadScriptStorage = void 0;
/**
 * Container class for preload scripts.
 */
class PreloadScriptStorage {
    /** Tracks all BiDi preload scripts.  */
    #scripts = new Set();
    /**
     * Finds all entries that match the given filter (OR logic).
     */
    find(filter) {
        if (!filter) {
            return [...this.#scripts];
        }
        return [...this.#scripts].filter((script) => {
            if (filter.id !== undefined && filter.id === script.id) {
                return true;
            }
            if (filter.targetId !== undefined &&
                script.targetIds.has(filter.targetId)) {
                return true;
            }
            if (filter.global !== undefined &&
                // Global scripts have no contexts
                ((filter.global && script.contexts === undefined) ||
                    // Non global scripts always have contexts
                    (!filter.global && script.contexts !== undefined))) {
                return true;
            }
            return false;
        });
    }
    add(preloadScript) {
        this.#scripts.add(preloadScript);
    }
    /** Deletes all BiDi preload script entries that match the given filter. */
    remove(filter) {
        for (const preloadScript of this.find(filter)) {
            this.#scripts.delete(preloadScript);
        }
    }
}
exports.PreloadScriptStorage = PreloadScriptStorage;
//# sourceMappingURL=PreloadScriptStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Realm = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const ChannelProxy_js_1 = __webpack_require__(/*! ./ChannelProxy.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js");
class Realm {
    #cdpClient;
    #eventManager;
    #executionContextId;
    #logger;
    #origin;
    #realmId;
    #realmStorage;
    constructor(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage) {
        this.#cdpClient = cdpClient;
        this.#eventManager = eventManager;
        this.#executionContextId = executionContextId;
        this.#logger = logger;
        this.#origin = origin;
        this.#realmId = realmId;
        this.#realmStorage = realmStorage;
        this.#realmStorage.addRealm(this);
    }
    cdpToBidiValue(cdpValue, resultOwnership) {
        const bidiValue = this.serializeForBiDi(cdpValue.result.deepSerializedValue, new Map());
        if (cdpValue.result.objectId) {
            const objectId = cdpValue.result.objectId;
            if (resultOwnership === "root" /* Script.ResultOwnership.Root */) {
                // Extend BiDi value with `handle` based on required `resultOwnership`
                // and  CDP response but not on the actual BiDi type.
                bidiValue.handle = objectId;
                // Remember all the handles sent to client.
                this.#realmStorage.knownHandlesToRealmMap.set(objectId, this.realmId);
            }
            else {
                // No need to await for the object to be released.
                void this.#releaseObject(objectId).catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
            }
        }
        return bidiValue;
    }
    /**
     * Relies on the CDP to implement proper BiDi serialization, except:
     * * CDP integer property `backendNodeId` is replaced with `sharedId` of
     * `{documentId}_element_{backendNodeId}`;
     * * CDP integer property `weakLocalObjectReference` is replaced with UUID `internalId`
     * using unique-per serialization `internalIdMap`.
     * * CDP type `platformobject` is replaced with `object`.
     * @param deepSerializedValue - CDP value to be converted to BiDi.
     * @param internalIdMap - Map from CDP integer `weakLocalObjectReference` to BiDi UUID
     * `internalId`.
     */
    serializeForBiDi(deepSerializedValue, internalIdMap) {
        if (Object.hasOwn(deepSerializedValue, 'weakLocalObjectReference')) {
            const weakLocalObjectReference = deepSerializedValue.weakLocalObjectReference;
            if (!internalIdMap.has(weakLocalObjectReference)) {
                internalIdMap.set(weakLocalObjectReference, (0, uuid_js_1.uuidv4)());
            }
            deepSerializedValue.internalId = internalIdMap.get(weakLocalObjectReference);
            delete deepSerializedValue['weakLocalObjectReference'];
        }
        // Platform object is a special case. It should have only `{type: object}`
        // without `value` field.
        if (deepSerializedValue.type === 'platformobject') {
            return { type: 'object' };
        }
        const bidiValue = deepSerializedValue.value;
        if (bidiValue === undefined) {
            return deepSerializedValue;
        }
        // Recursively update the nested values.
        if (['array', 'set', 'htmlcollection', 'nodelist'].includes(deepSerializedValue.type)) {
            for (const i in bidiValue) {
                bidiValue[i] = this.serializeForBiDi(bidiValue[i], internalIdMap);
            }
        }
        if (['object', 'map'].includes(deepSerializedValue.type)) {
            for (const i in bidiValue) {
                bidiValue[i] = [
                    this.serializeForBiDi(bidiValue[i][0], internalIdMap),
                    this.serializeForBiDi(bidiValue[i][1], internalIdMap),
                ];
            }
        }
        return deepSerializedValue;
    }
    get realmId() {
        return this.#realmId;
    }
    get executionContextId() {
        return this.#executionContextId;
    }
    get origin() {
        return this.#origin;
    }
    get source() {
        return {
            realm: this.realmId,
        };
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    get baseInfo() {
        return {
            realm: this.realmId,
            origin: this.origin,
        };
    }
    async evaluate(expression, awaitPromise, resultOwnership = "none" /* Script.ResultOwnership.None */, serializationOptions = {}, userActivation = false, includeCommandLineApi = false) {
        const cdpEvaluateResult = await this.cdpClient.sendCommand('Runtime.evaluate', {
            contextId: this.executionContextId,
            expression,
            awaitPromise,
            serializationOptions: Realm.#getSerializationOptions("deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */, serializationOptions),
            userGesture: userActivation,
            includeCommandLineAPI: includeCommandLineApi,
        });
        if (cdpEvaluateResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpEvaluateResult.exceptionDetails, 0, resultOwnership);
        }
        return {
            realm: this.realmId,
            result: this.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
            type: 'success',
        };
    }
    #registerEvent(event) {
        if (this.associatedBrowsingContexts.length === 0) {
            this.#eventManager.registerEvent(event, null);
        }
        else {
            for (const browsingContext of this.associatedBrowsingContexts) {
                this.#eventManager.registerEvent(event, browsingContext.id);
            }
        }
    }
    initialize() {
        this.#registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
            params: this.realmInfo,
        });
    }
    /**
     * Serializes a given CDP object into BiDi, keeping references in the
     * target's `globalThis`.
     */
    async serializeCdpObject(cdpRemoteObject, resultOwnership) {
        const argument = Realm.#cdpRemoteObjectToCallArgument(cdpRemoteObject);
        const cdpValue = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((remoteObject) => remoteObject),
            awaitPromise: false,
            arguments: [argument],
            serializationOptions: {
                serialization: "deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */,
            },
            executionContextId: this.executionContextId,
        });
        return this.cdpToBidiValue(cdpValue, resultOwnership);
    }
    static #cdpRemoteObjectToCallArgument(cdpRemoteObject) {
        if (cdpRemoteObject.objectId !== undefined) {
            return { objectId: cdpRemoteObject.objectId };
        }
        if (cdpRemoteObject.unserializableValue !== undefined) {
            return { unserializableValue: cdpRemoteObject.unserializableValue };
        }
        return { value: cdpRemoteObject.value };
    }
    /**
     * Gets the string representation of an object. This is equivalent to
     * calling `toString()` on the object value.
     */
    async stringifyObject(cdpRemoteObject) {
        const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((remoteObject) => String(remoteObject)),
            awaitPromise: false,
            arguments: [cdpRemoteObject],
            returnByValue: true,
            executionContextId: this.executionContextId,
        });
        return result.value;
    }
    async #flattenKeyValuePairs(mappingLocalValue) {
        const keyValueArray = await Promise.all(mappingLocalValue.map(async ([key, value]) => {
            let keyArg;
            if (typeof key === 'string') {
                // Key is a string.
                keyArg = { value: key };
            }
            else {
                // Key is a serialized value.
                keyArg = await this.deserializeForCdp(key);
            }
            const valueArg = await this.deserializeForCdp(value);
            return [keyArg, valueArg];
        }));
        return keyValueArray.flat();
    }
    async #flattenValueList(listLocalValue) {
        return await Promise.all(listLocalValue.map((localValue) => this.deserializeForCdp(localValue)));
    }
    async #serializeCdpExceptionDetails(cdpExceptionDetails, lineOffset, resultOwnership) {
        const callFrames = cdpExceptionDetails.stackTrace?.callFrames.map((frame) => ({
            url: frame.url,
            functionName: frame.functionName,
            lineNumber: frame.lineNumber - lineOffset,
            columnNumber: frame.columnNumber,
        })) ?? [];
        // Exception should always be there.
        const exception = cdpExceptionDetails.exception;
        return {
            exception: await this.serializeCdpObject(exception, resultOwnership),
            columnNumber: cdpExceptionDetails.columnNumber,
            lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
            stackTrace: {
                callFrames,
            },
            text: (await this.stringifyObject(exception)) || cdpExceptionDetails.text,
        };
    }
    async callFunction(functionDeclaration, awaitPromise, thisLocalValue = {
        type: 'undefined',
    }, argumentsLocalValues = [], resultOwnership = "none" /* Script.ResultOwnership.None */, serializationOptions = {}, userActivation = false) {
        const callFunctionAndSerializeScript = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${functionDeclaration}
      ), args);
    }`;
        const thisAndArgumentsList = [
            await this.deserializeForCdp(thisLocalValue),
            ...(await Promise.all(argumentsLocalValues.map(async (argumentLocalValue) => await this.deserializeForCdp(argumentLocalValue)))),
        ];
        let cdpCallFunctionResult;
        try {
            cdpCallFunctionResult = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                functionDeclaration: callFunctionAndSerializeScript,
                awaitPromise,
                arguments: thisAndArgumentsList,
                serializationOptions: Realm.#getSerializationOptions("deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */, serializationOptions),
                executionContextId: this.executionContextId,
                userGesture: userActivation,
            });
        }
        catch (error) {
            // Heuristic to determine if the problem is in the argument.
            // The check can be done on the `deserialization` step, but this approach
            // helps to save round-trips.
            if (error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                [
                    'Could not find object with given id',
                    'Argument should belong to the same JavaScript world as target object',
                    'Invalid remote object id',
                ].includes(error.message)) {
                throw new protocol_js_1.NoSuchHandleException('Handle was not found.');
            }
            throw error;
        }
        if (cdpCallFunctionResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpCallFunctionResult.exceptionDetails, 1, resultOwnership);
        }
        return {
            type: 'success',
            result: this.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
            realm: this.realmId,
        };
    }
    async deserializeForCdp(localValue) {
        if ('handle' in localValue && localValue.handle) {
            return { objectId: localValue.handle };
            // We tried to find a handle value but failed
            // This allows us to have exhaustive switch on `localValue.type`
        }
        else if ('handle' in localValue || 'sharedId' in localValue) {
            throw new protocol_js_1.NoSuchHandleException('Handle was not found.');
        }
        switch (localValue.type) {
            case 'undefined':
                return { unserializableValue: 'undefined' };
            case 'null':
                return { unserializableValue: 'null' };
            case 'string':
                return { value: localValue.value };
            case 'number':
                if (localValue.value === 'NaN') {
                    return { unserializableValue: 'NaN' };
                }
                else if (localValue.value === '-0') {
                    return { unserializableValue: '-0' };
                }
                else if (localValue.value === 'Infinity') {
                    return { unserializableValue: 'Infinity' };
                }
                else if (localValue.value === '-Infinity') {
                    return { unserializableValue: '-Infinity' };
                }
                return {
                    value: localValue.value,
                };
            case 'boolean':
                return { value: Boolean(localValue.value) };
            case 'bigint':
                return {
                    unserializableValue: `BigInt(${JSON.stringify(localValue.value)})`,
                };
            case 'date':
                return {
                    unserializableValue: `new Date(Date.parse(${JSON.stringify(localValue.value)}))`,
                };
            case 'regexp':
                return {
                    unserializableValue: `new RegExp(${JSON.stringify(localValue.value.pattern)}, ${JSON.stringify(localValue.value.flags)})`,
                };
            case 'map': {
                // TODO: If none of the nested keys and values has a remote
                // reference, serialize to `unserializableValue` without CDP roundtrip.
                const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => {
                        const result = new Map();
                        for (let i = 0; i < args.length; i += 2) {
                            result.set(args[i], args[i + 1]);
                        }
                        return result;
                    }),
                    awaitPromise: false,
                    arguments: keyValueArray,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'object': {
                // TODO: If none of the nested keys and values has a remote
                // reference, serialize to `unserializableValue` without CDP roundtrip.
                const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => {
                        const result = {};
                        for (let i = 0; i < args.length; i += 2) {
                            // Key should be either `string`, `number`, or `symbol`.
                            const key = args[i];
                            result[key] = args[i + 1];
                        }
                        return result;
                    }),
                    awaitPromise: false,
                    arguments: keyValueArray,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'array': {
                // TODO: If none of the nested items has a remote reference,
                // serialize to `unserializableValue` without CDP roundtrip.
                const args = await this.#flattenValueList(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => args),
                    awaitPromise: false,
                    arguments: args,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'set': {
                // TODO: if none of the nested items has a remote reference,
                // serialize to `unserializableValue` without CDP roundtrip.
                const args = await this.#flattenValueList(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => new Set(args)),
                    awaitPromise: false,
                    arguments: args,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'channel': {
                const channelProxy = new ChannelProxy_js_1.ChannelProxy(localValue.value, this.#logger);
                const channelProxySendMessageHandle = await channelProxy.init(this, this.#eventManager);
                return { objectId: channelProxySendMessageHandle };
            }
            // TODO(#375): Dispose of nested objects.
        }
        // Intentionally outside to handle unknown types
        throw new Error(`Value ${JSON.stringify(localValue)} is not deserializable.`);
    }
    async #getExceptionResult(exceptionDetails, lineOffset, resultOwnership) {
        return {
            exceptionDetails: await this.#serializeCdpExceptionDetails(exceptionDetails, lineOffset, resultOwnership),
            realm: this.realmId,
            type: 'exception',
        };
    }
    static #getSerializationOptions(serialization, serializationOptions) {
        return {
            serialization,
            additionalParameters: Realm.#getAdditionalSerializationParameters(serializationOptions),
            ...Realm.#getMaxObjectDepth(serializationOptions),
        };
    }
    static #getAdditionalSerializationParameters(serializationOptions) {
        const additionalParameters = {};
        if (serializationOptions.maxDomDepth !== undefined) {
            additionalParameters['maxNodeDepth'] =
                serializationOptions.maxDomDepth === null
                    ? 1000
                    : serializationOptions.maxDomDepth;
        }
        if (serializationOptions.includeShadowTree !== undefined) {
            additionalParameters['includeShadowTree'] =
                serializationOptions.includeShadowTree;
        }
        return additionalParameters;
    }
    static #getMaxObjectDepth(serializationOptions) {
        return serializationOptions.maxObjectDepth === undefined ||
            serializationOptions.maxObjectDepth === null
            ? {}
            : { maxDepth: serializationOptions.maxObjectDepth };
    }
    async #releaseObject(handle) {
        try {
            await this.cdpClient.sendCommand('Runtime.releaseObject', {
                objectId: handle,
            });
        }
        catch (error) {
            // Heuristic to determine if the problem is in the unknown handler.
            // Ignore the error if so.
            if (!(error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                error.message === 'Invalid remote object id')) {
                throw error;
            }
        }
    }
    async disown(handle) {
        // Disowning an object from different realm does nothing.
        if (this.#realmStorage.knownHandlesToRealmMap.get(handle) !== this.realmId) {
            return;
        }
        await this.#releaseObject(handle);
        this.#realmStorage.knownHandlesToRealmMap.delete(handle);
    }
    dispose() {
        this.#registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmDestroyed,
            params: {
                realm: this.realmId,
            },
        });
    }
}
exports.Realm = Realm;
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RealmStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const WindowRealm_js_1 = __webpack_require__(/*! ./WindowRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js");
/** Container class for browsing realms. */
class RealmStorage {
    /** Tracks handles and their realms sent to the client. */
    #knownHandlesToRealmMap = new Map();
    /** Map from realm ID to Realm. */
    #realmMap = new Map();
    get knownHandlesToRealmMap() {
        return this.#knownHandlesToRealmMap;
    }
    addRealm(realm) {
        this.#realmMap.set(realm.realmId, realm);
    }
    /** Finds all realms that match the given filter. */
    findRealms(filter) {
        return Array.from(this.#realmMap.values()).filter((realm) => {
            if (filter.realmId !== undefined && filter.realmId !== realm.realmId) {
                return false;
            }
            if (filter.browsingContextId !== undefined &&
                !realm.associatedBrowsingContexts
                    .map((browsingContext) => browsingContext.id)
                    .includes(filter.browsingContextId)) {
                return false;
            }
            if (filter.sandbox !== undefined &&
                (!(realm instanceof WindowRealm_js_1.WindowRealm) || filter.sandbox !== realm.sandbox)) {
                return false;
            }
            if (filter.executionContextId !== undefined &&
                filter.executionContextId !== realm.executionContextId) {
                return false;
            }
            if (filter.origin !== undefined && filter.origin !== realm.origin) {
                return false;
            }
            if (filter.type !== undefined && filter.type !== realm.realmType) {
                return false;
            }
            if (filter.cdpSessionId !== undefined &&
                filter.cdpSessionId !== realm.cdpClient.sessionId) {
                return false;
            }
            return true;
        });
    }
    findRealm(filter) {
        const maybeRealms = this.findRealms(filter);
        if (maybeRealms.length !== 1) {
            return undefined;
        }
        return maybeRealms[0];
    }
    /** Gets the only realm that matches the given filter, if any, otherwise throws. */
    getRealm(filter) {
        const maybeRealm = this.findRealm(filter);
        if (maybeRealm === undefined) {
            throw new protocol_js_1.NoSuchFrameException(`Realm ${JSON.stringify(filter)} not found`);
        }
        return maybeRealm;
    }
    /** Deletes all realms that match the given filter. */
    deleteRealms(filter) {
        this.findRealms(filter).map((realm) => {
            realm.dispose();
            this.#realmMap.delete(realm.realmId);
            Array.from(this.knownHandlesToRealmMap.entries())
                .filter(([, r]) => r === realm.realmId)
                .map(([handle]) => this.knownHandlesToRealmMap.delete(handle));
        });
    }
}
exports.RealmStorage = RealmStorage;
//# sourceMappingURL=RealmStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const PreloadScript_js_1 = __webpack_require__(/*! ./PreloadScript.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js");
class ScriptProcessor {
    #eventManager;
    #browsingContextStorage;
    #realmStorage;
    #preloadScriptStorage;
    #logger;
    constructor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#logger = logger;
        this.#eventManager = eventManager;
        this.#eventManager.addSubscribeHook(protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated, this.#onRealmCreatedSubscribeHook.bind(this));
    }
    #onRealmCreatedSubscribeHook(contextId) {
        const context = this.#browsingContextStorage.getContext(contextId);
        const contextsToReport = [
            context,
            ...this.#browsingContextStorage.getContext(contextId).allChildren,
        ];
        const realms = new Set();
        for (const reportContext of contextsToReport) {
            const realmsForContext = this.#realmStorage.findRealms({
                browsingContextId: reportContext.id,
            });
            for (const realm of realmsForContext) {
                realms.add(realm);
            }
        }
        for (const realm of realms) {
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
                params: realm.realmInfo,
            }, context.id);
        }
        return Promise.resolve();
    }
    async addPreloadScript(params) {
        const contexts = this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const preloadScript = new PreloadScript_js_1.PreloadScript(params, this.#logger);
        this.#preloadScriptStorage.add(preloadScript);
        const cdpTargets = contexts.size === 0
            ? new Set(this.#browsingContextStorage
                .getTopLevelContexts()
                .map((context) => context.cdpTarget))
            : new Set([...contexts.values()].map((context) => context.cdpTarget));
        await preloadScript.initInTargets(cdpTargets, false);
        return {
            script: preloadScript.id,
        };
    }
    async removePreloadScript(params) {
        const { script: id } = params;
        const scripts = this.#preloadScriptStorage.find({ id });
        if (scripts.length === 0) {
            throw new protocol_js_1.NoSuchScriptException(`No preload script with id '${id}'`);
        }
        await Promise.all(scripts.map((script) => script.remove()));
        this.#preloadScriptStorage.remove({ id });
        return {};
    }
    async callFunction(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.callFunction(params.functionDeclaration, params.awaitPromise, params.this, params.arguments, params.resultOwnership, params.serializationOptions, params.userActivation);
    }
    async evaluate(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.evaluate(params.expression, params.awaitPromise, params.resultOwnership, params.serializationOptions, params.userActivation);
    }
    async disown(params) {
        const realm = await this.#getRealm(params.target);
        await Promise.all(params.handles.map(async (handle) => await realm.disown(handle)));
        return {};
    }
    getRealms(params) {
        if (params.context !== undefined) {
            // Make sure the context is known.
            this.#browsingContextStorage.getContext(params.context);
        }
        const realms = this.#realmStorage
            .findRealms({
            browsingContextId: params.context,
            type: params.type,
        })
            .map((realm) => realm.realmInfo);
        return { realms };
    }
    async #getRealm(target) {
        if ('context' in target) {
            const context = this.#browsingContextStorage.getContext(target.context);
            return await context.getOrCreateSandbox(target.sandbox);
        }
        return this.#realmStorage.getRealm({
            realmId: target.realm,
        });
    }
}
exports.ScriptProcessor = ScriptProcessor;
//# sourceMappingURL=ScriptProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSharedId = getSharedId;
exports.parseSharedId = parseSharedId;
const SHARED_ID_DIVIDER = '_element_';
function getSharedId(frameId, documentId, backendNodeId) {
    return `f.${frameId}.d.${documentId}.e.${backendNodeId}`;
}
function parseLegacySharedId(sharedId) {
    const match = sharedId.match(new RegExp(`(.*)${SHARED_ID_DIVIDER}(.*)`));
    if (!match) {
        // SharedId is incorrectly formatted.
        return null;
    }
    const documentId = match[1];
    const elementId = match[2];
    if (documentId === undefined || elementId === undefined) {
        return null;
    }
    const backendNodeId = parseInt(elementId ?? '');
    if (isNaN(backendNodeId)) {
        return null;
    }
    return {
        documentId,
        backendNodeId,
    };
}
function parseSharedId(sharedId) {
    // TODO: remove legacy check once ChromeDriver provides sharedId in the new format.
    const legacyFormattedSharedId = parseLegacySharedId(sharedId);
    if (legacyFormattedSharedId !== null) {
        return { ...legacyFormattedSharedId, frameId: undefined };
    }
    const match = sharedId.match(/f\.(.*)\.d\.(.*)\.e\.([0-9]*)/);
    if (!match) {
        // SharedId is incorrectly formatted.
        return null;
    }
    const frameId = match[1];
    const documentId = match[2];
    const elementId = match[3];
    if (frameId === undefined ||
        documentId === undefined ||
        elementId === undefined) {
        return null;
    }
    const backendNodeId = parseInt(elementId ?? '');
    if (isNaN(backendNodeId)) {
        return null;
    }
    return {
        frameId,
        documentId,
        backendNodeId,
    };
}
//# sourceMappingURL=SharedId.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowRealm = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Realm_js_1 = __webpack_require__(/*! ./Realm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js");
const SharedId_js_1 = __webpack_require__(/*! ./SharedId.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js");
class WindowRealm extends Realm_js_1.Realm {
    #browsingContextId;
    #browsingContextStorage;
    sandbox;
    constructor(browsingContextId, browsingContextStorage, cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage, sandbox) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#browsingContextId = browsingContextId;
        this.#browsingContextStorage = browsingContextStorage;
        this.sandbox = sandbox;
        this.initialize();
    }
    #getBrowsingContextId(navigableId) {
        const maybeBrowsingContext = this.#browsingContextStorage
            .getAllContexts()
            .find((context) => context.navigableId === navigableId);
        return maybeBrowsingContext?.id ?? 'UNKNOWN';
    }
    get browsingContext() {
        return this.#browsingContextStorage.getContext(this.#browsingContextId);
    }
    get associatedBrowsingContexts() {
        return [this.browsingContext];
    }
    get realmType() {
        return 'window';
    }
    get realmInfo() {
        return {
            ...this.baseInfo,
            type: this.realmType,
            context: this.#browsingContextId,
            sandbox: this.sandbox,
        };
    }
    get source() {
        return {
            realm: this.realmId,
            context: this.browsingContext.id,
        };
    }
    serializeForBiDi(deepSerializedValue, internalIdMap) {
        const bidiValue = deepSerializedValue.value;
        if (deepSerializedValue.type === 'node' && bidiValue !== undefined) {
            if (Object.hasOwn(bidiValue, 'backendNodeId')) {
                let navigableId = this.browsingContext.navigableId ?? 'UNKNOWN';
                if (Object.hasOwn(bidiValue, 'loaderId')) {
                    // `loaderId` should be always there after ~2024-03-05, when
                    // https://crrev.com/c/5116240 reaches stable.
                    // TODO: remove the check after the date.
                    navigableId = bidiValue.loaderId;
                    delete bidiValue['loaderId'];
                }
                deepSerializedValue.sharedId =
                    (0, SharedId_js_1.getSharedId)(this.#getBrowsingContextId(navigableId), navigableId, bidiValue.backendNodeId);
                delete bidiValue['backendNodeId'];
            }
            if (Object.hasOwn(bidiValue, 'children')) {
                for (const i in bidiValue.children) {
                    bidiValue.children[i] = this.serializeForBiDi(bidiValue.children[i], internalIdMap);
                }
            }
            if (Object.hasOwn(bidiValue, 'shadowRoot') &&
                bidiValue.shadowRoot !== null) {
                bidiValue.shadowRoot = this.serializeForBiDi(bidiValue.shadowRoot, internalIdMap);
            }
            // `namespaceURI` can be is either `null` or non-empty string.
            if (bidiValue.namespaceURI === '') {
                bidiValue.namespaceURI = null;
            }
        }
        return super.serializeForBiDi(deepSerializedValue, internalIdMap);
    }
    async deserializeForCdp(localValue) {
        if ('sharedId' in localValue && localValue.sharedId) {
            const parsedSharedId = (0, SharedId_js_1.parseSharedId)(localValue.sharedId);
            if (parsedSharedId === null) {
                throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
            }
            const { documentId, backendNodeId } = parsedSharedId;
            // TODO: add proper validation if the element is accessible from the current realm.
            if (this.browsingContext.navigableId !== documentId) {
                throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" belongs to different document. Current document is ${this.browsingContext.navigableId}.`);
            }
            try {
                const { object } = await this.cdpClient.sendCommand('DOM.resolveNode', {
                    backendNodeId,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `obj.object.objectId` after using.
                return { objectId: object.objectId };
            }
            catch (error) {
                // Heuristic to detect "no such node" exception. Based on the  specific
                // CDP implementation.
                if (error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                    error.message === 'No node with given id found') {
                    throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
                }
                throw new protocol_js_1.UnknownErrorException(error.message, error.stack);
            }
        }
        return await super.deserializeForCdp(localValue);
    }
    async evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi) {
        await this.#browsingContextStorage
            .getContext(this.#browsingContextId)
            .targetUnblockedOrThrow();
        return await super.evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi);
    }
    async callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation) {
        await this.#browsingContextStorage
            .getContext(this.#browsingContextId)
            .targetUnblockedOrThrow();
        return await super.callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation);
    }
}
exports.WindowRealm = WindowRealm;
//# sourceMappingURL=WindowRealm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerRealm = void 0;
const Realm_js_1 = __webpack_require__(/*! ./Realm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js");
class WorkerRealm extends Realm_js_1.Realm {
    #realmType;
    #ownerRealms;
    constructor(cdpClient, eventManager, executionContextId, logger, origin, ownerRealms, realmId, realmStorage, realmType) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#ownerRealms = ownerRealms;
        this.#realmType = realmType;
        this.initialize();
    }
    get associatedBrowsingContexts() {
        return this.#ownerRealms.flatMap((realm) => realm.associatedBrowsingContexts);
    }
    get realmType() {
        return this.#realmType;
    }
    get source() {
        return {
            realm: this.realmId,
            // This is a hack to make Puppeteer able to track workers.
            // TODO: remove after Puppeteer tracks workers by owners and use the base version.
            context: this.associatedBrowsingContexts[0]?.id,
        };
    }
    get realmInfo() {
        const owners = this.#ownerRealms.map((realm) => realm.realmId);
        const { realmType } = this;
        switch (realmType) {
            case 'dedicated-worker': {
                const owner = owners[0];
                if (owner === undefined || owners.length !== 1) {
                    throw new Error('Dedicated worker must have exactly one owner');
                }
                return {
                    ...this.baseInfo,
                    type: realmType,
                    owners: [owner],
                };
            }
            case 'service-worker':
            case 'shared-worker': {
                return {
                    ...this.baseInfo,
                    type: realmType,
                };
            }
        }
    }
}
exports.WorkerRealm = WorkerRealm;
//# sourceMappingURL=WorkerRealm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventManager = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Buffer_js_1 = __webpack_require__(/*! ../../../utils/Buffer.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js");
const DefaultMap_js_1 = __webpack_require__(/*! ../../../utils/DefaultMap.js */ "./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js");
const DistinctValues_js_1 = __webpack_require__(/*! ../../../utils/DistinctValues.js */ "./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js");
const EventEmitter_js_1 = __webpack_require__(/*! ../../../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const IdWrapper_js_1 = __webpack_require__(/*! ../../../utils/IdWrapper.js */ "./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js");
const OutgoingMessage_js_1 = __webpack_require__(/*! ../../OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
const events_js_1 = __webpack_require__(/*! ./events.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js");
const SubscriptionManager_js_1 = __webpack_require__(/*! ./SubscriptionManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js");
class EventWrapper {
    #idWrapper = new IdWrapper_js_1.IdWrapper();
    #contextId;
    #event;
    constructor(event, contextId) {
        this.#event = event;
        this.#contextId = contextId;
    }
    get id() {
        return this.#idWrapper.id;
    }
    get contextId() {
        return this.#contextId;
    }
    get event() {
        return this.#event;
    }
}
/**
 * Maps event name to a desired buffer length.
 */
const eventBufferLength = new Map([[protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
class EventManager extends EventEmitter_js_1.EventEmitter {
    /**
     * Maps event name to a set of contexts where this event already happened.
     * Needed for getting buffered events from all the contexts in case of
     * subscripting to all contexts.
     */
    #eventToContextsMap = new DefaultMap_js_1.DefaultMap(() => new Set());
    /**
     * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
     * during subscription. Channel-agnostic.
     */
    #eventBuffers = new Map();
    /**
     * Maps `eventName` + `browsingContext` + `channel` to last sent event id.
     * Used to avoid sending duplicated events when user
     * subscribes -> unsubscribes -> subscribes.
     */
    #lastMessageSent = new Map();
    #subscriptionManager;
    #browsingContextStorage;
    /**
     * Map of event name to hooks to be called when client is subscribed to the event.
     */
    #subscribeHooks;
    constructor(browsingContextStorage) {
        super();
        this.#browsingContextStorage = browsingContextStorage;
        this.#subscriptionManager = new SubscriptionManager_js_1.SubscriptionManager(browsingContextStorage);
        this.#subscribeHooks = new DefaultMap_js_1.DefaultMap(() => []);
    }
    get subscriptionManager() {
        return this.#subscriptionManager;
    }
    /**
     * Returns consistent key to be used to access value maps.
     */
    static #getMapKey(eventName, browsingContext, channel) {
        return JSON.stringify({ eventName, browsingContext, channel });
    }
    addSubscribeHook(event, hook) {
        this.#subscribeHooks.get(event).push(hook);
    }
    registerEvent(event, contextId) {
        this.registerPromiseEvent(Promise.resolve({
            kind: 'success',
            value: event,
        }), contextId, event.method);
    }
    registerPromiseEvent(event, contextId, eventName) {
        const eventWrapper = new EventWrapper(event, contextId);
        const sortedChannels = this.#subscriptionManager.getChannelsSubscribedToEvent(eventName, contextId);
        this.#bufferEvent(eventWrapper, eventName);
        // Send events to channels in the subscription priority.
        for (const channel of sortedChannels) {
            this.emit("event" /* EventManagerEvents.Event */, {
                message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
                event: eventName,
            });
            this.#markEventSent(eventWrapper, channel, eventName);
        }
    }
    async subscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name);
        }
        // First check if all the contexts are known.
        for (const contextId of contextIds) {
            if (contextId !== null) {
                // Assert the context is known. Throw exception otherwise.
                this.#browsingContextStorage.getContext(contextId);
            }
        }
        // List of the subscription items that were actually added. Each contains a specific
        // event and context. No domain event (like "network") or global context subscription
        // (like null) are included.
        const addedSubscriptionItems = [];
        for (const eventName of eventNames) {
            for (const contextId of contextIds) {
                addedSubscriptionItems.push(...this.#subscriptionManager.subscribe(eventName, contextId, channel));
                for (const eventWrapper of this.#getBufferedEvents(eventName, contextId, channel)) {
                    // The order of the events is important.
                    this.emit("event" /* EventManagerEvents.Event */, {
                        message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(eventWrapper.event, channel),
                        event: eventName,
                    });
                    this.#markEventSent(eventWrapper, channel, eventName);
                }
            }
        }
        // Iterate over all new subscription items and call hooks if any. There can be
        // duplicates, e.g. when subscribing to the whole domain and some specific event in
        // the same time ("network", "network.responseCompleted"). `distinctValues` guarantees
        // that hooks are called only once per pair event + context.
        (0, DistinctValues_js_1.distinctValues)(addedSubscriptionItems).forEach(({ contextId, event }) => {
            this.#subscribeHooks.get(event).forEach((hook) => hook(contextId));
        });
        await this.toggleModulesIfNeeded();
    }
    async unsubscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name);
        }
        this.#subscriptionManager.unsubscribeAll(eventNames, contextIds, channel);
        await this.toggleModulesIfNeeded();
    }
    async toggleModulesIfNeeded() {
        // TODO(1): Only update changed subscribers
        // TODO(2): Enable for Worker Targets
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            return await context.toggleModulesIfNeeded();
        }));
    }
    /**
     * If the event is buffer-able, put it in the buffer.
     */
    #bufferEvent(eventWrapper, eventName) {
        if (!eventBufferLength.has(eventName)) {
            // Do nothing if the event is no buffer-able.
            return;
        }
        const bufferMapKey = EventManager.#getMapKey(eventName, eventWrapper.contextId);
        if (!this.#eventBuffers.has(bufferMapKey)) {
            this.#eventBuffers.set(bufferMapKey, new Buffer_js_1.Buffer(eventBufferLength.get(eventName)));
        }
        this.#eventBuffers.get(bufferMapKey).add(eventWrapper);
        // Add the context to the list of contexts having `eventName` events.
        this.#eventToContextsMap.get(eventName).add(eventWrapper.contextId);
    }
    /**
     * If the event is buffer-able, mark it as sent to the given contextId and channel.
     */
    #markEventSent(eventWrapper, channel, eventName) {
        if (!eventBufferLength.has(eventName)) {
            // Do nothing if the event is no buffer-able.
            return;
        }
        const lastSentMapKey = EventManager.#getMapKey(eventName, eventWrapper.contextId, channel);
        this.#lastMessageSent.set(lastSentMapKey, Math.max(this.#lastMessageSent.get(lastSentMapKey) ?? 0, eventWrapper.id));
    }
    /**
     * Returns events which are buffered and not yet sent to the given channel events.
     */
    #getBufferedEvents(eventName, contextId, channel) {
        const bufferMapKey = EventManager.#getMapKey(eventName, contextId);
        const lastSentMapKey = EventManager.#getMapKey(eventName, contextId, channel);
        const lastSentMessageId = this.#lastMessageSent.get(lastSentMapKey) ?? -Infinity;
        const result = this.#eventBuffers
            .get(bufferMapKey)
            ?.get()
            .filter((wrapper) => wrapper.id > lastSentMessageId) ?? [];
        if (contextId === null) {
            // For global subscriptions, events buffered in each context should be sent back.
            Array.from(this.#eventToContextsMap.get(eventName).keys())
                .filter((_contextId) => 
            // Events without context are already in the result.
            _contextId !== null &&
                // Events from deleted contexts should not be sent.
                this.#browsingContextStorage.hasContext(_contextId))
                .map((_contextId) => this.#getBufferedEvents(eventName, _contextId, channel))
                .forEach((events) => result.push(...events));
        }
        return result.sort((e1, e2) => e1.id - e2.id);
    }
}
exports.EventManager = EventManager;
//# sourceMappingURL=EventManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class SessionProcessor {
    #eventManager;
    #browserCdpClient;
    #initConnection;
    #created = false;
    constructor(eventManager, browserCdpClient, initConnection) {
        this.#eventManager = eventManager;
        this.#browserCdpClient = browserCdpClient;
        this.#initConnection = initConnection;
    }
    status() {
        return { ready: false, message: 'already connected' };
    }
    #mergeCapabilities(capabilitiesRequest) {
        // Roughly following https://www.w3.org/TR/webdriver2/#dfn-capabilities-processing.
        // Validations should already be done by the parser.
        const mergedCapabilities = [];
        for (const first of capabilitiesRequest.firstMatch ?? [{}]) {
            const result = {
                ...capabilitiesRequest.alwaysMatch,
            };
            for (const key of Object.keys(first)) {
                if (result[key] !== undefined) {
                    throw new protocol_js_1.InvalidArgumentException(`Capability ${key} in firstMatch is already defined in alwaysMatch`);
                }
                result[key] = first[key];
            }
            mergedCapabilities.push(result);
        }
        const match = mergedCapabilities.find((c) => c.browserName === 'chrome') ??
            mergedCapabilities[0] ??
            {};
        match.unhandledPromptBehavior = this.#getUnhandledPromptBehavior(match.unhandledPromptBehavior);
        return match;
    }
    #getUnhandledPromptBehavior(capabilityValue) {
        if (capabilityValue === undefined) {
            return undefined;
        }
        if (typeof capabilityValue === 'object') {
            // Do not validate capabilities. Incorrect ones will be ignored by Mapper.
            return capabilityValue;
        }
        if (typeof capabilityValue !== 'string') {
            throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' type: ${typeof capabilityValue}`);
        }
        switch (capabilityValue) {
            case 'accept':
            case 'accept and notify':
                return { default: "accept" /* Session.UserPromptHandlerType.Accept */ };
            case 'dismiss':
            case 'dismiss and notify':
                return { default: "dismiss" /* Session.UserPromptHandlerType.Dismiss */ };
            case 'ignore':
                return { default: "ignore" /* Session.UserPromptHandlerType.Ignore */ };
            default:
                throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' value: ${capabilityValue}`);
        }
    }
    async new(params) {
        if (this.#created) {
            throw new Error('Session has been already created.');
        }
        this.#created = true;
        const matchedCapabitlites = this.#mergeCapabilities(params.capabilities);
        await this.#initConnection(matchedCapabitlites);
        const version = await this.#browserCdpClient.sendCommand('Browser.getVersion');
        return {
            sessionId: 'unknown',
            capabilities: {
                ...matchedCapabitlites,
                acceptInsecureCerts: matchedCapabitlites.acceptInsecureCerts ?? false,
                browserName: version.product,
                browserVersion: version.revision,
                platformName: '',
                setWindowRect: false,
                webSocketUrl: '',
                userAgent: version.userAgent,
            },
        };
    }
    async subscribe(params, channel = null) {
        await this.#eventManager.subscribe(params.events, params.contexts ?? [null], channel);
        return {};
    }
    async unsubscribe(params, channel = null) {
        await this.#eventManager.unsubscribe(params.events, params.contexts ?? [null], channel);
        return {};
    }
}
exports.SessionProcessor = SessionProcessor;
//# sourceMappingURL=SessionProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubscriptionManager = void 0;
exports.cartesianProduct = cartesianProduct;
exports.unrollEvents = unrollEvents;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const events_js_1 = __webpack_require__(/*! ./events.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js");
/**
 * Returns the cartesian product of the given arrays.
 *
 * Example:
 *   cartesian([1, 2], ['a', 'b']); => [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 */
function cartesianProduct(...a) {
    return a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));
}
/** Expands "AllEvents" events into atomic events. */
function unrollEvents(events) {
    const allEvents = new Set();
    function addEvents(events) {
        for (const event of events) {
            allEvents.add(event);
        }
    }
    for (const event of events) {
        switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Log.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Network.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Script.EventNames));
                break;
            default:
                allEvents.add(event);
        }
    }
    return [...allEvents.values()];
}
class SubscriptionManager {
    #subscriptionPriority = 0;
    // BrowsingContext `null` means the event has subscription across all the
    // browsing contexts.
    // Channel `null` means no `channel` should be added.
    #channelToContextToEventMap = new Map();
    #browsingContextStorage;
    constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
    }
    getChannelsSubscribedToEvent(eventMethod, contextId) {
        const prioritiesAndChannels = Array.from(this.#channelToContextToEventMap.keys())
            .map((channel) => ({
            priority: this.#getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel),
            channel,
        }))
            .filter(({ priority }) => priority !== null);
        // Sort channels by priority.
        return prioritiesAndChannels
            .sort((a, b) => a.priority - b.priority)
            .map(({ channel }) => channel);
    }
    #getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel) {
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (contextToEventMap === undefined) {
            return null;
        }
        const maybeTopLevelContextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        // `null` covers global subscription.
        const relevantContexts = [...new Set([null, maybeTopLevelContextId])];
        // Get all the subscription priorities.
        const priorities = relevantContexts
            .map((context) => {
            // Get the priority for exact event name
            const priority = contextToEventMap.get(context)?.get(eventMethod);
            // For CDP we can't provide specific event name when subscribing
            // to the module directly.
            // Because of that we need to see event `cdp` exits in the map.
            if ((0, events_js_1.isCdpEvent)(eventMethod)) {
                const cdpPriority = contextToEventMap
                    .get(context)
                    ?.get(protocol_js_1.ChromiumBidi.BiDiModule.Cdp);
                // If we subscribe to the event directly and `cdp` module as well
                // priority will be different we take minimal priority
                return priority && cdpPriority
                    ? Math.min(priority, cdpPriority)
                    : // At this point we know that we have subscribed
                        // to only one of the two
                        (priority ?? cdpPriority);
            }
            return priority;
        })
            .filter((p) => p !== undefined);
        if (priorities.length === 0) {
            // Not subscribed, return null.
            return null;
        }
        // Return minimal priority.
        return Math.min(...priorities);
    }
    /**
     * @param module BiDi+ module
     * @param contextId `null` == globally subscribed
     *
     * @returns
     */
    isSubscribedTo(moduleOrEvent, contextId = null) {
        const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
        for (const browserContextToEventMap of this.#channelToContextToEventMap.values()) {
            for (const [id, eventMap] of browserContextToEventMap.entries()) {
                // Not subscribed to this context or globally
                if (topLevelContext !== id && id !== null) {
                    continue;
                }
                for (const event of eventMap.keys()) {
                    // This also covers the `cdp` case where
                    // we don't unroll the event names
                    if (
                    // Event explicitly subscribed
                    event === moduleOrEvent ||
                        // Event subscribed via module
                        event === moduleOrEvent.split('.').at(0) ||
                        // Event explicitly subscribed compared to module
                        event.split('.').at(0) === moduleOrEvent) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Subscribes to event in the given context and channel.
     * @param {EventNames} event
     * @param {BrowsingContext.BrowsingContext | null} contextId
     * @param {BidiPlusChannel} channel
     * @return {SubscriptionItem[]} List of
     * subscriptions. If the event is a whole module, it will return all the specific
     * events. If the contextId is null, it will return all the top-level contexts which were
     * not subscribed before the command.
     */
    subscribe(event, contextId, channel) {
        // All the subscriptions are handled on the top-level contexts.
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        // Check if subscribed event is a whole module
        switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
                return Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
                return Object.values(protocol_js_1.ChromiumBidi.Log.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
                return Object.values(protocol_js_1.ChromiumBidi.Network.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
                return Object.values(protocol_js_1.ChromiumBidi.Script.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            default:
            // Intentionally left empty.
        }
        if (!this.#channelToContextToEventMap.has(channel)) {
            this.#channelToContextToEventMap.set(channel, new Map());
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
            contextToEventMap.set(contextId, new Map());
        }
        const eventMap = contextToEventMap.get(contextId);
        const affectedContextIds = (contextId === null
            ? this.#browsingContextStorage.getTopLevelContexts().map((c) => c.id)
            : [contextId])
            // There can be contexts that are already subscribed to the event. Do not include
            // them to the output.
            .filter((contextId) => !this.isSubscribedTo(event, contextId));
        if (!eventMap.has(event)) {
            // Add subscription only if it's not already subscribed.
            eventMap.set(event, this.#subscriptionPriority++);
        }
        return affectedContextIds.map((contextId) => ({
            event,
            contextId,
        }));
    }
    /**
     * Unsubscribes atomically from all events in the given contexts and channel.
     */
    unsubscribeAll(events, contextIds, channel) {
        // Assert all contexts are known.
        for (const contextId of contextIds) {
            if (contextId !== null) {
                this.#browsingContextStorage.getContext(contextId);
            }
        }
        const eventContextPairs = cartesianProduct(unrollEvents(events), contextIds);
        // Assert all unsubscriptions are valid.
        // If any of the unsubscriptions are invalid, do not unsubscribe from anything.
        eventContextPairs
            .map(([event, contextId]) => this.#checkUnsubscribe(event, contextId, channel))
            .forEach((unsubscribe) => unsubscribe());
    }
    /**
     * Unsubscribes from the event in the given context and channel.
     * Syntactic sugar for "unsubscribeAll".
     */
    unsubscribe(eventName, contextId, channel) {
        this.unsubscribeAll([eventName], [contextId], channel);
    }
    #checkUnsubscribe(event, contextId, channel) {
        // All the subscriptions are handled on the top-level contexts.
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        if (!this.#channelToContextToEventMap.has(channel)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        const eventMap = contextToEventMap.get(contextId);
        if (!eventMap.has(event)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        return () => {
            eventMap.delete(event);
            // Clean up maps if empty.
            if (eventMap.size === 0) {
                contextToEventMap.delete(event);
            }
            if (contextToEventMap.size === 0) {
                this.#channelToContextToEventMap.delete(channel);
            }
        };
    }
}
exports.SubscriptionManager = SubscriptionManager;
//# sourceMappingURL=SubscriptionManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCdpEvent = isCdpEvent;
exports.assertSupportedEvent = assertSupportedEvent;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/**
 * Returns true if the given event is a CDP event.
 * @see https://chromedevtools.github.io/devtools-protocol/
 */
function isCdpEvent(name) {
    return (name.split('.').at(0)?.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.Cdp) ?? false);
}
/**
 * Asserts that the given event is known to BiDi or BiDi+, or throws otherwise.
 */
function assertSupportedEvent(name) {
    if (!protocol_js_1.ChromiumBidi.EVENT_NAMES.has(name) && !isCdpEvent(name)) {
        throw new protocol_js_1.InvalidArgumentException(`Unknown event: ${name}`);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const NetworkProcessor_js_1 = __webpack_require__(/*! ../network/NetworkProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ../network/NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
/**
 * Responsible for handling the `storage` domain.
 */
class StorageProcessor {
    #browserCdpClient;
    #browsingContextStorage;
    #logger;
    constructor(browserCdpClient, browsingContextStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#browserCdpClient = browserCdpClient;
        this.#logger = logger;
    }
    async deleteCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
            cdpResponse = await this.#browserCdpClient.sendCommand('Storage.getCookies', {
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        const cdpCookiesToDelete = cdpResponse.cookies
            .filter(
        // CDP's partition key is the source origin. If the request specifies the
        // `sourceOrigin` partition key, only cookies with the requested source origin
        // are returned.
        (c) => partitionKey.sourceOrigin === undefined ||
            c.partitionKey?.topLevelSite === partitionKey.sourceOrigin)
            .filter((cdpCookie) => {
            const bidiCookie = (0, NetworkUtils_js_1.cdpToBiDiCookie)(cdpCookie);
            return this.#matchCookie(bidiCookie, params.filter);
        })
            .map((cookie) => ({
            ...cookie,
            // Set expiry to pass date to delete the cookie.
            expires: 1,
        }));
        await this.#browserCdpClient.sendCommand('Storage.setCookies', {
            cookies: cdpCookiesToDelete,
            browserContextId: this.#getCdpBrowserContextId(partitionKey),
        });
        return {
            partitionKey,
        };
    }
    async getCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
            cdpResponse = await this.#browserCdpClient.sendCommand('Storage.getCookies', {
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        const filteredBiDiCookies = cdpResponse.cookies
            .filter(
        // CDP's partition key is the source origin. If the request specifies the
        // `sourceOrigin` partition key, only cookies with the requested source origin
        // are returned.
        (c) => partitionKey.sourceOrigin === undefined ||
            c.partitionKey?.topLevelSite === partitionKey.sourceOrigin)
            .map((c) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(c))
            .filter((c) => this.#matchCookie(c, params.filter));
        return {
            cookies: filteredBiDiCookies,
            partitionKey,
        };
    }
    async setCookie(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        const cdpCookie = (0, NetworkUtils_js_1.bidiToCdpCookie)(params, partitionKey);
        try {
            await this.#browserCdpClient.sendCommand('Storage.setCookies', {
                cookies: [cdpCookie],
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            this.#logger?.(log_js_1.LogType.debugError, err);
            throw new protocol_js_1.UnableToSetCookieException(err.toString());
        }
        return {
            partitionKey,
        };
    }
    #isNoSuchUserContextError(err) {
        // Heuristic to detect if the user context is not found.
        // See https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/browser_handler.cc;drc=a56154dd81e4679712422ac6eed2c9581cb51ab0;l=314
        return err.message?.startsWith('Failed to find browser context for id');
    }
    #getCdpBrowserContextId(partitionKey) {
        return partitionKey.userContext === 'default'
            ? undefined
            : partitionKey.userContext;
    }
    #expandStoragePartitionSpecByBrowsingContext(descriptor) {
        const browsingContextId = descriptor.context;
        const browsingContext = this.#browsingContextStorage.getContext(browsingContextId);
        // https://w3c.github.io/webdriver-bidi/#associated-storage-partition.
        // Each browsing context also has an associated storage partition, which is the
        // storage partition it uses to persist data. In Chromium it's a `BrowserContext`
        // which maps to BiDi `UserContext`.
        return {
            userContext: browsingContext.userContext,
        };
    }
    #expandStoragePartitionSpecByStorageKey(descriptor) {
        const unsupportedPartitionKeys = new Map();
        let sourceOrigin = descriptor.sourceOrigin;
        if (sourceOrigin !== undefined) {
            const url = NetworkProcessor_js_1.NetworkProcessor.parseUrlString(sourceOrigin);
            if (url.origin === 'null') {
                // Origin `null` is a special case for local pages.
                sourceOrigin = url.origin;
            }
            else {
                // Port is not supported in CDP Cookie's `partitionKey`, so it should be stripped
                // from the requested source origin.
                sourceOrigin = `${url.protocol}//${url.hostname}`;
            }
        }
        for (const [key, value] of Object.entries(descriptor)) {
            if (key !== undefined &&
                value !== undefined &&
                !['type', 'sourceOrigin', 'userContext'].includes(key)) {
                unsupportedPartitionKeys.set(key, value);
            }
        }
        if (unsupportedPartitionKeys.size > 0) {
            this.#logger?.(log_js_1.LogType.debugInfo, `Unsupported partition keys: ${JSON.stringify(Object.fromEntries(unsupportedPartitionKeys))}`);
        }
        // Set `userContext` to `default` if not provided, as it's required in Chromium.
        const userContext = descriptor.userContext ?? 'default';
        return {
            userContext,
            ...(sourceOrigin === undefined ? {} : { sourceOrigin }),
        };
    }
    #expandStoragePartitionSpec(partitionSpec) {
        if (partitionSpec === undefined) {
            // `userContext` is required in Chromium.
            return { userContext: 'default' };
        }
        if (partitionSpec.type === 'context') {
            return this.#expandStoragePartitionSpecByBrowsingContext(partitionSpec);
        }
        (0, assert_js_1.assert)(partitionSpec.type === 'storageKey', 'Unknown partition type');
        // Partition spec is a storage partition.
        // Let partition key be partition spec.
        return this.#expandStoragePartitionSpecByStorageKey(partitionSpec);
    }
    #matchCookie(cookie, filter) {
        if (filter === undefined) {
            return true;
        }
        return ((filter.domain === undefined || filter.domain === cookie.domain) &&
            (filter.name === undefined || filter.name === cookie.name) &&
            // `value` contains fields `type` and `value`.
            (filter.value === undefined ||
                (0, NetworkUtils_js_1.deserializeByteValue)(filter.value) ===
                    (0, NetworkUtils_js_1.deserializeByteValue)(cookie.value)) &&
            (filter.path === undefined || filter.path === cookie.path) &&
            (filter.size === undefined || filter.size === cookie.size) &&
            (filter.httpOnly === undefined || filter.httpOnly === cookie.httpOnly) &&
            (filter.secure === undefined || filter.secure === cookie.secure) &&
            (filter.sameSite === undefined || filter.sameSite === cookie.sameSite) &&
            (filter.expiry === undefined || filter.expiry === cookie.expiry));
    }
}
exports.StorageProcessor = StorageProcessor;
//# sourceMappingURL=StorageProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnderspecifiedStoragePartitionException = exports.UnableToSetFileInputException = exports.UnableToSetCookieException = exports.NoSuchStoragePartitionException = exports.UnsupportedOperationException = exports.UnableToCloseBrowserException = exports.UnableToCaptureScreenException = exports.UnknownErrorException = exports.UnknownCommandException = exports.SessionNotCreatedException = exports.NoSuchUserContextException = exports.NoSuchScriptException = exports.NoSuchRequestException = exports.NoSuchNodeException = exports.NoSuchInterceptException = exports.NoSuchHistoryEntryException = exports.NoSuchHandleException = exports.NoSuchFrameException = exports.NoSuchElementException = exports.NoSuchAlertException = exports.MoveTargetOutOfBoundsException = exports.InvalidSessionIdException = exports.InvalidSelectorException = exports.InvalidArgumentException = exports.Exception = void 0;
class Exception extends Error {
    error;
    message;
    stacktrace;
    constructor(error, message, stacktrace) {
        super();
        this.error = error;
        this.message = message;
        this.stacktrace = stacktrace;
    }
    toErrorResponse(commandId) {
        return {
            type: 'error',
            id: commandId,
            error: this.error,
            message: this.message,
            stacktrace: this.stacktrace,
        };
    }
}
exports.Exception = Exception;
class InvalidArgumentException extends Exception {
    constructor(message, stacktrace) {
        super("invalid argument" /* ErrorCode.InvalidArgument */, message, stacktrace);
    }
}
exports.InvalidArgumentException = InvalidArgumentException;
class InvalidSelectorException extends Exception {
    constructor(message, stacktrace) {
        super("invalid selector" /* ErrorCode.InvalidSelector */, message, stacktrace);
    }
}
exports.InvalidSelectorException = InvalidSelectorException;
class InvalidSessionIdException extends Exception {
    constructor(message, stacktrace) {
        super("invalid session id" /* ErrorCode.InvalidSessionId */, message, stacktrace);
    }
}
exports.InvalidSessionIdException = InvalidSessionIdException;
class MoveTargetOutOfBoundsException extends Exception {
    constructor(message, stacktrace) {
        super("move target out of bounds" /* ErrorCode.MoveTargetOutOfBounds */, message, stacktrace);
    }
}
exports.MoveTargetOutOfBoundsException = MoveTargetOutOfBoundsException;
class NoSuchAlertException extends Exception {
    constructor(message, stacktrace) {
        super("no such alert" /* ErrorCode.NoSuchAlert */, message, stacktrace);
    }
}
exports.NoSuchAlertException = NoSuchAlertException;
class NoSuchElementException extends Exception {
    constructor(message, stacktrace) {
        super("no such element" /* ErrorCode.NoSuchElement */, message, stacktrace);
    }
}
exports.NoSuchElementException = NoSuchElementException;
class NoSuchFrameException extends Exception {
    constructor(message, stacktrace) {
        super("no such frame" /* ErrorCode.NoSuchFrame */, message, stacktrace);
    }
}
exports.NoSuchFrameException = NoSuchFrameException;
class NoSuchHandleException extends Exception {
    constructor(message, stacktrace) {
        super("no such handle" /* ErrorCode.NoSuchHandle */, message, stacktrace);
    }
}
exports.NoSuchHandleException = NoSuchHandleException;
class NoSuchHistoryEntryException extends Exception {
    constructor(message, stacktrace) {
        super("no such history entry" /* ErrorCode.NoSuchHistoryEntry */, message, stacktrace);
    }
}
exports.NoSuchHistoryEntryException = NoSuchHistoryEntryException;
class NoSuchInterceptException extends Exception {
    constructor(message, stacktrace) {
        super("no such intercept" /* ErrorCode.NoSuchIntercept */, message, stacktrace);
    }
}
exports.NoSuchInterceptException = NoSuchInterceptException;
class NoSuchNodeException extends Exception {
    constructor(message, stacktrace) {
        super("no such node" /* ErrorCode.NoSuchNode */, message, stacktrace);
    }
}
exports.NoSuchNodeException = NoSuchNodeException;
class NoSuchRequestException extends Exception {
    constructor(message, stacktrace) {
        super("no such request" /* ErrorCode.NoSuchRequest */, message, stacktrace);
    }
}
exports.NoSuchRequestException = NoSuchRequestException;
class NoSuchScriptException extends Exception {
    constructor(message, stacktrace) {
        super("no such script" /* ErrorCode.NoSuchScript */, message, stacktrace);
    }
}
exports.NoSuchScriptException = NoSuchScriptException;
class NoSuchUserContextException extends Exception {
    constructor(message, stacktrace) {
        super("no such user context" /* ErrorCode.NoSuchUserContext */, message, stacktrace);
    }
}
exports.NoSuchUserContextException = NoSuchUserContextException;
class SessionNotCreatedException extends Exception {
    constructor(message, stacktrace) {
        super("session not created" /* ErrorCode.SessionNotCreated */, message, stacktrace);
    }
}
exports.SessionNotCreatedException = SessionNotCreatedException;
class UnknownCommandException extends Exception {
    constructor(message, stacktrace) {
        super("unknown command" /* ErrorCode.UnknownCommand */, message, stacktrace);
    }
}
exports.UnknownCommandException = UnknownCommandException;
class UnknownErrorException extends Exception {
    constructor(message, stacktrace = new Error().stack) {
        super("unknown error" /* ErrorCode.UnknownError */, message, stacktrace);
    }
}
exports.UnknownErrorException = UnknownErrorException;
class UnableToCaptureScreenException extends Exception {
    constructor(message, stacktrace) {
        super("unable to capture screen" /* ErrorCode.UnableToCaptureScreen */, message, stacktrace);
    }
}
exports.UnableToCaptureScreenException = UnableToCaptureScreenException;
class UnableToCloseBrowserException extends Exception {
    constructor(message, stacktrace) {
        super("unable to close browser" /* ErrorCode.UnableToCloseBrowser */, message, stacktrace);
    }
}
exports.UnableToCloseBrowserException = UnableToCloseBrowserException;
class UnsupportedOperationException extends Exception {
    constructor(message, stacktrace) {
        super("unsupported operation" /* ErrorCode.UnsupportedOperation */, message, stacktrace);
    }
}
exports.UnsupportedOperationException = UnsupportedOperationException;
class NoSuchStoragePartitionException extends Exception {
    constructor(message, stacktrace) {
        super("no such storage partition" /* ErrorCode.NoSuchStoragePartition */, message, stacktrace);
    }
}
exports.NoSuchStoragePartitionException = NoSuchStoragePartitionException;
class UnableToSetCookieException extends Exception {
    constructor(message, stacktrace) {
        super("unable to set cookie" /* ErrorCode.UnableToSetCookie */, message, stacktrace);
    }
}
exports.UnableToSetCookieException = UnableToSetCookieException;
class UnableToSetFileInputException extends Exception {
    constructor(message, stacktrace) {
        super("unable to set file input" /* ErrorCode.UnableToSetFileInput */, message, stacktrace);
    }
}
exports.UnableToSetFileInputException = UnableToSetFileInputException;
class UnderspecifiedStoragePartitionException extends Exception {
    constructor(message, stacktrace) {
        super("underspecified storage partition" /* ErrorCode.UnderspecifiedStoragePartition */, message, stacktrace);
    }
}
exports.UnderspecifiedStoragePartitionException = UnderspecifiedStoragePartitionException;
//# sourceMappingURL=ErrorResponse.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=cdp.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EVENT_NAMES = exports.Network = exports.BrowsingContext = exports.Log = exports.Script = exports.BiDiModule = void 0;
// keep-sorted end
var BiDiModule;
(function (BiDiModule) {
    // keep-sorted start
    BiDiModule["Browser"] = "browser";
    BiDiModule["BrowsingContext"] = "browsingContext";
    BiDiModule["Cdp"] = "cdp";
    BiDiModule["Input"] = "input";
    BiDiModule["Log"] = "log";
    BiDiModule["Network"] = "network";
    BiDiModule["Script"] = "script";
    BiDiModule["Session"] = "session";
    // keep-sorted end
})(BiDiModule || (exports.BiDiModule = BiDiModule = {}));
var Script;
(function (Script) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["Message"] = "script.message";
        EventNames["RealmCreated"] = "script.realmCreated";
        EventNames["RealmDestroyed"] = "script.realmDestroyed";
        // keep-sorted end
    })(EventNames = Script.EventNames || (Script.EventNames = {}));
})(Script || (exports.Script = Script = {}));
var Log;
(function (Log) {
    let EventNames;
    (function (EventNames) {
        EventNames["LogEntryAdded"] = "log.entryAdded";
    })(EventNames = Log.EventNames || (Log.EventNames = {}));
})(Log || (exports.Log = Log = {}));
var BrowsingContext;
(function (BrowsingContext) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["ContextCreated"] = "browsingContext.contextCreated";
        EventNames["ContextDestroyed"] = "browsingContext.contextDestroyed";
        EventNames["DomContentLoaded"] = "browsingContext.domContentLoaded";
        EventNames["DownloadWillBegin"] = "browsingContext.downloadWillBegin";
        EventNames["FragmentNavigated"] = "browsingContext.fragmentNavigated";
        EventNames["Load"] = "browsingContext.load";
        EventNames["NavigationAborted"] = "browsingContext.navigationAborted";
        EventNames["NavigationFailed"] = "browsingContext.navigationFailed";
        EventNames["NavigationStarted"] = "browsingContext.navigationStarted";
        EventNames["UserPromptClosed"] = "browsingContext.userPromptClosed";
        EventNames["UserPromptOpened"] = "browsingContext.userPromptOpened";
        // keep-sorted end
    })(EventNames = BrowsingContext.EventNames || (BrowsingContext.EventNames = {}));
})(BrowsingContext || (exports.BrowsingContext = BrowsingContext = {}));
var Network;
(function (Network) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["AuthRequired"] = "network.authRequired";
        EventNames["BeforeRequestSent"] = "network.beforeRequestSent";
        EventNames["FetchError"] = "network.fetchError";
        EventNames["ResponseCompleted"] = "network.responseCompleted";
        EventNames["ResponseStarted"] = "network.responseStarted";
        // keep-sorted end
    })(EventNames = Network.EventNames || (Network.EventNames = {}));
})(Network || (exports.Network = Network = {}));
exports.EVENT_NAMES = new Set([
    // keep-sorted start
    ...Object.values(BiDiModule),
    ...Object.values(BrowsingContext.EventNames),
    ...Object.values(Log.EventNames),
    ...Object.values(Network.EventNames),
    ...Object.values(Script.EventNames),
    // keep-sorted end
]);
//# sourceMappingURL=chromium-bidi.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=webdriver-bidi-permissions.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=webdriver-bidi.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChromiumBidi = exports.Cdp = void 0;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.Cdp = __importStar(__webpack_require__(/*! ./cdp.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js"));
exports.ChromiumBidi = __importStar(__webpack_require__(/*! ./chromium-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js"));
__exportStar(__webpack_require__(/*! ./generated/webdriver-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js"), exports);
__exportStar(__webpack_require__(/*! ./ErrorResponse.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js"), exports);
__exportStar(__webpack_require__(/*! ./generated/webdriver-bidi-permissions.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js"), exports);
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Base64.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Base64.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64ToString = base64ToString;
/**
 * Encodes a string to base64.
 *
 * Uses the native Web API if available, otherwise falls back to a NodeJS Buffer.
 * @param {string} base64Str
 * @return {string}
 */
function base64ToString(base64Str) {
    // Available only if run in a browser context.
    if ('atob' in globalThis) {
        return globalThis.atob(base64Str);
    }
    // Available only if run in a NodeJS context.
    return Buffer.from(base64Str, 'base64').toString('ascii');
}
//# sourceMappingURL=Base64.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Buffer = void 0;
/** Implements a FIFO buffer with a fixed size. */
class Buffer {
    #capacity;
    #entries = [];
    #onItemRemoved;
    /**
     * @param capacity The buffer capacity.
     * @param onItemRemoved Delegate called for each removed element.
     */
    constructor(capacity, onItemRemoved) {
        this.#capacity = capacity;
        this.#onItemRemoved = onItemRemoved;
    }
    get() {
        return this.#entries;
    }
    add(value) {
        this.#entries.push(value);
        while (this.#entries.length > this.#capacity) {
            const item = this.#entries.shift();
            if (item !== undefined) {
                this.#onItemRemoved?.(item);
            }
        }
    }
}
exports.Buffer = Buffer;
//# sourceMappingURL=Buffer.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultMap = void 0;
/**
 * A subclass of Map whose functionality is almost the same as its parent
 * except for the fact that DefaultMap never returns undefined. It provides a
 * default value for keys that do not exist.
 */
class DefaultMap extends Map {
    /** The default value to return whenever a key is not present in the map. */
    #getDefaultValue;
    constructor(getDefaultValue, entries) {
        super(entries);
        this.#getDefaultValue = getDefaultValue;
    }
    get(key) {
        if (!this.has(key)) {
            this.set(key, this.#getDefaultValue(key));
        }
        return super.get(key);
    }
}
exports.DefaultMap = DefaultMap;
//# sourceMappingURL=DefaultMap.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js":
/*!**************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
class Deferred {
    #isFinished = false;
    #promise;
    #result;
    #resolve;
    #reject;
    get isFinished() {
        return this.#isFinished;
    }
    get result() {
        if (!this.#isFinished) {
            throw new Error('Deferred is not finished yet');
        }
        return this.#result;
    }
    constructor() {
        this.#promise = new Promise((resolve, reject) => {
            this.#resolve = resolve;
            this.#reject = reject;
        });
        // Needed to avoid `Uncaught (in promise)`. The promises returned by `then`
        // and `catch` will be rejected anyway.
        this.#promise.catch((_error) => {
            // Intentionally empty.
        });
    }
    then(onFulfilled, onRejected) {
        return this.#promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this.#promise.catch(onRejected);
    }
    resolve(value) {
        this.#result = value;
        if (!this.#isFinished) {
            this.#isFinished = true;
            this.#resolve(value);
        }
    }
    reject(reason) {
        if (!this.#isFinished) {
            this.#isFinished = true;
            this.#reject(reason);
        }
    }
    finally(onFinally) {
        return this.#promise.finally(onFinally);
    }
    [Symbol.toStringTag] = 'Promise';
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js":
/*!********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distinctValues = distinctValues;
exports.deterministicJSONStringify = deterministicJSONStringify;
/**
 * Returns an array of distinct values. Order is not guaranteed.
 * @param values - The values to filter. Should be JSON-serializable.
 * @return - An array of distinct values.
 */
function distinctValues(values) {
    const map = new Map();
    for (const value of values) {
        map.set(deterministicJSONStringify(value), value);
    }
    return Array.from(map.values());
}
/**
 * Returns a stringified version of the object with keys sorted. This is required to
 * ensure that the stringified version of an object is deterministic independent of the
 * order of keys.
 * @param obj
 * @return {string}
 */
function deterministicJSONStringify(obj) {
    return JSON.stringify(normalizeObject(obj));
}
function normalizeObject(obj) {
    if (obj === undefined ||
        obj === null ||
        Array.isArray(obj) ||
        typeof obj !== 'object') {
        return obj;
    }
    // Copy the original object key and values to a new object in sorted order.
    const newObj = {};
    for (const key of Object.keys(obj).sort()) {
        const value = obj[key];
        newObj[key] = normalizeObject(value); // Recursively sort nested objects
    }
    return newObj;
}
//# sourceMappingURL=DistinctValues.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js":
/*!******************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mitt_1 = __importDefault(__webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.mjs"));
class EventEmitter {
    #emitter = (0, mitt_1.default)();
    on(type, handler) {
        this.#emitter.on(type, handler);
        return this;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param event The event you'd like to listen to
     * @param handler The handler function to run when the event occurs
     * @return `this` to enable chaining method calls.
     */
    once(event, handler) {
        const onceHandler = (eventData) => {
            handler(eventData);
            this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
    }
    off(type, handler) {
        this.#emitter.off(type, handler);
        return this;
    }
    /**
     * Emits an event and call any associated listeners.
     *
     * @param event The event to emit.
     * @param eventData Any data to emit with the event.
     * @return `true` if there are any listeners, `false` otherwise.
     */
    emit(event, eventData) {
        this.#emitter.emit(event, eventData);
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     * @param event - the event to remove listeners for.
     * @returns `this` to enable you to chain method calls.
     */
    removeAllListeners(event) {
        if (event) {
            this.#emitter.all.delete(event);
        }
        else {
            this.#emitter.all.clear();
        }
        return this;
    }
}
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSingleComplexGrapheme = isSingleComplexGrapheme;
exports.isSingleGrapheme = isSingleGrapheme;
/**
 * Check if the given string is a single complex grapheme. A complex grapheme is one that
 * is made up of multiple characters.
 */
function isSingleComplexGrapheme(value) {
    return isSingleGrapheme(value) && value.length > 1;
}
/**
 * Check if the given string is a single grapheme.
 */
function isSingleGrapheme(value) {
    // Theoretically there can be some strings considered a grapheme in some locales, like
    // slovak "ch" digraph. Use english locale for consistency.
    // https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
    const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
    return [...segmenter.segment(value)].length === 1;
}
//# sourceMappingURL=GraphemeTools.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js":
/*!***************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdWrapper = void 0;
/**
 * Creates an object with a positive unique incrementing id.
 */
class IdWrapper {
    static #counter = 0;
    #id;
    constructor() {
        this.#id = ++IdWrapper.#counter;
    }
    get id() {
        return this.#id;
    }
}
exports.IdWrapper = IdWrapper;
//# sourceMappingURL=IdWrapper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js":
/*!***********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 * Copyright 2022 The Chromium Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mutex = void 0;
/**
 * Use Mutex class to coordinate local concurrent operations.
 * Once `acquire` promise resolves, you hold the lock and must
 * call `release` function returned by `acquire` to release the
 * lock. Failing to `release` the lock may lead to deadlocks.
 */
class Mutex {
    #locked = false;
    #acquirers = [];
    // This is FIFO.
    acquire() {
        const state = { resolved: false };
        if (this.#locked) {
            return new Promise((resolve) => {
                this.#acquirers.push(() => resolve(this.#release.bind(this, state)));
            });
        }
        this.#locked = true;
        return Promise.resolve(this.#release.bind(this, state));
    }
    #release(state) {
        if (state.resolved) {
            throw new Error('Cannot release more than once.');
        }
        state.resolved = true;
        const resolve = this.#acquirers.shift();
        if (!resolve) {
            this.#locked = false;
            return;
        }
        resolve();
    }
    async run(action) {
        const release = await this.acquire();
        try {
            // Note we need to await here because we want the await to release AFTER
            // that await happens. Returning action() will trigger the release
            // immediately which is counter to what we want.
            const result = await action();
            return result;
        }
        finally {
            release();
        }
    }
}
exports.Mutex = Mutex;
//# sourceMappingURL=Mutex.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessingQueue = void 0;
const log_js_1 = __webpack_require__(/*! ./log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
class ProcessingQueue {
    static LOGGER_PREFIX = `${log_js_1.LogType.debug}:queue`;
    #logger;
    #processor;
    #queue = [];
    // Flag to keep only 1 active processor.
    #isProcessing = false;
    constructor(processor, logger) {
        this.#processor = processor;
        this.#logger = logger;
    }
    add(entry, name) {
        this.#queue.push([entry, name]);
        // No need in waiting. Just initialize processor if needed.
        void this.#processIfNeeded();
    }
    async #processIfNeeded() {
        if (this.#isProcessing) {
            return;
        }
        this.#isProcessing = true;
        while (this.#queue.length > 0) {
            const arrayEntry = this.#queue.shift();
            if (!arrayEntry) {
                continue;
            }
            const [entryPromise, name] = arrayEntry;
            this.#logger?.(ProcessingQueue.LOGGER_PREFIX, 'Processing event:', name);
            await entryPromise
                .then((entry) => {
                if (entry.kind === 'error') {
                    this.#logger?.(log_js_1.LogType.debugError, 'Event threw before sending:', entry.error.message, entry.error.stack);
                    return;
                }
                return this.#processor(entry.value);
            })
                .catch((error) => {
                this.#logger?.(log_js_1.LogType.debugError, 'Event was not processed:', error?.message);
            });
        }
        this.#isProcessing = false;
    }
}
exports.ProcessingQueue = ProcessingQueue;
//# sourceMappingURL=ProcessingQueue.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js":
/*!****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URLPattern = void 0;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const urlpattern_polyfill_1 = __webpack_require__(/*! urlpattern-polyfill */ "./node_modules/urlpattern-polyfill/index.cjs");
// XXX: Switch to native URLPattern when available.
// https://github.com/nodejs/node/issues/40844
let URLPattern = urlpattern_polyfill_1.URLPattern;
exports.URLPattern = URLPattern;
if ('URLPattern' in globalThis) {
    // eslint-disable-next-line no-global-assign
    exports.URLPattern = URLPattern = globalThis.URLPattern;
}
//# sourceMappingURL=UrlPattern.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/assert.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = assert;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assert(predicate, message) {
    if (!predicate) {
        throw new Error(message ?? 'Internal assertion failed.');
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/log.js":
/*!*********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/log.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogType = void 0;
var LogType;
(function (LogType) {
    // keep-sorted start
    LogType["bidi"] = "bidi";
    LogType["cdp"] = "cdp";
    LogType["debug"] = "debug";
    LogType["debugError"] = "debug:error";
    LogType["debugInfo"] = "debug:info";
    // keep-sorted end
})(LogType || (exports.LogType = LogType = {}));
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inchesFromCm = inchesFromCm;
/** @return Given an input in cm, convert it to inches. */
function inchesFromCm(cm) {
    return cm / 2.54;
}
//# sourceMappingURL=unitConversions.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js":
/*!**********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/uuid.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidv4 = uuidv4;
function bytesToHex(bytes) {
    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
}
/**
 * Generates a random v4 UUID, as specified in RFC4122.
 *
 * Uses the native Web Crypto API if available, otherwise falls back to a
 * polyfill.
 *
 * Example: '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
 */
function uuidv4() {
    // Available only in secure contexts
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API
    if ('crypto' in globalThis && 'randomUUID' in globalThis.crypto) {
        // Node with
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1 or
        // secure browser context.
        return globalThis.crypto.randomUUID();
    }
    const randomValues = new Uint8Array(16);
    if ('crypto' in globalThis && 'getRandomValues' in globalThis.crypto) {
        // Node (>=18) with
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1 or
        // browser.
        globalThis.crypto.getRandomValues(randomValues);
    }
    else {
        // Node (<=16) without
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1.
        // eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports
        (__webpack_require__(/*! crypto */ "crypto").webcrypto).getRandomValues(randomValues);
    }
    // Set version (4) and variant (RFC4122) bits.
    randomValues[6] = (randomValues[6] & 0x0f) | 0x40;
    randomValues[8] = (randomValues[8] & 0x3f) | 0x80;
    return [
        bytesToHex(randomValues.subarray(0, 4)),
        bytesToHex(randomValues.subarray(4, 6)),
        bytesToHex(randomValues.subarray(6, 8)),
        bytesToHex(randomValues.subarray(8, 10)),
        bytesToHex(randomValues.subarray(10, 16)),
    ].join('-');
}
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/urlpattern-polyfill/dist/urlpattern.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/urlpattern-polyfill/dist/urlpattern.cjs ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
var M=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Ee=Object.prototype.hasOwnProperty;var Oe=(e,t)=>{for(var r in t)M(e,r,{get:t[r],enumerable:!0})},ke=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of Re(t))!Ee.call(e,a)&&a!==r&&M(e,a,{get:()=>t[a],enumerable:!(n=Pe(t,a))||n.enumerable});return e};var Te=e=>ke(M({},"__esModule",{value:!0}),e);var Ne={};Oe(Ne,{URLPattern:()=>Y});module.exports=Te(Ne);var R=class{type=3;name="";prefix="";value="";suffix="";modifier=3;constructor(t,r,n,a,c,l){this.type=t,this.name=r,this.prefix=n,this.value=a,this.suffix=c,this.modifier=l}hasCustomName(){return this.name!==""&&typeof this.name!="number"}},Ae=/[$_\p{ID_Start}]/u,ye=/[$_\u200C\u200D\p{ID_Continue}]/u,v=".*";function we(e,t){return(t?/^[\x00-\xFF]*$/:/^[\x00-\x7F]*$/).test(e)}function D(e,t=!1){let r=[],n=0;for(;n<e.length;){let a=e[n],c=function(l){if(!t)throw new TypeError(l);r.push({type:"INVALID_CHAR",index:n,value:e[n++]})};if(a==="*"){r.push({type:"ASTERISK",index:n,value:e[n++]});continue}if(a==="+"||a==="?"){r.push({type:"OTHER_MODIFIER",index:n,value:e[n++]});continue}if(a==="\\"){r.push({type:"ESCAPED_CHAR",index:n++,value:e[n++]});continue}if(a==="{"){r.push({type:"OPEN",index:n,value:e[n++]});continue}if(a==="}"){r.push({type:"CLOSE",index:n,value:e[n++]});continue}if(a===":"){let l="",s=n+1;for(;s<e.length;){let i=e.substr(s,1);if(s===n+1&&Ae.test(i)||s!==n+1&&ye.test(i)){l+=e[s++];continue}break}if(!l){c(`Missing parameter name at ${n}`);continue}r.push({type:"NAME",index:n,value:l}),n=s;continue}if(a==="("){let l=1,s="",i=n+1,o=!1;if(e[i]==="?"){c(`Pattern cannot start with "?" at ${i}`);continue}for(;i<e.length;){if(!we(e[i],!1)){c(`Invalid character '${e[i]}' at ${i}.`),o=!0;break}if(e[i]==="\\"){s+=e[i++]+e[i++];continue}if(e[i]===")"){if(l--,l===0){i++;break}}else if(e[i]==="("&&(l++,e[i+1]!=="?")){c(`Capturing groups are not allowed at ${i}`),o=!0;break}s+=e[i++]}if(o)continue;if(l){c(`Unbalanced pattern at ${n}`);continue}if(!s){c(`Missing pattern at ${n}`);continue}r.push({type:"REGEX",index:n,value:s}),n=i;continue}r.push({type:"CHAR",index:n,value:e[n++]})}return r.push({type:"END",index:n,value:""}),r}function F(e,t={}){let r=D(e);t.delimiter??="/#?",t.prefixes??="./";let n=`[^${S(t.delimiter)}]+?`,a=[],c=0,l=0,s="",i=new Set,o=h=>{if(l<r.length&&r[l].type===h)return r[l++].value},f=()=>o("OTHER_MODIFIER")??o("ASTERISK"),d=h=>{let u=o(h);if(u!==void 0)return u;let{type:p,index:A}=r[l];throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`)},T=()=>{let h="",u;for(;u=o("CHAR")??o("ESCAPED_CHAR");)h+=u;return h},xe=h=>h,L=t.encodePart||xe,I="",U=h=>{I+=h},$=()=>{I.length&&(a.push(new R(3,"","",L(I),"",3)),I="")},X=(h,u,p,A,Z)=>{let g=3;switch(Z){case"?":g=1;break;case"*":g=0;break;case"+":g=2;break}if(!u&&!p&&g===3){U(h);return}if($(),!u&&!p){if(!h)return;a.push(new R(3,"","",L(h),"",g));return}let m;p?p==="*"?m=v:m=p:m=n;let O=2;m===n?(O=1,m=""):m===v&&(O=0,m="");let P;if(u?P=u:p&&(P=c++),i.has(P))throw new TypeError(`Duplicate name '${P}'.`);i.add(P),a.push(new R(O,P,L(h),m,L(A),g))};for(;l<r.length;){let h=o("CHAR"),u=o("NAME"),p=o("REGEX");if(!u&&!p&&(p=o("ASTERISK")),u||p){let g=h??"";t.prefixes.indexOf(g)===-1&&(U(g),g=""),$();let m=f();X(g,u,p,"",m);continue}let A=h??o("ESCAPED_CHAR");if(A){U(A);continue}if(o("OPEN")){let g=T(),m=o("NAME"),O=o("REGEX");!m&&!O&&(O=o("ASTERISK"));let P=T();d("CLOSE");let be=f();X(g,m,O,P,be);continue}$(),d("END")}return a}function S(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function B(e){return e&&e.ignoreCase?"ui":"u"}function q(e,t,r){return W(F(e,r),t,r)}function k(e){switch(e){case 0:return"*";case 1:return"?";case 2:return"+";case 3:return""}}function W(e,t,r={}){r.delimiter??="/#?",r.prefixes??="./",r.sensitive??=!1,r.strict??=!1,r.end??=!0,r.start??=!0,r.endsWith="";let n=r.start?"^":"";for(let s of e){if(s.type===3){s.modifier===3?n+=S(s.value):n+=`(?:${S(s.value)})${k(s.modifier)}`;continue}t&&t.push(s.name);let i=`[^${S(r.delimiter)}]+?`,o=s.value;if(s.type===1?o=i:s.type===0&&(o=v),!s.prefix.length&&!s.suffix.length){s.modifier===3||s.modifier===1?n+=`(${o})${k(s.modifier)}`:n+=`((?:${o})${k(s.modifier)})`;continue}if(s.modifier===3||s.modifier===1){n+=`(?:${S(s.prefix)}(${o})${S(s.suffix)})`,n+=k(s.modifier);continue}n+=`(?:${S(s.prefix)}`,n+=`((?:${o})(?:`,n+=S(s.suffix),n+=S(s.prefix),n+=`(?:${o}))*)${S(s.suffix)})`,s.modifier===0&&(n+="?")}let a=`[${S(r.endsWith)}]|$`,c=`[${S(r.delimiter)}]`;if(r.end)return r.strict||(n+=`${c}?`),r.endsWith.length?n+=`(?=${a})`:n+="$",new RegExp(n,B(r));r.strict||(n+=`(?:${c}(?=${a}))?`);let l=!1;if(e.length){let s=e[e.length-1];s.type===3&&s.modifier===3&&(l=r.delimiter.indexOf(s)>-1)}return l||(n+=`(?=${c}|${a})`),new RegExp(n,B(r))}var x={delimiter:"",prefixes:"",sensitive:!0,strict:!0},J={delimiter:".",prefixes:"",sensitive:!0,strict:!0},Q={delimiter:"/",prefixes:"/",sensitive:!0,strict:!0};function ee(e,t){return e.length?e[0]==="/"?!0:!t||e.length<2?!1:(e[0]=="\\"||e[0]=="{")&&e[1]=="/":!1}function te(e,t){return e.startsWith(t)?e.substring(t.length,e.length):e}function Ce(e,t){return e.endsWith(t)?e.substr(0,e.length-t.length):e}function _(e){return!e||e.length<2?!1:e[0]==="["||(e[0]==="\\"||e[0]==="{")&&e[1]==="["}var re=["ftp","file","http","https","ws","wss"];function N(e){if(!e)return!0;for(let t of re)if(e.test(t))return!0;return!1}function ne(e,t){if(e=te(e,"#"),t||e==="")return e;let r=new URL("https://example.com");return r.hash=e,r.hash?r.hash.substring(1,r.hash.length):""}function se(e,t){if(e=te(e,"?"),t||e==="")return e;let r=new URL("https://example.com");return r.search=e,r.search?r.search.substring(1,r.search.length):""}function ie(e,t){return t||e===""?e:_(e)?K(e):j(e)}function ae(e,t){if(t||e==="")return e;let r=new URL("https://example.com");return r.password=e,r.password}function oe(e,t){if(t||e==="")return e;let r=new URL("https://example.com");return r.username=e,r.username}function ce(e,t,r){if(r||e==="")return e;if(t&&!re.includes(t))return new URL(`${t}:${e}`).pathname;let n=e[0]=="/";return e=new URL(n?e:"/-"+e,"https://example.com").pathname,n||(e=e.substring(2,e.length)),e}function le(e,t,r){return z(t)===e&&(e=""),r||e===""?e:G(e)}function fe(e,t){return e=Ce(e,":"),t||e===""?e:y(e)}function z(e){switch(e){case"ws":case"http":return"80";case"wws":case"https":return"443";case"ftp":return"21";default:return""}}function y(e){if(e==="")return e;if(/^[-+.A-Za-z0-9]*$/.test(e))return e.toLowerCase();throw new TypeError(`Invalid protocol '${e}'.`)}function he(e){if(e==="")return e;let t=new URL("https://example.com");return t.username=e,t.username}function ue(e){if(e==="")return e;let t=new URL("https://example.com");return t.password=e,t.password}function j(e){if(e==="")return e;if(/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))throw new TypeError(`Invalid hostname '${e}'`);let t=new URL("https://example.com");return t.hostname=e,t.hostname}function K(e){if(e==="")return e;if(/[^0-9a-fA-F[\]:]/g.test(e))throw new TypeError(`Invalid IPv6 hostname '${e}'`);return e.toLowerCase()}function G(e){if(e===""||/^[0-9]*$/.test(e)&&parseInt(e)<=65535)return e;throw new TypeError(`Invalid port '${e}'.`)}function de(e){if(e==="")return e;let t=new URL("https://example.com");return t.pathname=e[0]!=="/"?"/-"+e:e,e[0]!=="/"?t.pathname.substring(2,t.pathname.length):t.pathname}function pe(e){return e===""?e:new URL(`data:${e}`).pathname}function ge(e){if(e==="")return e;let t=new URL("https://example.com");return t.search=e,t.search.substring(1,t.search.length)}function me(e){if(e==="")return e;let t=new URL("https://example.com");return t.hash=e,t.hash.substring(1,t.hash.length)}var H=class{#i;#n=[];#t={};#e=0;#s=1;#l=0;#o=0;#d=0;#p=0;#g=!1;constructor(t){this.#i=t}get result(){return this.#t}parse(){for(this.#n=D(this.#i,!0);this.#e<this.#n.length;this.#e+=this.#s){if(this.#s=1,this.#n[this.#e].type==="END"){if(this.#o===0){this.#b(),this.#f()?this.#r(9,1):this.#h()?this.#r(8,1):this.#r(7,0);continue}else if(this.#o===2){this.#u(5);continue}this.#r(10,0);break}if(this.#d>0)if(this.#A())this.#d-=1;else continue;if(this.#T()){this.#d+=1;continue}switch(this.#o){case 0:this.#P()&&this.#u(1);break;case 1:if(this.#P()){this.#C();let t=7,r=1;this.#E()?(t=2,r=3):this.#g&&(t=2),this.#r(t,r)}break;case 2:this.#S()?this.#u(3):(this.#x()||this.#h()||this.#f())&&this.#u(5);break;case 3:this.#O()?this.#r(4,1):this.#S()&&this.#r(5,1);break;case 4:this.#S()&&this.#r(5,1);break;case 5:this.#y()?this.#p+=1:this.#w()&&(this.#p-=1),this.#k()&&!this.#p?this.#r(6,1):this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 6:this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 7:this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 8:this.#f()&&this.#r(9,1);break;case 9:break;case 10:break}}this.#t.hostname!==void 0&&this.#t.port===void 0&&(this.#t.port="")}#r(t,r){switch(this.#o){case 0:break;case 1:this.#t.protocol=this.#c();break;case 2:break;case 3:this.#t.username=this.#c();break;case 4:this.#t.password=this.#c();break;case 5:this.#t.hostname=this.#c();break;case 6:this.#t.port=this.#c();break;case 7:this.#t.pathname=this.#c();break;case 8:this.#t.search=this.#c();break;case 9:this.#t.hash=this.#c();break;case 10:break}this.#o!==0&&t!==10&&([1,2,3,4].includes(this.#o)&&[6,7,8,9].includes(t)&&(this.#t.hostname??=""),[1,2,3,4,5,6].includes(this.#o)&&[8,9].includes(t)&&(this.#t.pathname??=this.#g?"/":""),[1,2,3,4,5,6,7].includes(this.#o)&&t===9&&(this.#t.search??="")),this.#R(t,r)}#R(t,r){this.#o=t,this.#l=this.#e+r,this.#e+=r,this.#s=0}#b(){this.#e=this.#l,this.#s=0}#u(t){this.#b(),this.#o=t}#m(t){return t<0&&(t=this.#n.length-t),t<this.#n.length?this.#n[t]:this.#n[this.#n.length-1]}#a(t,r){let n=this.#m(t);return n.value===r&&(n.type==="CHAR"||n.type==="ESCAPED_CHAR"||n.type==="INVALID_CHAR")}#P(){return this.#a(this.#e,":")}#E(){return this.#a(this.#e+1,"/")&&this.#a(this.#e+2,"/")}#S(){return this.#a(this.#e,"@")}#O(){return this.#a(this.#e,":")}#k(){return this.#a(this.#e,":")}#x(){return this.#a(this.#e,"/")}#h(){if(this.#a(this.#e,"?"))return!0;if(this.#n[this.#e].value!=="?")return!1;let t=this.#m(this.#e-1);return t.type!=="NAME"&&t.type!=="REGEX"&&t.type!=="CLOSE"&&t.type!=="ASTERISK"}#f(){return this.#a(this.#e,"#")}#T(){return this.#n[this.#e].type=="OPEN"}#A(){return this.#n[this.#e].type=="CLOSE"}#y(){return this.#a(this.#e,"[")}#w(){return this.#a(this.#e,"]")}#c(){let t=this.#n[this.#e],r=this.#m(this.#l).index;return this.#i.substring(r,t.index)}#C(){let t={};Object.assign(t,x),t.encodePart=y;let r=q(this.#c(),void 0,t);this.#g=N(r)}};var V=["protocol","username","password","hostname","port","pathname","search","hash"],E="*";function Se(e,t){if(typeof e!="string")throw new TypeError("parameter 1 is not of type 'string'.");let r=new URL(e,t);return{protocol:r.protocol.substring(0,r.protocol.length-1),username:r.username,password:r.password,hostname:r.hostname,port:r.port,pathname:r.pathname,search:r.search!==""?r.search.substring(1,r.search.length):void 0,hash:r.hash!==""?r.hash.substring(1,r.hash.length):void 0}}function b(e,t){return t?C(e):e}function w(e,t,r){let n;if(typeof t.baseURL=="string")try{n=new URL(t.baseURL),t.protocol===void 0&&(e.protocol=b(n.protocol.substring(0,n.protocol.length-1),r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&(e.username=b(n.username,r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&t.password===void 0&&(e.password=b(n.password,r)),t.protocol===void 0&&t.hostname===void 0&&(e.hostname=b(n.hostname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&(e.port=b(n.port,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&(e.pathname=b(n.pathname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&(e.search=b(n.search.substring(1,n.search.length),r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&t.hash===void 0&&(e.hash=b(n.hash.substring(1,n.hash.length),r))}catch{throw new TypeError(`invalid baseURL '${t.baseURL}'.`)}if(typeof t.protocol=="string"&&(e.protocol=fe(t.protocol,r)),typeof t.username=="string"&&(e.username=oe(t.username,r)),typeof t.password=="string"&&(e.password=ae(t.password,r)),typeof t.hostname=="string"&&(e.hostname=ie(t.hostname,r)),typeof t.port=="string"&&(e.port=le(t.port,e.protocol,r)),typeof t.pathname=="string"){if(e.pathname=t.pathname,n&&!ee(e.pathname,r)){let a=n.pathname.lastIndexOf("/");a>=0&&(e.pathname=b(n.pathname.substring(0,a+1),r)+e.pathname)}e.pathname=ce(e.pathname,e.protocol,r)}return typeof t.search=="string"&&(e.search=se(t.search,r)),typeof t.hash=="string"&&(e.hash=ne(t.hash,r)),e}function C(e){return e.replace(/([+*?:{}()\\])/g,"\\$1")}function Le(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function Ie(e,t){t.delimiter??="/#?",t.prefixes??="./",t.sensitive??=!1,t.strict??=!1,t.end??=!0,t.start??=!0,t.endsWith="";let r=".*",n=`[^${Le(t.delimiter)}]+?`,a=/[$_\u200C\u200D\p{ID_Continue}]/u,c="";for(let l=0;l<e.length;++l){let s=e[l];if(s.type===3){if(s.modifier===3){c+=C(s.value);continue}c+=`{${C(s.value)}}${k(s.modifier)}`;continue}let i=s.hasCustomName(),o=!!s.suffix.length||!!s.prefix.length&&(s.prefix.length!==1||!t.prefixes.includes(s.prefix)),f=l>0?e[l-1]:null,d=l<e.length-1?e[l+1]:null;if(!o&&i&&s.type===1&&s.modifier===3&&d&&!d.prefix.length&&!d.suffix.length)if(d.type===3){let T=d.value.length>0?d.value[0]:"";o=a.test(T)}else o=!d.hasCustomName();if(!o&&!s.prefix.length&&f&&f.type===3){let T=f.value[f.value.length-1];o=t.prefixes.includes(T)}o&&(c+="{"),c+=C(s.prefix),i&&(c+=`:${s.name}`),s.type===2?c+=`(${s.value})`:s.type===1?i||(c+=`(${n})`):s.type===0&&(!i&&(!f||f.type===3||f.modifier!==3||o||s.prefix!=="")?c+="*":c+=`(${r})`),s.type===1&&i&&s.suffix.length&&a.test(s.suffix[0])&&(c+="\\"),c+=C(s.suffix),o&&(c+="}"),s.modifier!==3&&(c+=k(s.modifier))}return c}var Y=class{#i;#n={};#t={};#e={};#s={};#l=!1;constructor(t={},r,n){try{let a;if(typeof r=="string"?a=r:n=r,typeof t=="string"){let i=new H(t);if(i.parse(),t=i.result,a===void 0&&typeof t.protocol!="string")throw new TypeError("A base URL must be provided for a relative constructor string.");t.baseURL=a}else{if(!t||typeof t!="object")throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");if(a)throw new TypeError("parameter 1 is not of type 'string'.")}typeof n>"u"&&(n={ignoreCase:!1});let c={ignoreCase:n.ignoreCase===!0},l={pathname:E,protocol:E,username:E,password:E,hostname:E,port:E,search:E,hash:E};this.#i=w(l,t,!0),z(this.#i.protocol)===this.#i.port&&(this.#i.port="");let s;for(s of V){if(!(s in this.#i))continue;let i={},o=this.#i[s];switch(this.#t[s]=[],s){case"protocol":Object.assign(i,x),i.encodePart=y;break;case"username":Object.assign(i,x),i.encodePart=he;break;case"password":Object.assign(i,x),i.encodePart=ue;break;case"hostname":Object.assign(i,J),_(o)?i.encodePart=K:i.encodePart=j;break;case"port":Object.assign(i,x),i.encodePart=G;break;case"pathname":N(this.#n.protocol)?(Object.assign(i,Q,c),i.encodePart=de):(Object.assign(i,x,c),i.encodePart=pe);break;case"search":Object.assign(i,x,c),i.encodePart=ge;break;case"hash":Object.assign(i,x,c),i.encodePart=me;break}try{this.#s[s]=F(o,i),this.#n[s]=W(this.#s[s],this.#t[s],i),this.#e[s]=Ie(this.#s[s],i),this.#l=this.#l||this.#s[s].some(f=>f.type===2)}catch{throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`)}}}catch(a){throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`)}}test(t={},r){let n={pathname:"",protocol:"",username:"",password:"",hostname:"",port:"",search:"",hash:""};if(typeof t!="string"&&r)throw new TypeError("parameter 1 is not of type 'string'.");if(typeof t>"u")return!1;try{typeof t=="object"?n=w(n,t,!1):n=w(n,Se(t,r),!1)}catch{return!1}let a;for(a of V)if(!this.#n[a].exec(n[a]))return!1;return!0}exec(t={},r){let n={pathname:"",protocol:"",username:"",password:"",hostname:"",port:"",search:"",hash:""};if(typeof t!="string"&&r)throw new TypeError("parameter 1 is not of type 'string'.");if(typeof t>"u")return;try{typeof t=="object"?n=w(n,t,!1):n=w(n,Se(t,r),!1)}catch{return null}let a={};r?a.inputs=[t,r]:a.inputs=[t];let c;for(c of V){let l=this.#n[c].exec(n[c]);if(!l)return null;let s={};for(let[i,o]of this.#t[c].entries())if(typeof o=="string"||typeof o=="number"){let f=l[i+1];s[o]=f}a[c]={input:n[c]??"",groups:s}}return a}static compareComponent(t,r,n){let a=(i,o)=>{for(let f of["type","modifier","prefix","value","suffix"]){if(i[f]<o[f])return-1;if(i[f]===o[f])continue;return 1}return 0},c=new R(3,"","","","",3),l=new R(0,"","","","",3),s=(i,o)=>{let f=0;for(;f<Math.min(i.length,o.length);++f){let d=a(i[f],o[f]);if(d)return d}return i.length===o.length?0:a(i[f]??c,o[f]??c)};return!r.#e[t]&&!n.#e[t]?0:r.#e[t]&&!n.#e[t]?s(r.#s[t],[l]):!r.#e[t]&&n.#e[t]?s([l],n.#s[t]):s(r.#s[t],n.#s[t])}get protocol(){return this.#e.protocol}get username(){return this.#e.username}get password(){return this.#e.password}get hostname(){return this.#e.hostname}get port(){return this.#e.port}get pathname(){return this.#e.pathname}get search(){return this.#e.search}get hash(){return this.#e.hash}get hasRegExpGroups(){return this.#l}};


/***/ }),

/***/ "./node_modules/urlpattern-polyfill/index.cjs":
/*!****************************************************!*\
  !*** ./node_modules/urlpattern-polyfill/index.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { URLPattern } = __webpack_require__(/*! ./dist/urlpattern.cjs */ "./node_modules/urlpattern-polyfill/dist/urlpattern.cjs");

module.exports = { URLPattern };

if (!globalThis.URLPattern) {
  globalThis.URLPattern = URLPattern;
}


/***/ }),

/***/ "./node_modules/mitt/dist/mitt.mjs":
/*!*****************************************!*\
  !*** ./node_modules/mitt/dist/mitt.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}
//# sourceMappingURL=mitt.mjs.map


/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   connectBidiOverCdp: () => (/* binding */ connectBidiOverCdp)
/* harmony export */ });
/* harmony import */ var chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js");
/* harmony import */ var _common_Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */




const bidiServerLogger = (prefix, ...args) => {
    (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)(`bidi:${prefix}`)(args);
};
/**
 * @internal
 */
async function connectBidiOverCdp(cdp) {
    const transportBiDi = new NoOpTransport();
    const cdpConnectionAdapter = new CdpConnectionAdapter(cdp);
    const pptrTransport = {
        send(message) {
            // Forwards a BiDi command sent by Puppeteer to the input of the BidiServer.
            transportBiDi.emitMessage(JSON.parse(message));
        },
        close() {
            bidiServer.close();
            cdpConnectionAdapter.close();
            cdp.dispose();
        },
        onmessage(_message) {
            // The method is overridden by the Connection.
        },
    };
    transportBiDi.on('bidiResponse', (message) => {
        // Forwards a BiDi event sent by BidiServer to Puppeteer.
        pptrTransport.onmessage(JSON.stringify(message));
    });
    const pptrBiDiConnection = new _Connection_js__WEBPACK_IMPORTED_MODULE_3__.BidiConnection(cdp.url(), pptrTransport, cdp.delay, cdp.timeout);
    const bidiServer = await chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.BidiServer.createAndStart(transportBiDi, cdpConnectionAdapter, cdpConnectionAdapter.browserClient(), 
    /* selfTargetId= */ '', undefined, bidiServerLogger);
    return pptrBiDiConnection;
}
/**
 * Manages CDPSessions for BidiServer.
 * @internal
 */
class CdpConnectionAdapter {
    #cdp;
    #adapters = new Map();
    #browserCdpConnection;
    constructor(cdp) {
        this.#cdp = cdp;
        this.#browserCdpConnection = new CDPClientAdapter(cdp);
    }
    browserClient() {
        return this.#browserCdpConnection;
    }
    getCdpClient(id) {
        const session = this.#cdp.session(id);
        if (!session) {
            throw new Error(`Unknown CDP session with id ${id}`);
        }
        if (!this.#adapters.has(session)) {
            const adapter = new CDPClientAdapter(session, id, this.#browserCdpConnection);
            this.#adapters.set(session, adapter);
            return adapter;
        }
        return this.#adapters.get(session);
    }
    close() {
        this.#browserCdpConnection.close();
        for (const adapter of this.#adapters.values()) {
            adapter.close();
        }
    }
}
/**
 * Wrapper on top of CDPSession/CDPConnection to satisfy CDP interface that
 * BidiServer needs.
 *
 * @internal
 */
class CDPClientAdapter extends chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #closed = false;
    #client;
    sessionId = undefined;
    #browserClient;
    constructor(client, sessionId, browserClient) {
        super();
        this.#client = client;
        this.sessionId = sessionId;
        this.#browserClient = browserClient;
        this.#client.on('*', this.#forwardMessage);
    }
    browserClient() {
        return this.#browserClient;
    }
    #forwardMessage = (method, event) => {
        this.emit(method, event);
    };
    async sendCommand(method, ...params) {
        if (this.#closed) {
            return;
        }
        try {
            return await this.#client.send(method, ...params);
        }
        catch (err) {
            if (this.#closed) {
                return;
            }
            throw err;
        }
    }
    close() {
        this.#client.off('*', this.#forwardMessage);
        this.#closed = true;
    }
    isCloseError(error) {
        return error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_2__.TargetCloseError;
    }
}
/**
 * This transport is given to the BiDi server instance and allows Puppeteer
 * to send and receive commands to the BiDiServer.
 * @internal
 */
class NoOpTransport extends chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #onMessage = async (_m) => {
        return;
    };
    emitMessage(message) {
        void this.#onMessage(message);
    }
    setOnMessage(onMessage) {
        this.#onMessage = onMessage;
    }
    async sendMessage(message) {
        this.emit('bidiResponse', message);
    }
    close() {
        this.#onMessage = async (_m) => {
            return;
        };
    }
}
//# sourceMappingURL=BidiOverCdp.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowser: () => (/* binding */ BidiBrowser)
/* harmony export */ });
/* harmony import */ var _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _BrowserContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js");
/* harmony import */ var _core_Session_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/Session.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js");
/* harmony import */ var _Target_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};







/**
 * @internal
 */
let BidiBrowser = (() => {
    let _classSuper = _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.Browser;
    let _private_trustedEmitter_decorators;
    let _private_trustedEmitter_initializers = [];
    let _private_trustedEmitter_extraInitializers = [];
    let _private_trustedEmitter_descriptor;
    return class BidiBrowser extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _private_trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_3__.bubble)()];
            __esDecorate(this, _private_trustedEmitter_descriptor = { get: __setFunctionName(function () { return this.#trustedEmitter_accessor_storage; }, "#trustedEmitter", "get"), set: __setFunctionName(function (value) { this.#trustedEmitter_accessor_storage = value; }, "#trustedEmitter", "set") }, _private_trustedEmitter_decorators, { kind: "accessor", name: "#trustedEmitter", static: false, private: true, access: { has: obj => #trustedEmitter in obj, get: obj => obj.#trustedEmitter, set: (obj, value) => { obj.#trustedEmitter = value; } }, metadata: _metadata }, _private_trustedEmitter_initializers, _private_trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        protocol = 'webDriverBiDi';
        static subscribeModules = [
            'browsingContext',
            'network',
            'log',
            'script',
        ];
        static subscribeCdpEvents = [
            // Coverage
            'cdp.Debugger.scriptParsed',
            'cdp.CSS.styleSheetAdded',
            'cdp.Runtime.executionContextsCleared',
            // Tracing
            'cdp.Tracing.tracingComplete',
            // TODO: subscribe to all CDP events in the future.
            'cdp.Network.requestWillBeSent',
            'cdp.Debugger.scriptParsed',
            'cdp.Page.screencastFrame',
        ];
        static async create(opts) {
            const session = await _core_Session_js__WEBPACK_IMPORTED_MODULE_5__.Session.from(opts.connection, {
                firstMatch: opts.capabilities?.firstMatch,
                alwaysMatch: {
                    ...opts.capabilities?.alwaysMatch,
                    // Capabilities that come from Puppeteer's API take precedence.
                    acceptInsecureCerts: opts.acceptInsecureCerts,
                    unhandledPromptBehavior: {
                        default: "ignore" /* Bidi.Session.UserPromptHandlerType.Ignore */,
                    },
                    webSocketUrl: true,
                },
            });
            await session.subscribe(session.capabilities.browserName.toLocaleLowerCase().includes('firefox')
                ? BidiBrowser.subscribeModules
                : [...BidiBrowser.subscribeModules, ...BidiBrowser.subscribeCdpEvents]);
            const browser = new BidiBrowser(session.browser, opts);
            browser.#initialize();
            return browser;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _private_trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__.EventEmitter());
        get #trustedEmitter() { return _private_trustedEmitter_descriptor.get.call(this); }
        set #trustedEmitter(value) { return _private_trustedEmitter_descriptor.set.call(this, value); }
        #process = __runInitializers(this, _private_trustedEmitter_extraInitializers);
        #closeCallback;
        #browserCore;
        #defaultViewport;
        #browserContexts = new WeakMap();
        #target = new _Target_js__WEBPACK_IMPORTED_MODULE_6__.BidiBrowserTarget(this);
        #cdpConnection;
        constructor(browserCore, opts) {
            super();
            this.#process = opts.process;
            this.#closeCallback = opts.closeCallback;
            this.#browserCore = browserCore;
            this.#defaultViewport = opts.defaultViewport;
            this.#cdpConnection = opts.cdpConnection;
        }
        #initialize() {
            // Initializing existing contexts.
            for (const userContext of this.#browserCore.userContexts) {
                this.#createBrowserContext(userContext);
            }
            this.#browserCore.once('disconnected', () => {
                this.#trustedEmitter.emit("disconnected" /* BrowserEvent.Disconnected */, undefined);
                this.#trustedEmitter.removeAllListeners();
            });
            this.#process?.once('close', () => {
                this.#browserCore.dispose('Browser process exited.', true);
                this.connection.dispose();
            });
        }
        get #browserName() {
            return this.#browserCore.session.capabilities.browserName;
        }
        get #browserVersion() {
            return this.#browserCore.session.capabilities.browserVersion;
        }
        get cdpSupported() {
            return this.#cdpConnection !== undefined;
        }
        get cdpConnection() {
            return this.#cdpConnection;
        }
        async userAgent() {
            return this.#browserCore.session.capabilities.userAgent;
        }
        #createBrowserContext(userContext) {
            const browserContext = _BrowserContext_js__WEBPACK_IMPORTED_MODULE_4__.BidiBrowserContext.from(this, userContext, {
                defaultViewport: this.#defaultViewport,
            });
            this.#browserContexts.set(userContext, browserContext);
            browserContext.trustedEmitter.on("targetcreated" /* BrowserContextEvent.TargetCreated */, target => {
                this.#trustedEmitter.emit("targetcreated" /* BrowserEvent.TargetCreated */, target);
            });
            browserContext.trustedEmitter.on("targetchanged" /* BrowserContextEvent.TargetChanged */, target => {
                this.#trustedEmitter.emit("targetchanged" /* BrowserEvent.TargetChanged */, target);
            });
            browserContext.trustedEmitter.on("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target => {
                this.#trustedEmitter.emit("targetdestroyed" /* BrowserEvent.TargetDestroyed */, target);
            });
            return browserContext;
        }
        get connection() {
            // SAFETY: We only have one implementation.
            return this.#browserCore.session.connection;
        }
        wsEndpoint() {
            return this.connection.url;
        }
        async close() {
            if (this.connection.closed) {
                return;
            }
            try {
                await this.#browserCore.close();
                await this.#closeCallback?.call(null);
            }
            catch (error) {
                // Fail silently.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
            finally {
                this.connection.dispose();
            }
        }
        get connected() {
            return !this.#browserCore.disconnected;
        }
        process() {
            return this.#process ?? null;
        }
        async createBrowserContext(_options) {
            const userContext = await this.#browserCore.createUserContext();
            return this.#createBrowserContext(userContext);
        }
        async version() {
            return `${this.#browserName}/${this.#browserVersion}`;
        }
        browserContexts() {
            return [...this.#browserCore.userContexts].map(context => {
                return this.#browserContexts.get(context);
            });
        }
        defaultBrowserContext() {
            return this.#browserContexts.get(this.#browserCore.defaultUserContext);
        }
        newPage() {
            return this.defaultBrowserContext().newPage();
        }
        targets() {
            return [
                this.#target,
                ...this.browserContexts().flatMap(context => {
                    return context.targets();
                }),
            ];
        }
        target() {
            return this.#target;
        }
        async disconnect() {
            try {
                await this.#browserCore.session.end();
            }
            catch (error) {
                // Fail silently.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
            finally {
                this.connection.dispose();
            }
        }
        get debugInfo() {
            return {
                pendingProtocolErrors: this.connection.getPendingProtocolErrors(),
            };
        }
    };
})();

//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowserContext: () => (/* binding */ BidiBrowserContext)
/* harmony export */ });
/* harmony import */ var _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js");
/* harmony import */ var _api_BrowserContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _core_UserContext_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/UserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/* harmony import */ var _Target_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});










/**
 * @internal
 */
let BidiBrowserContext = (() => {
    let _classSuper = _api_BrowserContext_js__WEBPACK_IMPORTED_MODULE_1__.BrowserContext;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return class BidiBrowserContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_5__.bubble)()];
            __esDecorate(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: obj => "trustedEmitter" in obj, get: obj => obj.trustedEmitter, set: (obj, value) => { obj.trustedEmitter = value; } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browser, userContext, options) {
            const context = new BidiBrowserContext(browser, userContext, options);
            context.#initialize();
            return context;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter());
        get trustedEmitter() { return this.#trustedEmitter_accessor_storage; }
        set trustedEmitter(value) { this.#trustedEmitter_accessor_storage = value; }
        #browser = __runInitializers(this, _trustedEmitter_extraInitializers);
        #defaultViewport;
        // This is public because of cookies.
        userContext;
        #pages = new WeakMap();
        #targets = new Map();
        #overrides = [];
        constructor(browser, userContext, options) {
            super();
            this.#browser = browser;
            this.userContext = userContext;
            this.#defaultViewport = options.defaultViewport;
        }
        #initialize() {
            // Create targets for existing browsing contexts.
            for (const browsingContext of this.userContext.browsingContexts) {
                this.#createPage(browsingContext);
            }
            this.userContext.on('browsingcontext', ({ browsingContext }) => {
                const page = this.#createPage(browsingContext);
                // We need to wait for the DOMContentLoaded as the
                // browsingContext still may be navigating from the about:blank
                browsingContext.once('DOMContentLoaded', () => {
                    if (browsingContext.originalOpener) {
                        for (const context of this.userContext.browsingContexts) {
                            if (context.id === browsingContext.originalOpener) {
                                this.#pages
                                    .get(context)
                                    .trustedEmitter.emit("popup" /* PageEvent.Popup */, page);
                            }
                        }
                    }
                });
            });
            this.userContext.on('closed', () => {
                this.trustedEmitter.removeAllListeners();
            });
        }
        #createPage(browsingContext) {
            const page = _Page_js__WEBPACK_IMPORTED_MODULE_7__.BidiPage.from(this, browsingContext);
            this.#pages.set(browsingContext, page);
            page.trustedEmitter.on("close" /* PageEvent.Close */, () => {
                this.#pages.delete(browsingContext);
            });
            // -- Target stuff starts here --
            const pageTarget = new _Target_js__WEBPACK_IMPORTED_MODULE_8__.BidiPageTarget(page);
            const pageTargets = new Map();
            this.#targets.set(page, [pageTarget, pageTargets]);
            page.trustedEmitter.on("frameattached" /* PageEvent.FrameAttached */, frame => {
                const bidiFrame = frame;
                const target = new _Target_js__WEBPACK_IMPORTED_MODULE_8__.BidiFrameTarget(bidiFrame);
                pageTargets.set(bidiFrame, target);
                this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, target);
            });
            page.trustedEmitter.on("framenavigated" /* PageEvent.FrameNavigated */, frame => {
                const bidiFrame = frame;
                const target = pageTargets.get(bidiFrame);
                // If there is no target, then this is the page's frame.
                if (target === undefined) {
                    this.trustedEmitter.emit("targetchanged" /* BrowserContextEvent.TargetChanged */, pageTarget);
                }
                else {
                    this.trustedEmitter.emit("targetchanged" /* BrowserContextEvent.TargetChanged */, target);
                }
            });
            page.trustedEmitter.on("framedetached" /* PageEvent.FrameDetached */, frame => {
                const bidiFrame = frame;
                const target = pageTargets.get(bidiFrame);
                if (target === undefined) {
                    return;
                }
                pageTargets.delete(bidiFrame);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target);
            });
            page.trustedEmitter.on("workercreated" /* PageEvent.WorkerCreated */, worker => {
                const bidiWorker = worker;
                const target = new _Target_js__WEBPACK_IMPORTED_MODULE_8__.BidiWorkerTarget(bidiWorker);
                pageTargets.set(bidiWorker, target);
                this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, target);
            });
            page.trustedEmitter.on("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker => {
                const bidiWorker = worker;
                const target = pageTargets.get(bidiWorker);
                if (target === undefined) {
                    return;
                }
                pageTargets.delete(worker);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target);
            });
            page.trustedEmitter.on("close" /* PageEvent.Close */, () => {
                this.#targets.delete(page);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, pageTarget);
            });
            this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, pageTarget);
            // -- Target stuff ends here --
            return page;
        }
        targets() {
            return [...this.#targets.values()].flatMap(([target, frames]) => {
                return [target, ...frames.values()];
            });
        }
        async newPage() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const _guard = __addDisposableResource(env_1, await this.waitForScreenshotOperations(), false);
                const context = await this.userContext.createBrowsingContext("tab" /* Bidi.BrowsingContext.CreateType.Tab */);
                const page = this.#pages.get(context);
                if (!page) {
                    throw new Error('Page is not found');
                }
                if (this.#defaultViewport) {
                    try {
                        await page.setViewport(this.#defaultViewport);
                    }
                    catch {
                        // No support for setViewport in Firefox.
                    }
                }
                return page;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        async close() {
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.userContext.id !== _core_UserContext_js__WEBPACK_IMPORTED_MODULE_6__.UserContext.DEFAULT, 'Default BrowserContext cannot be closed!');
            try {
                await this.userContext.remove();
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError)(error);
            }
            this.#targets.clear();
        }
        browser() {
            return this.#browser;
        }
        async pages() {
            return [...this.userContext.browsingContexts].map(context => {
                return this.#pages.get(context);
            });
        }
        async overridePermissions(origin, permissions) {
            const permissionsSet = new Set(permissions.map(permission => {
                const protocolPermission = _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
                if (!protocolPermission) {
                    throw new Error('Unknown permission: ' + permission);
                }
                return permission;
            }));
            await Promise.all(Array.from(_api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.keys()).map(permission => {
                const result = this.userContext.setPermissions(origin, {
                    name: permission,
                }, permissionsSet.has(permission)
                    ? "granted" /* Bidi.Permissions.PermissionState.Granted */
                    : "denied" /* Bidi.Permissions.PermissionState.Denied */);
                this.#overrides.push({ origin, permission });
                // TODO: some permissions are outdated and setting them to denied does
                // not work.
                if (!permissionsSet.has(permission)) {
                    return result.catch(_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError);
                }
                return result;
            }));
        }
        async clearPermissionOverrides() {
            const promises = this.#overrides.map(({ permission, origin }) => {
                return this.userContext
                    .setPermissions(origin, {
                    name: permission,
                }, "prompt" /* Bidi.Permissions.PermissionState.Prompt */)
                    .catch(_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError);
            });
            this.#overrides = [];
            await Promise.all(promises);
        }
        get id() {
            if (this.userContext.id === _core_UserContext_js__WEBPACK_IMPORTED_MODULE_6__.UserContext.DEFAULT) {
                return undefined;
            }
            return this.userContext.id;
        }
    };
})();

//# sourceMappingURL=BrowserContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiCdpSession: () => (/* binding */ BidiCdpSession)
/* harmony export */ });
/* harmony import */ var _api_CDPSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _util_Deferred_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Deferred.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js");



/**
 * @internal
 */
class BidiCdpSession extends _api_CDPSession_js__WEBPACK_IMPORTED_MODULE_0__.CDPSession {
    static sessions = new Map();
    #detached = false;
    #connection;
    #sessionId = _util_Deferred_js__WEBPACK_IMPORTED_MODULE_2__.Deferred.create();
    frame;
    constructor(frame, sessionId) {
        super();
        this.frame = frame;
        if (!this.frame.page().browser().cdpSupported) {
            return;
        }
        const connection = this.frame.page().browser().connection;
        this.#connection = connection;
        if (sessionId) {
            this.#sessionId.resolve(sessionId);
            BidiCdpSession.sessions.set(sessionId, this);
        }
        else {
            (async () => {
                try {
                    const { result } = await connection.send('cdp.getSession', {
                        context: frame._id,
                    });
                    this.#sessionId.resolve(result.session);
                    BidiCdpSession.sessions.set(result.session, this);
                }
                catch (error) {
                    this.#sessionId.reject(error);
                }
            })();
        }
        // SAFETY: We never throw #sessionId.
        BidiCdpSession.sessions.set(this.#sessionId.value(), this);
    }
    connection() {
        return undefined;
    }
    async send(method, params, options) {
        if (this.#connection === undefined) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation('CDP support is required for this feature. The current browser does not support CDP.');
        }
        if (this.#detached) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
        }
        const session = await this.#sessionId.valueOrThrow();
        const { result } = await this.#connection.send('cdp.sendCommand', {
            method: method,
            params: params,
            session,
        }, options?.timeout);
        return result.result;
    }
    async detach() {
        if (this.#connection === undefined ||
            this.#connection.closed ||
            this.#detached) {
            return;
        }
        try {
            await this.frame.client.send('Target.detachFromTarget', {
                sessionId: this.id(),
            });
        }
        finally {
            this.onClose();
        }
    }
    /**
     * @internal
     */
    onClose = () => {
        BidiCdpSession.sessions.delete(this.id());
        this.#detached = true;
    };
    id() {
        const value = this.#sessionId.value();
        return typeof value === 'string' ? value : '';
    }
}
//# sourceMappingURL=CDPSession.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiConnection: () => (/* binding */ BidiConnection)
/* harmony export */ });
/* harmony import */ var _common_CallbackRegistry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/CallbackRegistry.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js");
/* harmony import */ var _common_Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _CDPSession_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */






const debugProtocolSend = (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:webDriverBiDi:SEND ');
const debugProtocolReceive = (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:webDriverBiDi:RECV ');
/**
 * @internal
 */
class BidiConnection extends _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
    #url;
    #transport;
    #delay;
    #timeout = 0;
    #closed = false;
    #callbacks = new _common_CallbackRegistry_js__WEBPACK_IMPORTED_MODULE_0__.CallbackRegistry();
    #emitters = [];
    constructor(url, transport, delay = 0, timeout) {
        super();
        this.#url = url;
        this.#delay = delay;
        this.#timeout = timeout ?? 180_000;
        this.#transport = transport;
        this.#transport.onmessage = this.onMessage.bind(this);
        this.#transport.onclose = this.unbind.bind(this);
    }
    get closed() {
        return this.#closed;
    }
    get url() {
        return this.#url;
    }
    pipeTo(emitter) {
        this.#emitters.push(emitter);
    }
    emit(type, event) {
        for (const emitter of this.#emitters) {
            emitter.emit(type, event);
        }
        return super.emit(type, event);
    }
    send(method, params, timeout) {
        (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.#closed, 'Protocol error: Connection closed.');
        return this.#callbacks.create(method, timeout ?? this.#timeout, id => {
            const stringifiedMessage = JSON.stringify({
                id,
                method,
                params,
            });
            debugProtocolSend(stringifiedMessage);
            this.#transport.send(stringifiedMessage);
        });
    }
    /**
     * @internal
     */
    async onMessage(message) {
        if (this.#delay) {
            await new Promise(f => {
                return setTimeout(f, this.#delay);
            });
        }
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if ('type' in object) {
            switch (object.type) {
                case 'success':
                    this.#callbacks.resolve(object.id, object);
                    return;
                case 'error':
                    if (object.id === null) {
                        break;
                    }
                    this.#callbacks.reject(object.id, createProtocolError(object), `${object.error}: ${object.message}`);
                    return;
                case 'event':
                    if (isCdpEvent(object)) {
                        _CDPSession_js__WEBPACK_IMPORTED_MODULE_5__.BidiCdpSession.sessions
                            .get(object.params.session)
                            ?.emit(object.params.event, object.params.params);
                        return;
                    }
                    // SAFETY: We know the method and parameter still match here.
                    this.emit(object.method, object.params);
                    return;
            }
        }
        // Even if the response in not in BiDi protocol format but `id` is provided, reject
        // the callback. This can happen if the endpoint supports CDP instead of BiDi.
        if ('id' in object) {
            this.#callbacks.reject(object.id, `Protocol Error. Message is not in BiDi protocol format: '${message}'`, object.message);
        }
        (0,_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError)(object);
    }
    /**
     * Unbinds the connection, but keeps the transport open. Useful when the transport will
     * be reused by other connection e.g. with different protocol.
     * @internal
     */
    unbind() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        // Both may still be invoked and produce errors
        this.#transport.onmessage = () => { };
        this.#transport.onclose = () => { };
        this.#callbacks.clear();
    }
    /**
     * Unbinds the connection and closes the transport.
     */
    dispose() {
        this.unbind();
        this.#transport.close();
    }
    getPendingProtocolErrors() {
        return this.#callbacks.getPendingProtocolErrors();
    }
}
/**
 * @internal
 */
function createProtocolError(object) {
    let message = `${object.error} ${object.message}`;
    if (object.stacktrace) {
        message += ` ${object.stacktrace}`;
    }
    return message;
}
function isCdpEvent(event) {
    return event.method.startsWith('cdp.');
}
//# sourceMappingURL=Connection.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiDeserializer: () => (/* binding */ BidiDeserializer)
/* harmony export */ });
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @internal
 */
class BidiDeserializer {
    static deserialize(result) {
        if (!result) {
            (0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.debugError)('Service did not produce a result.');
            return undefined;
        }
        switch (result.type) {
            case 'array':
                return result.value?.map(value => {
                    return this.deserialize(value);
                });
            case 'set':
                return result.value?.reduce((acc, value) => {
                    return acc.add(this.deserialize(value));
                }, new Set());
            case 'object':
                return result.value?.reduce((acc, tuple) => {
                    const { key, value } = this.#deserializeTuple(tuple);
                    acc[key] = value;
                    return acc;
                }, {});
            case 'map':
                return result.value?.reduce((acc, tuple) => {
                    const { key, value } = this.#deserializeTuple(tuple);
                    return acc.set(key, value);
                }, new Map());
            case 'promise':
                return {};
            case 'regexp':
                return new RegExp(result.value.pattern, result.value.flags);
            case 'date':
                return new Date(result.value);
            case 'undefined':
                return undefined;
            case 'null':
                return null;
            case 'number':
                return this.#deserializeNumber(result.value);
            case 'bigint':
                return BigInt(result.value);
            case 'boolean':
                return Boolean(result.value);
            case 'string':
                return result.value;
        }
        (0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.debugError)(`Deserialization of type ${result.type} not supported.`);
        return undefined;
    }
    static #deserializeNumber(value) {
        switch (value) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                return value;
        }
    }
    static #deserializeTuple([serializedKey, serializedValue]) {
        const key = typeof serializedKey === 'string'
            ? serializedKey
            : this.deserialize(serializedKey);
        const value = this.deserialize(serializedValue);
        return { key, value };
    }
}
//# sourceMappingURL=Deserializer.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiDialog: () => (/* binding */ BidiDialog)
/* harmony export */ });
/* harmony import */ var _api_Dialog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Dialog.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

class BidiDialog extends _api_Dialog_js__WEBPACK_IMPORTED_MODULE_0__.Dialog {
    static from(prompt) {
        return new BidiDialog(prompt);
    }
    #prompt;
    constructor(prompt) {
        super(prompt.info.type, prompt.info.message, prompt.info.defaultValue);
        this.#prompt = prompt;
        this.handled = prompt.handled;
    }
    async handle(options) {
        await this.#prompt.handle({
            accept: options.accept,
            userText: options.text,
        });
    }
}
//# sourceMappingURL=Dialog.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiElementHandle: () => (/* binding */ BidiElementHandle)
/* harmony export */ });
/* harmony import */ var _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/* harmony import */ var _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/AsyncIterableUtil.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});





/**
 * @internal
 */
let BidiElementHandle = (() => {
    var _a;
    let _classSuper = _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__.ElementHandle;
    let _instanceExtraInitializers = [];
    let _autofill_decorators;
    let _contentFrame_decorators;
    return class BidiElementHandle extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _autofill_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_3__.throwIfDisposed)()];
            _contentFrame_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_3__.throwIfDisposed)(), (_a = _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__.ElementHandle).bindIsolatedHandle.bind(_a)];
            __esDecorate(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: obj => "autofill" in obj, get: obj => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: obj => "contentFrame" in obj, get: obj => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(value, realm) {
            return new BidiElementHandle(value, realm);
        }
        constructor(value, realm) {
            super(_JSHandle_js__WEBPACK_IMPORTED_MODULE_4__.BidiJSHandle.from(value, realm));
            __runInitializers(this, _instanceExtraInitializers);
        }
        get realm() {
            // SAFETY: See the super call in the constructor.
            return this.handle.realm;
        }
        get frame() {
            return this.realm.environment;
        }
        remoteValue() {
            return this.handle.remoteValue();
        }
        async autofill(data) {
            const client = this.frame.client;
            const nodeInfo = await client.send('DOM.describeNode', {
                objectId: this.handle.id,
            });
            const fieldId = nodeInfo.node.backendNodeId;
            const frameId = this.frame._id;
            await client.send('Autofill.trigger', {
                fieldId,
                frameId,
                card: data.creditCard,
            });
        }
        async contentFrame() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource(env_1, (await this.evaluateHandle(element => {
                    if (element instanceof HTMLIFrameElement ||
                        element instanceof HTMLFrameElement) {
                        return element.contentWindow;
                    }
                    return;
                })), false);
                const value = handle.remoteValue();
                if (value.type === 'window') {
                    return (this.frame
                        .page()
                        .frames()
                        .find(frame => {
                        return frame._id === value.value.context;
                    }) ?? null);
                }
                return null;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        async uploadFile(...files) {
            // Locate all files and confirm that they exist.
            const path = _environment_js__WEBPACK_IMPORTED_MODULE_1__.environment.value.path;
            files = files.map(file => {
                if (path.win32.isAbsolute(file) || path.posix.isAbsolute(file)) {
                    return file;
                }
                else {
                    return path.resolve(file);
                }
            });
            await this.frame.setFiles(this, files);
        }
        async *queryAXTree(name, role) {
            const results = await this.frame.locateNodes(this, {
                type: 'accessibility',
                value: {
                    role,
                    name,
                },
            });
            return yield* _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_2__.AsyncIterableUtil.map(results, node => {
                // TODO: maybe change ownership since the default ownership is probably none.
                return Promise.resolve(BidiElementHandle.from(node, this.realm));
            });
        }
    };
})();

//# sourceMappingURL=ElementHandle.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExposeableFunction: () => (/* binding */ ExposeableFunction)
/* harmony export */ });
/* harmony import */ var chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chromium-bidi/lib/cjs/protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _util_Function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Function.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});







/**
 * @internal
 */
class ExposeableFunction {
    static async from(frame, name, apply, isolate = false) {
        const func = new ExposeableFunction(frame, name, apply, isolate);
        await func.#initialize();
        return func;
    }
    #frame;
    name;
    #apply;
    #isolate;
    #channel;
    #scripts = [];
    #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack();
    constructor(frame, name, apply, isolate = false) {
        this.#frame = frame;
        this.name = name;
        this.#apply = apply;
        this.#isolate = isolate;
        this.#channel = `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}`;
    }
    async #initialize() {
        const connection = this.#connection;
        const channel = {
            type: 'channel',
            value: {
                channel: this.#channel,
                ownership: "root" /* Bidi.Script.ResultOwnership.Root */,
            },
        };
        const connectionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__.EventEmitter(connection));
        connectionEmitter.on(chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__.ChromiumBidi.Script.EventNames.Message, this.#handleMessage);
        const functionDeclaration = (0,_util_Function_js__WEBPACK_IMPORTED_MODULE_4__.stringifyFunction)((0,_util_Function_js__WEBPACK_IMPORTED_MODULE_4__.interpolateFunction)((callback) => {
            Object.assign(globalThis, {
                [PLACEHOLDER('name')]: function (...args) {
                    return new Promise((resolve, reject) => {
                        callback([resolve, reject, args]);
                    });
                },
            });
        }, { name: JSON.stringify(this.name) }));
        const frames = [this.#frame];
        for (const frame of frames) {
            frames.push(...frame.childFrames());
        }
        await Promise.all(frames.map(async (frame) => {
            const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
            try {
                const [script] = await Promise.all([
                    frame.browsingContext.addPreloadScript(functionDeclaration, {
                        arguments: [channel],
                        sandbox: realm.sandbox,
                    }),
                    realm.realm.callFunction(functionDeclaration, false, {
                        arguments: [channel],
                    }),
                ]);
                this.#scripts.push([frame, script]);
            }
            catch (error) {
                // If it errors, the frame probably doesn't support call function. We
                // fail gracefully.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }));
    }
    get #connection() {
        return this.#frame.page().browser().connection;
    }
    #handleMessage = async (params) => {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            if (params.channel !== this.#channel) {
                return;
            }
            const realm = this.#getRealm(params.source);
            if (!realm) {
                // Unrelated message.
                return;
            }
            const dataHandle = __addDisposableResource(env_1, _JSHandle_js__WEBPACK_IMPORTED_MODULE_6__.BidiJSHandle.from(params.data, realm), false);
            const argsHandle = __addDisposableResource(env_1, await dataHandle.evaluateHandle(([, , args]) => {
                return args;
            }), false);
            const stack = __addDisposableResource(env_1, new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack(), false);
            const args = [];
            for (const [index, handle] of await argsHandle.getProperties()) {
                stack.use(handle);
                // Element handles are passed as is.
                if (handle instanceof _ElementHandle_js__WEBPACK_IMPORTED_MODULE_5__.BidiElementHandle) {
                    args[+index] = handle;
                    stack.use(handle);
                    continue;
                }
                // Everything else is passed as the JS value.
                args[+index] = handle.jsonValue();
            }
            let result;
            try {
                result = await this.#apply(...(await Promise.all(args)));
            }
            catch (error) {
                try {
                    if (error instanceof Error) {
                        await dataHandle.evaluate(([, reject], name, message, stack) => {
                            const error = new Error(message);
                            error.name = name;
                            if (stack) {
                                error.stack = stack;
                            }
                            reject(error);
                        }, error.name, error.message, error.stack);
                    }
                    else {
                        await dataHandle.evaluate(([, reject], error) => {
                            reject(error);
                        }, error);
                    }
                }
                catch (error) {
                    (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
                }
                return;
            }
            try {
                await dataHandle.evaluate(([resolve], result) => {
                    resolve(result);
                }, result);
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    };
    #getRealm(source) {
        const frame = this.#findFrame(source.context);
        if (!frame) {
            // Unrelated message.
            return;
        }
        return frame.realm(source.realm);
    }
    #findFrame(id) {
        const frames = [this.#frame];
        for (const frame of frames) {
            if (frame._id === id) {
                return frame;
            }
            frames.push(...frame.childFrames());
        }
        return;
    }
    [Symbol.dispose]() {
        void this[Symbol.asyncDispose]().catch(_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError);
    }
    async [Symbol.asyncDispose]() {
        this.#disposables.dispose();
        await Promise.all(this.#scripts.map(async ([frame, script]) => {
            const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
            try {
                await Promise.all([
                    realm.evaluate(name => {
                        delete globalThis[name];
                    }, this.name),
                    ...frame.childFrames().map(childFrame => {
                        return childFrame.evaluate(name => {
                            delete globalThis[name];
                        }, this.name);
                    }),
                    frame.browsingContext.removePreloadScript(script),
                ]);
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }));
    }
}
//# sourceMappingURL=ExposedFunction.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiFrame: () => (/* binding */ BidiFrame)
/* harmony export */ });
/* harmony import */ var _third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../third_party/rxjs/rxjs.js */ "./node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js");
/* harmony import */ var _api_Frame_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js");
/* harmony import */ var _cdp_Accessibility_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cdp/Accessibility.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js");
/* harmony import */ var _common_ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/ConsoleMessage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/ErrorLike.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js");
/* harmony import */ var _CDPSession_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/* harmony import */ var _Dialog_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Dialog.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js");
/* harmony import */ var _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ExposedFunction.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js");
/* harmony import */ var _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
/* harmony import */ var _WebWorker_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
















// TODO: Remove this and map CDP the correct method.
// Requires breaking change.
function convertConsoleMessageLevel(method) {
    switch (method) {
        case 'group':
            return 'startGroup';
        case 'groupCollapsed':
            return 'startGroupCollapsed';
        case 'groupEnd':
            return 'endGroup';
        default:
            return method;
    }
}
let BidiFrame = (() => {
    var _a;
    let _classSuper = _api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _setContent_decorators;
    let _waitForNavigation_decorators;
    let _private_waitForLoad$_decorators;
    let _private_waitForLoad$_descriptor;
    let _private_waitForNetworkIdle$_decorators;
    let _private_waitForNetworkIdle$_descriptor;
    let _setFiles_decorators;
    let _locateNodes_decorators;
    return class BidiFrame extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _goto_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _setContent_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _waitForNavigation_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _private_waitForLoad$_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _private_waitForNetworkIdle$_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _setFiles_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            _locateNodes_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDetached];
            __esDecorate(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: obj => "goto" in obj, get: obj => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: obj => "setContent" in obj, get: obj => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: obj => "waitForNavigation" in obj, get: obj => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_waitForLoad$_descriptor = { value: __setFunctionName(function (options = {}) {
                    let { waitUntil = 'load' } = options;
                    const { timeout: ms = this.timeoutSettings.navigationTimeout() } = options;
                    if (!Array.isArray(waitUntil)) {
                        waitUntil = [waitUntil];
                    }
                    const events = new Set();
                    for (const lifecycleEvent of waitUntil) {
                        switch (lifecycleEvent) {
                            case 'load': {
                                events.add('load');
                                break;
                            }
                            case 'domcontentloaded': {
                                events.add('DOMContentLoaded');
                                break;
                            }
                        }
                    }
                    if (events.size === 0) {
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(undefined);
                    }
                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.combineLatest)([...events].map(event => {
                        return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(this.browsingContext, event);
                    })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.map)(() => { }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.first)(), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.timeout)(ms), this.#detached$().pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.map)(() => {
                        throw new Error('Frame detached.');
                    }))));
                }, "#waitForLoad$") }, _private_waitForLoad$_decorators, { kind: "method", name: "#waitForLoad$", static: false, private: true, access: { has: obj => #waitForLoad$ in obj, get: obj => obj.#waitForLoad$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_waitForNetworkIdle$_descriptor = { value: __setFunctionName(function (options = {}) {
                    let { waitUntil = 'load' } = options;
                    if (!Array.isArray(waitUntil)) {
                        waitUntil = [waitUntil];
                    }
                    let concurrency = Infinity;
                    for (const event of waitUntil) {
                        switch (event) {
                            case 'networkidle0': {
                                concurrency = Math.min(0, concurrency);
                                break;
                            }
                            case 'networkidle2': {
                                concurrency = Math.min(2, concurrency);
                                break;
                            }
                        }
                    }
                    if (concurrency === Infinity) {
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(undefined);
                    }
                    return this.page().waitForNetworkIdle$({
                        idleTime: 500,
                        timeout: options.timeout ?? this.timeoutSettings.timeout(),
                        concurrency,
                    });
                }, "#waitForNetworkIdle$") }, _private_waitForNetworkIdle$_decorators, { kind: "method", name: "#waitForNetworkIdle$", static: false, private: true, access: { has: obj => #waitForNetworkIdle$ in obj, get: obj => obj.#waitForNetworkIdle$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: obj => "setFiles" in obj, get: obj => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: obj => "locateNodes" in obj, get: obj => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(parent, browsingContext) {
            const frame = new BidiFrame(parent, browsingContext);
            frame.#initialize();
            return frame;
        }
        #parent = __runInitializers(this, _instanceExtraInitializers);
        browsingContext;
        #frames = new WeakMap();
        realms;
        _id;
        client;
        accessibility;
        constructor(parent, browsingContext) {
            super();
            this.#parent = parent;
            this.browsingContext = browsingContext;
            this._id = browsingContext.id;
            this.client = new _CDPSession_js__WEBPACK_IMPORTED_MODULE_7__.BidiCdpSession(this);
            this.realms = {
                default: _Realm_js__WEBPACK_IMPORTED_MODULE_13__.BidiFrameRealm.from(this.browsingContext.defaultRealm, this),
                internal: _Realm_js__WEBPACK_IMPORTED_MODULE_13__.BidiFrameRealm.from(this.browsingContext.createWindowRealm(`__puppeteer_internal_${Math.ceil(Math.random() * 10000)}`), this),
            };
            this.accessibility = new _cdp_Accessibility_js__WEBPACK_IMPORTED_MODULE_2__.Accessibility(this.realms.default);
        }
        #initialize() {
            for (const browsingContext of this.browsingContext.children) {
                this.#createFrameTarget(browsingContext);
            }
            this.browsingContext.on('browsingcontext', ({ browsingContext }) => {
                this.#createFrameTarget(browsingContext);
            });
            this.browsingContext.on('closed', () => {
                for (const session of _CDPSession_js__WEBPACK_IMPORTED_MODULE_7__.BidiCdpSession.sessions.values()) {
                    if (session.frame === this) {
                        session.onClose();
                    }
                }
                this.page().trustedEmitter.emit("framedetached" /* PageEvent.FrameDetached */, this);
            });
            this.browsingContext.on('request', ({ request }) => {
                const httpRequest = _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_11__.BidiHTTPRequest.from(request, this);
                request.once('success', () => {
                    this.page().trustedEmitter.emit("requestfinished" /* PageEvent.RequestFinished */, httpRequest);
                });
                request.once('error', () => {
                    this.page().trustedEmitter.emit("requestfailed" /* PageEvent.RequestFailed */, httpRequest);
                });
                void httpRequest.finalizeInterceptions();
            });
            this.browsingContext.on('navigation', ({ navigation }) => {
                navigation.once('fragment', () => {
                    this.page().trustedEmitter.emit("framenavigated" /* PageEvent.FrameNavigated */, this);
                });
            });
            this.browsingContext.on('load', () => {
                this.page().trustedEmitter.emit("load" /* PageEvent.Load */, undefined);
            });
            this.browsingContext.on('DOMContentLoaded', () => {
                this._hasStartedLoading = true;
                this.page().trustedEmitter.emit("domcontentloaded" /* PageEvent.DOMContentLoaded */, undefined);
                this.page().trustedEmitter.emit("framenavigated" /* PageEvent.FrameNavigated */, this);
            });
            this.browsingContext.on('userprompt', ({ userPrompt }) => {
                this.page().trustedEmitter.emit("dialog" /* PageEvent.Dialog */, _Dialog_js__WEBPACK_IMPORTED_MODULE_9__.BidiDialog.from(userPrompt));
            });
            this.browsingContext.on('log', ({ entry }) => {
                if (this._id !== entry.source.context) {
                    return;
                }
                if (isConsoleLogEntry(entry)) {
                    const args = entry.args.map(arg => {
                        return this.mainRealm().createHandle(arg);
                    });
                    const text = args
                        .reduce((value, arg) => {
                        const parsedValue = arg instanceof _JSHandle_js__WEBPACK_IMPORTED_MODULE_12__.BidiJSHandle && arg.isPrimitiveValue
                            ? _Deserializer_js__WEBPACK_IMPORTED_MODULE_8__.BidiDeserializer.deserialize(arg.remoteValue())
                            : arg.toString();
                        return `${value} ${parsedValue}`;
                    }, '')
                        .slice(1);
                    this.page().trustedEmitter.emit("console" /* PageEvent.Console */, new _common_ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_3__.ConsoleMessage(convertConsoleMessageLevel(entry.method), text, args, getStackTraceLocations(entry.stackTrace)));
                }
                else if (isJavaScriptLogEntry(entry)) {
                    const error = new Error(entry.text ?? '');
                    const messageHeight = error.message.split('\n').length;
                    const messageLines = error.stack.split('\n').splice(0, messageHeight);
                    const stackLines = [];
                    if (entry.stackTrace) {
                        for (const frame of entry.stackTrace.callFrames) {
                            // Note we need to add `1` because the values are 0-indexed.
                            stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
                            if (stackLines.length >= Error.stackTraceLimit) {
                                break;
                            }
                        }
                    }
                    error.stack = [...messageLines, ...stackLines].join('\n');
                    this.page().trustedEmitter.emit("pageerror" /* PageEvent.PageError */, error);
                }
                else {
                    (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.debugError)(`Unhandled LogEntry with type "${entry.type}", text "${entry.text}" and level "${entry.level}"`);
                }
            });
            this.browsingContext.on('worker', ({ realm }) => {
                const worker = _WebWorker_js__WEBPACK_IMPORTED_MODULE_15__.BidiWebWorker.from(this, realm);
                realm.on('destroyed', () => {
                    this.page().trustedEmitter.emit("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker);
                });
                this.page().trustedEmitter.emit("workercreated" /* PageEvent.WorkerCreated */, worker);
            });
        }
        #createFrameTarget(browsingContext) {
            const frame = BidiFrame.from(this, browsingContext);
            this.#frames.set(browsingContext, frame);
            this.page().trustedEmitter.emit("frameattached" /* PageEvent.FrameAttached */, frame);
            browsingContext.on('closed', () => {
                this.#frames.delete(browsingContext);
            });
            return frame;
        }
        get timeoutSettings() {
            return this.page()._timeoutSettings;
        }
        mainRealm() {
            return this.realms.default;
        }
        isolatedRealm() {
            return this.realms.internal;
        }
        realm(id) {
            for (const realm of Object.values(this.realms)) {
                if (realm.realm.id === id) {
                    return realm;
                }
            }
            return;
        }
        page() {
            let parent = this.#parent;
            while (parent instanceof BidiFrame) {
                parent = parent.#parent;
            }
            return parent;
        }
        url() {
            return this.browsingContext.url;
        }
        parentFrame() {
            if (this.#parent instanceof BidiFrame) {
                return this.#parent;
            }
            return null;
        }
        childFrames() {
            return [...this.browsingContext.children].map(child => {
                return this.#frames.get(child);
            });
        }
        #detached$() {
            return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.defer)(() => {
                if (this.detached) {
                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(this);
                }
                return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(this.page().trustedEmitter, "framedetached" /* PageEvent.FrameDetached */).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.filter)(detachedFrame => {
                    return detachedFrame === this;
                }));
            });
        }
        async goto(url, options = {}) {
            const [response] = await Promise.all([
                this.waitForNavigation(options),
                // Some implementations currently only report errors when the
                // readiness=interactive.
                //
                // Related: https://bugzilla.mozilla.org/show_bug.cgi?id=1846601
                this.browsingContext
                    .navigate(url, "interactive" /* Bidi.BrowsingContext.ReadinessState.Interactive */)
                    .catch(error => {
                    if ((0,_util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_6__.isErrorLike)(error) &&
                        error.message.includes('net::ERR_HTTP_RESPONSE_CODE_FAILURE')) {
                        return;
                    }
                    throw error;
                }),
            ]).catch((0,_util_js__WEBPACK_IMPORTED_MODULE_14__.rewriteNavigationError)(url, options.timeout ?? this.timeoutSettings.navigationTimeout()));
            return response;
        }
        async setContent(html, options = {}) {
            await Promise.all([
                this.setFrameContent(html),
                (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.combineLatest)([
                    this.#waitForLoad$(options),
                    this.#waitForNetworkIdle$(options),
                ])),
            ]);
        }
        async waitForNavigation(options = {}) {
            const { timeout: ms = this.timeoutSettings.navigationTimeout(), signal } = options;
            const frames = this.childFrames().map(frame => {
                return frame.#detached$();
            });
            return await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.combineLatest)([
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(this.browsingContext, 'navigation')
                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.first)())
                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.switchMap)(({ navigation }) => {
                    return this.#waitForLoad$(options).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.delayWhen)(() => {
                        if (frames.length === 0) {
                            return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(undefined);
                        }
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.combineLatest)(frames);
                    }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(navigation, 'fragment'), (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(navigation, 'failed'), (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(navigation, 'aborted').pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.map)(({ url }) => {
                        throw new Error(`Navigation aborted: ${url}`);
                    }))), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => {
                        if (navigation.request) {
                            function requestFinished$(request) {
                                // Reduces flakiness if the response events arrive after
                                // the load event.
                                // Usually, the response or error is already there at this point.
                                if (request.response || request.error) {
                                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(navigation);
                                }
                                if (request.redirect) {
                                    return requestFinished$(request.redirect);
                                }
                                return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(request, 'success')
                                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(request, 'error')), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromEmitterEvent)(request, 'redirect')))
                                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => {
                                    return requestFinished$(request);
                                }));
                            }
                            return requestFinished$(navigation.request);
                        }
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.of)(navigation);
                    }));
                })),
                this.#waitForNetworkIdle$(options),
            ]).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.map)(([navigation]) => {
                const request = navigation.request;
                if (!request) {
                    return null;
                }
                const lastRequest = request.lastRedirect ?? request;
                const httpRequest = _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_11__.requests.get(lastRequest);
                return httpRequest.response();
            }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.timeout)(ms), (0,_common_util_js__WEBPACK_IMPORTED_MODULE_5__.fromAbortSignal)(signal), this.#detached$().pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.map)(() => {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_4__.TargetCloseError('Frame detached.');
            })))));
        }
        waitForDevicePrompt() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_4__.UnsupportedOperation();
        }
        get detached() {
            return this.browsingContext.closed;
        }
        #exposedFunctions = new Map();
        async exposeFunction(name, apply) {
            if (this.#exposedFunctions.has(name)) {
                throw new Error(`Failed to add page binding with name ${name}: globalThis['${name}'] already exists!`);
            }
            const exposeable = await _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_10__.ExposeableFunction.from(this, name, apply);
            this.#exposedFunctions.set(name, exposeable);
        }
        async removeExposedFunction(name) {
            const exposedFunction = this.#exposedFunctions.get(name);
            if (!exposedFunction) {
                throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);
            }
            this.#exposedFunctions.delete(name);
            await exposedFunction[Symbol.asyncDispose]();
        }
        async createCDPSession() {
            if (!this.page().browser().cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_4__.UnsupportedOperation();
            }
            const cdpConnection = this.page().browser().cdpConnection;
            return await cdpConnection._createSession({ targetId: this._id });
        }
        get #waitForLoad$() { return _private_waitForLoad$_descriptor.value; }
        get #waitForNetworkIdle$() { return _private_waitForNetworkIdle$_descriptor.value; }
        async setFiles(element, files) {
            await this.browsingContext.setFiles(
            // SAFETY: ElementHandles are always remote references.
            element.remoteValue(), files);
        }
        async locateNodes(element, locator) {
            return await this.browsingContext.locateNodes(locator, 
            // SAFETY: ElementHandles are always remote references.
            [element.remoteValue()]);
        }
    };
})();

function isConsoleLogEntry(event) {
    return event.type === 'console';
}
function isJavaScriptLogEntry(event) {
    return event.type === 'javascript';
}
function getStackTraceLocations(stackTrace) {
    const stackTraceLocations = [];
    if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
            stackTraceLocations.push({
                url: callFrame.url,
                lineNumber: callFrame.lineNumber,
                columnNumber: callFrame.columnNumber,
            });
        }
    }
    return stackTraceLocations;
}
//# sourceMappingURL=Frame.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiHTTPRequest: () => (/* binding */ BidiHTTPRequest),
/* harmony export */   requests: () => (/* binding */ requests)
/* harmony export */ });
/* harmony import */ var _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _util_encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/encoding.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/encoding.js");
/* harmony import */ var _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js");
var _a;




const requests = new WeakMap();
/**
 * @internal
 */
class BidiHTTPRequest extends _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.HTTPRequest {
    static from(bidiRequest, frame, redirect) {
        const request = new _a(bidiRequest, frame, redirect);
        request.#initialize();
        return request;
    }
    #redirectChain;
    #response = null;
    id;
    #frame;
    #request;
    constructor(request, frame, redirect) {
        super();
        requests.set(request, this);
        this.interception.enabled = request.isBlocked;
        this.#request = request;
        this.#frame = frame;
        this.#redirectChain = redirect ? redirect.#redirectChain : [];
        this.id = request.id;
    }
    get client() {
        return this.#frame.client;
    }
    #initialize() {
        this.#request.on('redirect', request => {
            const httpRequest = _a.from(request, this.#frame, this);
            this.#redirectChain.push(this);
            request.once('success', () => {
                this.#frame
                    .page()
                    .trustedEmitter.emit("requestfinished" /* PageEvent.RequestFinished */, httpRequest);
            });
            request.once('error', () => {
                this.#frame
                    .page()
                    .trustedEmitter.emit("requestfailed" /* PageEvent.RequestFailed */, httpRequest);
            });
            void httpRequest.finalizeInterceptions();
        });
        this.#request.once('success', data => {
            this.#response = _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_3__.BidiHTTPResponse.from(data, this, this.#frame.page().browser().cdpSupported);
        });
        this.#request.on('authenticate', this.#handleAuthentication);
        this.#frame.page().trustedEmitter.emit("request" /* PageEvent.Request */, this);
        if (this.#hasInternalHeaderOverwrite) {
            this.interception.handlers.push(async () => {
                await this.continue({
                    headers: this.headers(),
                }, 0);
            });
        }
    }
    url() {
        return this.#request.url;
    }
    resourceType() {
        if (!this.#frame.page().browser().cdpSupported) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
        return (this.#request.resourceType || 'other').toLowerCase();
    }
    method() {
        return this.#request.method;
    }
    postData() {
        if (!this.#frame.page().browser().cdpSupported) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
        return this.#request.postData;
    }
    hasPostData() {
        if (!this.#frame.page().browser().cdpSupported) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
        return this.#request.hasPostData;
    }
    async fetchPostData() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    get #hasInternalHeaderOverwrite() {
        return Boolean(Object.keys(this.#extraHTTPHeaders).length ||
            Object.keys(this.#userAgentHeaders).length);
    }
    get #extraHTTPHeaders() {
        return this.#frame?.page()._extraHTTPHeaders ?? {};
    }
    get #userAgentHeaders() {
        return this.#frame?.page()._userAgentHeaders ?? {};
    }
    headers() {
        const headers = {};
        for (const header of this.#request.headers) {
            headers[header.name.toLowerCase()] = header.value.value;
        }
        return {
            ...headers,
            ...this.#extraHTTPHeaders,
            ...this.#userAgentHeaders,
        };
    }
    response() {
        return this.#response;
    }
    failure() {
        if (this.#request.error === undefined) {
            return null;
        }
        return { errorText: this.#request.error };
    }
    isNavigationRequest() {
        return this.#request.navigation !== undefined;
    }
    initiator() {
        return this.#request.initiator;
    }
    redirectChain() {
        return this.#redirectChain.slice();
    }
    frame() {
        return this.#frame;
    }
    async continue(overrides, priority) {
        return await super.continue({
            headers: this.#hasInternalHeaderOverwrite ? this.headers() : undefined,
            ...overrides,
        }, priority);
    }
    async _continue(overrides = {}) {
        const headers = getBidiHeaders(overrides.headers);
        this.interception.handled = true;
        return await this.#request
            .continueRequest({
            url: overrides.url,
            method: overrides.method,
            body: overrides.postData
                ? {
                    type: 'base64',
                    value: (0,_util_encoding_js__WEBPACK_IMPORTED_MODULE_2__.stringToBase64)(overrides.postData),
                }
                : undefined,
            headers: headers.length > 0 ? headers : undefined,
        })
            .catch(error => {
            this.interception.handled = false;
            return (0,_api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.handleError)(error);
        });
    }
    async _abort() {
        this.interception.handled = true;
        return await this.#request.failRequest().catch(error => {
            this.interception.handled = false;
            throw error;
        });
    }
    async _respond(response, _priority) {
        this.interception.handled = true;
        let parsedBody;
        if (response.body) {
            parsedBody = _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.HTTPRequest.getResponse(response.body);
        }
        const headers = getBidiHeaders(response.headers);
        const hasContentLength = headers.some(header => {
            return header.name === 'content-length';
        });
        if (response.contentType) {
            headers.push({
                name: 'content-type',
                value: {
                    type: 'string',
                    value: response.contentType,
                },
            });
        }
        if (parsedBody?.contentLength && !hasContentLength) {
            headers.push({
                name: 'content-length',
                value: {
                    type: 'string',
                    value: String(parsedBody.contentLength),
                },
            });
        }
        const status = response.status || 200;
        return await this.#request
            .provideResponse({
            statusCode: status,
            headers: headers.length > 0 ? headers : undefined,
            reasonPhrase: _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.STATUS_TEXTS[status],
            body: parsedBody?.base64
                ? {
                    type: 'base64',
                    value: parsedBody?.base64,
                }
                : undefined,
        })
            .catch(error => {
            this.interception.handled = false;
            throw error;
        });
    }
    #authenticationHandled = false;
    #handleAuthentication = async () => {
        if (!this.#frame) {
            return;
        }
        const credentials = this.#frame.page()._credentials;
        if (credentials && !this.#authenticationHandled) {
            this.#authenticationHandled = true;
            void this.#request.continueWithAuth({
                action: 'provideCredentials',
                credentials: {
                    type: 'password',
                    username: credentials.username,
                    password: credentials.password,
                },
            });
        }
        else {
            void this.#request.continueWithAuth({
                action: 'cancel',
            });
        }
    };
    timing() {
        return this.#request.timing();
    }
}
_a = BidiHTTPRequest;
function getBidiHeaders(rawHeaders) {
    const headers = [];
    for (const [name, value] of Object.entries(rawHeaders ?? [])) {
        if (!Object.is(value, undefined)) {
            const values = Array.isArray(value) ? value : [value];
            for (const value of values) {
                headers.push({
                    name: name.toLowerCase(),
                    value: {
                        type: 'string',
                        value: String(value),
                    },
                });
            }
        }
    }
    return headers;
}
//# sourceMappingURL=HTTPRequest.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiHTTPResponse: () => (/* binding */ BidiHTTPResponse)
/* harmony export */ });
/* harmony import */ var _api_HTTPResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_SecurityDetails_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/SecurityDetails.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};




/**
 * @internal
 */
let BidiHTTPResponse = (() => {
    let _classSuper = _api_HTTPResponse_js__WEBPACK_IMPORTED_MODULE_0__.HTTPResponse;
    let _instanceExtraInitializers = [];
    let _remoteAddress_decorators;
    return class BidiHTTPResponse extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _remoteAddress_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_3__.invokeAtMostOnceForArguments];
            __esDecorate(this, null, _remoteAddress_decorators, { kind: "method", name: "remoteAddress", static: false, private: false, access: { has: obj => "remoteAddress" in obj, get: obj => obj.remoteAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(data, request, cdpSupported) {
            const response = new BidiHTTPResponse(data, request, cdpSupported);
            response.#initialize();
            return response;
        }
        #data = __runInitializers(this, _instanceExtraInitializers);
        #request;
        #securityDetails;
        #cdpSupported = false;
        constructor(data, request, cdpSupported) {
            super();
            this.#data = data;
            this.#request = request;
            this.#cdpSupported = cdpSupported;
            // @ts-expect-error non-standard property.
            const securityDetails = data['goog:securityDetails'];
            if (cdpSupported && securityDetails) {
                this.#securityDetails = new _common_SecurityDetails_js__WEBPACK_IMPORTED_MODULE_2__.SecurityDetails(securityDetails);
            }
        }
        #initialize() {
            if (this.#data.fromCache) {
                this.#request
                    .frame()
                    ?.page()
                    .trustedEmitter.emit("requestservedfromcache" /* PageEvent.RequestServedFromCache */, this.#request);
            }
            this.#request.frame()?.page().trustedEmitter.emit("response" /* PageEvent.Response */, this);
        }
        remoteAddress() {
            return {
                ip: '',
                port: -1,
            };
        }
        url() {
            return this.#data.url;
        }
        status() {
            return this.#data.status;
        }
        statusText() {
            return this.#data.statusText;
        }
        headers() {
            const headers = {};
            for (const header of this.#data.headers) {
                // TODO: How to handle Binary Headers
                // https://w3c.github.io/webdriver-bidi/#type-network-Header
                if (header.value.type === 'string') {
                    headers[header.name.toLowerCase()] = header.value.value;
                }
            }
            return headers;
        }
        request() {
            return this.#request;
        }
        fromCache() {
            return this.#data.fromCache;
        }
        timing() {
            const bidiTiming = this.#request.timing();
            return {
                requestTime: bidiTiming.requestTime,
                proxyStart: -1,
                proxyEnd: -1,
                dnsStart: bidiTiming.dnsStart,
                dnsEnd: bidiTiming.dnsEnd,
                connectStart: bidiTiming.connectStart,
                connectEnd: bidiTiming.connectEnd,
                sslStart: bidiTiming.tlsStart,
                sslEnd: -1,
                workerStart: -1,
                workerReady: -1,
                workerFetchStart: -1,
                workerRespondWithSettled: -1,
                workerRouterEvaluationStart: -1,
                workerCacheLookupStart: -1,
                sendStart: bidiTiming.requestStart,
                sendEnd: -1,
                pushStart: -1,
                pushEnd: -1,
                receiveHeadersStart: bidiTiming.responseStart,
                receiveHeadersEnd: bidiTiming.responseEnd,
            };
        }
        frame() {
            return this.#request.frame();
        }
        fromServiceWorker() {
            return false;
        }
        securityDetails() {
            if (!this.#cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
            }
            return this.#securityDetails ?? null;
        }
        content() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
    };
})();

//# sourceMappingURL=HTTPResponse.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiKeyboard: () => (/* binding */ BidiKeyboard),
/* harmony export */   BidiMouse: () => (/* binding */ BidiMouse),
/* harmony export */   BidiTouchscreen: () => (/* binding */ BidiTouchscreen)
/* harmony export */ });
/* harmony import */ var _api_Input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */


var SourceActionsType;
(function (SourceActionsType) {
    SourceActionsType["None"] = "none";
    SourceActionsType["Key"] = "key";
    SourceActionsType["Pointer"] = "pointer";
    SourceActionsType["Wheel"] = "wheel";
})(SourceActionsType || (SourceActionsType = {}));
var ActionType;
(function (ActionType) {
    ActionType["Pause"] = "pause";
    ActionType["KeyDown"] = "keyDown";
    ActionType["KeyUp"] = "keyUp";
    ActionType["PointerUp"] = "pointerUp";
    ActionType["PointerDown"] = "pointerDown";
    ActionType["PointerMove"] = "pointerMove";
    ActionType["Scroll"] = "scroll";
})(ActionType || (ActionType = {}));
const getBidiKeyValue = (key) => {
    switch (key) {
        case '\r':
        case '\n':
            key = 'Enter';
            break;
    }
    // Measures the number of code points rather than UTF-16 code units.
    if ([...key].length === 1) {
        return key;
    }
    switch (key) {
        case 'Cancel':
            return '\uE001';
        case 'Help':
            return '\uE002';
        case 'Backspace':
            return '\uE003';
        case 'Tab':
            return '\uE004';
        case 'Clear':
            return '\uE005';
        case 'Enter':
            return '\uE007';
        case 'Shift':
        case 'ShiftLeft':
            return '\uE008';
        case 'Control':
        case 'ControlLeft':
            return '\uE009';
        case 'Alt':
        case 'AltLeft':
            return '\uE00A';
        case 'Pause':
            return '\uE00B';
        case 'Escape':
            return '\uE00C';
        case 'PageUp':
            return '\uE00E';
        case 'PageDown':
            return '\uE00F';
        case 'End':
            return '\uE010';
        case 'Home':
            return '\uE011';
        case 'ArrowLeft':
            return '\uE012';
        case 'ArrowUp':
            return '\uE013';
        case 'ArrowRight':
            return '\uE014';
        case 'ArrowDown':
            return '\uE015';
        case 'Insert':
            return '\uE016';
        case 'Delete':
            return '\uE017';
        case 'NumpadEqual':
            return '\uE019';
        case 'Numpad0':
            return '\uE01A';
        case 'Numpad1':
            return '\uE01B';
        case 'Numpad2':
            return '\uE01C';
        case 'Numpad3':
            return '\uE01D';
        case 'Numpad4':
            return '\uE01E';
        case 'Numpad5':
            return '\uE01F';
        case 'Numpad6':
            return '\uE020';
        case 'Numpad7':
            return '\uE021';
        case 'Numpad8':
            return '\uE022';
        case 'Numpad9':
            return '\uE023';
        case 'NumpadMultiply':
            return '\uE024';
        case 'NumpadAdd':
            return '\uE025';
        case 'NumpadSubtract':
            return '\uE027';
        case 'NumpadDecimal':
            return '\uE028';
        case 'NumpadDivide':
            return '\uE029';
        case 'F1':
            return '\uE031';
        case 'F2':
            return '\uE032';
        case 'F3':
            return '\uE033';
        case 'F4':
            return '\uE034';
        case 'F5':
            return '\uE035';
        case 'F6':
            return '\uE036';
        case 'F7':
            return '\uE037';
        case 'F8':
            return '\uE038';
        case 'F9':
            return '\uE039';
        case 'F10':
            return '\uE03A';
        case 'F11':
            return '\uE03B';
        case 'F12':
            return '\uE03C';
        case 'Meta':
        case 'MetaLeft':
            return '\uE03D';
        case 'ShiftRight':
            return '\uE050';
        case 'ControlRight':
            return '\uE051';
        case 'AltRight':
            return '\uE052';
        case 'MetaRight':
            return '\uE053';
        case 'Digit0':
            return '0';
        case 'Digit1':
            return '1';
        case 'Digit2':
            return '2';
        case 'Digit3':
            return '3';
        case 'Digit4':
            return '4';
        case 'Digit5':
            return '5';
        case 'Digit6':
            return '6';
        case 'Digit7':
            return '7';
        case 'Digit8':
            return '8';
        case 'Digit9':
            return '9';
        case 'KeyA':
            return 'a';
        case 'KeyB':
            return 'b';
        case 'KeyC':
            return 'c';
        case 'KeyD':
            return 'd';
        case 'KeyE':
            return 'e';
        case 'KeyF':
            return 'f';
        case 'KeyG':
            return 'g';
        case 'KeyH':
            return 'h';
        case 'KeyI':
            return 'i';
        case 'KeyJ':
            return 'j';
        case 'KeyK':
            return 'k';
        case 'KeyL':
            return 'l';
        case 'KeyM':
            return 'm';
        case 'KeyN':
            return 'n';
        case 'KeyO':
            return 'o';
        case 'KeyP':
            return 'p';
        case 'KeyQ':
            return 'q';
        case 'KeyR':
            return 'r';
        case 'KeyS':
            return 's';
        case 'KeyT':
            return 't';
        case 'KeyU':
            return 'u';
        case 'KeyV':
            return 'v';
        case 'KeyW':
            return 'w';
        case 'KeyX':
            return 'x';
        case 'KeyY':
            return 'y';
        case 'KeyZ':
            return 'z';
        case 'Semicolon':
            return ';';
        case 'Equal':
            return '=';
        case 'Comma':
            return ',';
        case 'Minus':
            return '-';
        case 'Period':
            return '.';
        case 'Slash':
            return '/';
        case 'Backquote':
            return '`';
        case 'BracketLeft':
            return '[';
        case 'Backslash':
            return '\\';
        case 'BracketRight':
            return ']';
        case 'Quote':
            return '"';
        default:
            throw new Error(`Unknown key: "${key}"`);
    }
};
/**
 * @internal
 */
class BidiKeyboard extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Keyboard {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async down(key, _options) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions: [
                    {
                        type: ActionType.KeyDown,
                        value: getBidiKeyValue(key),
                    },
                ],
            },
        ]);
    }
    async up(key) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions: [
                    {
                        type: ActionType.KeyUp,
                        value: getBidiKeyValue(key),
                    },
                ],
            },
        ]);
    }
    async press(key, options = {}) {
        const { delay = 0 } = options;
        const actions = [
            {
                type: ActionType.KeyDown,
                value: getBidiKeyValue(key),
            },
        ];
        if (delay > 0) {
            actions.push({
                type: ActionType.Pause,
                duration: delay,
            });
        }
        actions.push({
            type: ActionType.KeyUp,
            value: getBidiKeyValue(key),
        });
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions,
            },
        ]);
    }
    async type(text, options = {}) {
        const { delay = 0 } = options;
        // This spread separates the characters into code points rather than UTF-16
        // code units.
        const values = [...text].map(getBidiKeyValue);
        const actions = [];
        if (delay <= 0) {
            for (const value of values) {
                actions.push({
                    type: ActionType.KeyDown,
                    value,
                }, {
                    type: ActionType.KeyUp,
                    value,
                });
            }
        }
        else {
            for (const value of values) {
                actions.push({
                    type: ActionType.KeyDown,
                    value,
                }, {
                    type: ActionType.Pause,
                    duration: delay,
                }, {
                    type: ActionType.KeyUp,
                    value,
                });
            }
        }
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions,
            },
        ]);
    }
    async sendCharacter(char) {
        // Measures the number of code points rather than UTF-16 code units.
        if ([...char].length > 1) {
            throw new Error('Cannot send more than 1 character.');
        }
        const frame = await this.#page.focusedFrame();
        await frame.isolatedRealm().evaluate(async (char) => {
            document.execCommand('insertText', false, char);
        }, char);
    }
}
const getBidiButton = (button) => {
    switch (button) {
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left:
            return 0;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Middle:
            return 1;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Right:
            return 2;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Back:
            return 3;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Forward:
            return 4;
    }
};
/**
 * @internal
 */
class BidiMouse extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Mouse {
    #page;
    #lastMovePoint = { x: 0, y: 0 };
    constructor(page) {
        super();
        this.#page = page;
    }
    async reset() {
        this.#lastMovePoint = { x: 0, y: 0 };
        await this.#page.mainFrame().browsingContext.releaseActions();
    }
    async move(x, y, options = {}) {
        const from = this.#lastMovePoint;
        const to = {
            x: Math.round(x),
            y: Math.round(y),
        };
        const actions = [];
        const steps = options.steps ?? 0;
        for (let i = 0; i < steps; ++i) {
            actions.push({
                type: ActionType.PointerMove,
                x: from.x + (to.x - from.x) * (i / steps),
                y: from.y + (to.y - from.y) * (i / steps),
                origin: options.origin,
            });
        }
        actions.push({
            type: ActionType.PointerMove,
            ...to,
            origin: options.origin,
        });
        // https://w3c.github.io/webdriver-bidi/#command-input-performActions:~:text=input.PointerMoveAction%20%3D%20%7B%0A%20%20type%3A%20%22pointerMove%22%2C%0A%20%20x%3A%20js%2Dint%2C
        this.#lastMovePoint = to;
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions,
            },
        ]);
    }
    async down(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions: [
                    {
                        type: ActionType.PointerDown,
                        button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
                    },
                ],
            },
        ]);
    }
    async up(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions: [
                    {
                        type: ActionType.PointerUp,
                        button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
                    },
                ],
            },
        ]);
    }
    async click(x, y, options = {}) {
        const actions = [
            {
                type: ActionType.PointerMove,
                x: Math.round(x),
                y: Math.round(y),
                origin: options.origin,
            },
        ];
        const pointerDownAction = {
            type: ActionType.PointerDown,
            button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
        };
        const pointerUpAction = {
            type: ActionType.PointerUp,
            button: pointerDownAction.button,
        };
        for (let i = 1; i < (options.count ?? 1); ++i) {
            actions.push(pointerDownAction, pointerUpAction);
        }
        actions.push(pointerDownAction);
        if (options.delay) {
            actions.push({
                type: ActionType.Pause,
                duration: options.delay,
            });
        }
        actions.push(pointerUpAction);
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions,
            },
        ]);
    }
    async wheel(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Wheel,
                id: "__puppeteer_wheel" /* InputId.Wheel */,
                actions: [
                    {
                        type: ActionType.Scroll,
                        ...(this.#lastMovePoint ?? {
                            x: 0,
                            y: 0,
                        }),
                        deltaX: options.deltaX ?? 0,
                        deltaY: options.deltaY ?? 0,
                    },
                ],
            },
        ]);
    }
    drag() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragOver() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragEnter() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    drop() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragAndDrop() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiTouchscreen extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Touchscreen {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async touchStart(x, y, options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerMove,
                        x: Math.round(x),
                        y: Math.round(y),
                        origin: options.origin,
                    },
                    {
                        type: ActionType.PointerDown,
                        button: 0,
                        width: 0.5 * 2, // 2 times default touch radius.
                        height: 0.5 * 2, // 2 times default touch radius.
                        pressure: 0.5,
                        altitudeAngle: Math.PI / 2,
                    },
                ],
            },
        ]);
    }
    async touchMove(x, y, options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerMove,
                        x: Math.round(x),
                        y: Math.round(y),
                        origin: options.origin,
                        width: 0.5 * 2, // 2 times default touch radius.
                        height: 0.5 * 2, // 2 times default touch radius.
                        pressure: 0.5,
                        altitudeAngle: Math.PI / 2,
                    },
                ],
            },
        ]);
    }
    async touchEnd() {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerUp,
                        button: 0,
                    },
                ],
            },
        ]);
    }
}
//# sourceMappingURL=Input.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiJSHandle: () => (/* binding */ BidiJSHandle)
/* harmony export */ });
/* harmony import */ var _api_JSHandle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiJSHandle extends _api_JSHandle_js__WEBPACK_IMPORTED_MODULE_0__.JSHandle {
    static from(value, realm) {
        return new BidiJSHandle(value, realm);
    }
    #remoteValue;
    realm;
    #disposed = false;
    constructor(value, realm) {
        super();
        this.#remoteValue = value;
        this.realm = realm;
    }
    get disposed() {
        return this.#disposed;
    }
    async jsonValue() {
        return await this.evaluate(value => {
            return value;
        });
    }
    asElement() {
        return null;
    }
    async dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        await this.realm.destroyHandles([this]);
    }
    get isPrimitiveValue() {
        switch (this.#remoteValue.type) {
            case 'string':
            case 'number':
            case 'bigint':
            case 'boolean':
            case 'undefined':
            case 'null':
                return true;
            default:
                return false;
        }
    }
    toString() {
        if (this.isPrimitiveValue) {
            return 'JSHandle:' + _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__.BidiDeserializer.deserialize(this.#remoteValue);
        }
        return 'JSHandle@' + this.#remoteValue.type;
    }
    get id() {
        return 'handle' in this.#remoteValue ? this.#remoteValue.handle : undefined;
    }
    remoteValue() {
        return this.#remoteValue;
    }
    remoteObject() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation('Not available in WebDriver BiDi');
    }
}
//# sourceMappingURL=JSHandle.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiPage: () => (/* binding */ BidiPage)
/* harmony export */ });
/* harmony import */ var _third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../third_party/rxjs/rxjs.js */ "./node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js");
/* harmony import */ var _api_Page_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js");
/* harmony import */ var _cdp_Coverage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cdp/Coverage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js");
/* harmony import */ var _cdp_EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cdp/EmulationManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js");
/* harmony import */ var _cdp_Tracing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cdp/Tracing.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_encoding_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/encoding.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/encoding.js");
/* harmony import */ var _util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/ErrorLike.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js");
/* harmony import */ var _Frame_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js");
/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});















/**
 * Implements Page using WebDriver BiDi.
 *
 * @internal
 */
let BidiPage = (() => {
    let _classSuper = _api_Page_js__WEBPACK_IMPORTED_MODULE_1__.Page;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return class BidiPage extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_9__.bubble)()];
            __esDecorate(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: obj => "trustedEmitter" in obj, get: obj => obj.trustedEmitter, set: (obj, value) => { obj.trustedEmitter = value; } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browserContext, browsingContext) {
            const page = new BidiPage(browserContext, browsingContext);
            page.#initialize();
            return page;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_6__.EventEmitter());
        get trustedEmitter() { return this.#trustedEmitter_accessor_storage; }
        set trustedEmitter(value) { this.#trustedEmitter_accessor_storage = value; }
        #browserContext = __runInitializers(this, _trustedEmitter_extraInitializers);
        #frame;
        #viewport = null;
        #workers = new Set();
        keyboard;
        mouse;
        touchscreen;
        tracing;
        coverage;
        #cdpEmulationManager;
        #emulatedNetworkConditions;
        _client() {
            return this.#frame.client;
        }
        constructor(browserContext, browsingContext) {
            super();
            this.#browserContext = browserContext;
            this.#frame = _Frame_js__WEBPACK_IMPORTED_MODULE_12__.BidiFrame.from(this, browsingContext);
            this.#cdpEmulationManager = new _cdp_EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__.EmulationManager(this.#frame.client);
            this.tracing = new _cdp_Tracing_js__WEBPACK_IMPORTED_MODULE_4__.Tracing(this.#frame.client);
            this.coverage = new _cdp_Coverage_js__WEBPACK_IMPORTED_MODULE_2__.Coverage(this.#frame.client);
            this.keyboard = new _Input_js__WEBPACK_IMPORTED_MODULE_13__.BidiKeyboard(this);
            this.mouse = new _Input_js__WEBPACK_IMPORTED_MODULE_13__.BidiMouse(this);
            this.touchscreen = new _Input_js__WEBPACK_IMPORTED_MODULE_13__.BidiTouchscreen(this);
        }
        #initialize() {
            this.#frame.browsingContext.on('closed', () => {
                this.trustedEmitter.emit("close" /* PageEvent.Close */, undefined);
                this.trustedEmitter.removeAllListeners();
            });
            this.trustedEmitter.on("workercreated" /* PageEvent.WorkerCreated */, worker => {
                this.#workers.add(worker);
            });
            this.trustedEmitter.on("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker => {
                this.#workers.delete(worker);
            });
        }
        /**
         * @internal
         */
        _userAgentHeaders = {};
        #userAgentInterception;
        #userAgentPreloadScript;
        async setUserAgent(userAgent, userAgentMetadata) {
            if (!this.#browserContext.browser().cdpSupported && userAgentMetadata) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation('Current Browser does not support `userAgentMetadata`');
            }
            else if (this.#browserContext.browser().cdpSupported &&
                userAgentMetadata) {
                return await this._client().send('Network.setUserAgentOverride', {
                    userAgent: userAgent,
                    userAgentMetadata: userAgentMetadata,
                });
            }
            const enable = userAgent !== '';
            userAgent = userAgent ?? (await this.#browserContext.browser().userAgent());
            this._userAgentHeaders = enable
                ? {
                    'User-Agent': userAgent,
                }
                : {};
            this.#userAgentInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#userAgentInterception, enable);
            const changeUserAgent = (userAgent) => {
                Object.defineProperty(navigator, 'userAgent', {
                    value: userAgent,
                });
            };
            const frames = [this.#frame];
            for (const frame of frames) {
                frames.push(...frame.childFrames());
            }
            if (this.#userAgentPreloadScript) {
                await this.removeScriptToEvaluateOnNewDocument(this.#userAgentPreloadScript);
            }
            const [evaluateToken] = await Promise.all([
                enable
                    ? this.evaluateOnNewDocument(changeUserAgent, userAgent)
                    : undefined,
                // When we disable the UserAgent we want to
                // evaluate the original value in all Browsing Contexts
                frames.map(frame => {
                    return frame.evaluate(changeUserAgent, userAgent);
                }),
            ]);
            this.#userAgentPreloadScript = evaluateToken?.identifier;
        }
        async setBypassCSP(enabled) {
            // TODO: handle CDP-specific cases such as mprach.
            await this._client().send('Page.setBypassCSP', { enabled });
        }
        async queryObjects(prototypeHandle) {
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(prototypeHandle.id, 'Prototype JSHandle must not be referencing primitive value');
            const response = await this.#frame.client.send('Runtime.queryObjects', {
                prototypeObjectId: prototypeHandle.id,
            });
            return this.#frame.mainRealm().createHandle({
                type: 'array',
                handle: response.objects.objectId,
            });
        }
        browser() {
            return this.browserContext().browser();
        }
        browserContext() {
            return this.#browserContext;
        }
        mainFrame() {
            return this.#frame;
        }
        async focusedFrame() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource(env_1, (await this.mainFrame()
                    .isolatedRealm()
                    .evaluateHandle(() => {
                    let win = window;
                    while (win.document.activeElement instanceof win.HTMLIFrameElement ||
                        win.document.activeElement instanceof win.HTMLFrameElement) {
                        if (win.document.activeElement.contentWindow === null) {
                            break;
                        }
                        win = win.document.activeElement.contentWindow;
                    }
                    return win;
                })), false);
                const value = handle.remoteValue();
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(value.type === 'window');
                const frame = this.frames().find(frame => {
                    return frame._id === value.value.context;
                });
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(frame);
                return frame;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        frames() {
            const frames = [this.#frame];
            for (const frame of frames) {
                frames.push(...frame.childFrames());
            }
            return frames;
        }
        isClosed() {
            return this.#frame.detached;
        }
        async close(options) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                const _guard = __addDisposableResource(env_2, await this.#browserContext.waitForScreenshotOperations(), false);
                try {
                    await this.#frame.browsingContext.close(options?.runBeforeUnload);
                }
                catch {
                    return;
                }
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                __disposeResources(env_2);
            }
        }
        async reload(options = {}) {
            const [response] = await Promise.all([
                this.#frame.waitForNavigation(options),
                this.#frame.browsingContext.reload(),
            ]).catch((0,_util_js__WEBPACK_IMPORTED_MODULE_14__.rewriteNavigationError)(this.url(), options.timeout ?? this._timeoutSettings.navigationTimeout()));
            return response;
        }
        setDefaultNavigationTimeout(timeout) {
            this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        }
        setDefaultTimeout(timeout) {
            this._timeoutSettings.setDefaultTimeout(timeout);
        }
        getDefaultTimeout() {
            return this._timeoutSettings.timeout();
        }
        isJavaScriptEnabled() {
            return this.#cdpEmulationManager.javascriptEnabled;
        }
        async setGeolocation(options) {
            return await this.#cdpEmulationManager.setGeolocation(options);
        }
        async setJavaScriptEnabled(enabled) {
            return await this.#cdpEmulationManager.setJavaScriptEnabled(enabled);
        }
        async emulateMediaType(type) {
            return await this.#cdpEmulationManager.emulateMediaType(type);
        }
        async emulateCPUThrottling(factor) {
            return await this.#cdpEmulationManager.emulateCPUThrottling(factor);
        }
        async emulateMediaFeatures(features) {
            return await this.#cdpEmulationManager.emulateMediaFeatures(features);
        }
        async emulateTimezone(timezoneId) {
            return await this.#cdpEmulationManager.emulateTimezone(timezoneId);
        }
        async emulateIdleState(overrides) {
            return await this.#cdpEmulationManager.emulateIdleState(overrides);
        }
        async emulateVisionDeficiency(type) {
            return await this.#cdpEmulationManager.emulateVisionDeficiency(type);
        }
        async setViewport(viewport) {
            if (!this.browser().cdpSupported) {
                await this.#frame.browsingContext.setViewport({
                    viewport: viewport?.width && viewport?.height
                        ? {
                            width: viewport.width,
                            height: viewport.height,
                        }
                        : null,
                    devicePixelRatio: viewport?.deviceScaleFactor
                        ? viewport.deviceScaleFactor
                        : null,
                });
                this.#viewport = viewport;
                return;
            }
            const needsReload = await this.#cdpEmulationManager.emulateViewport(viewport);
            this.#viewport = viewport;
            if (needsReload) {
                await this.reload();
            }
        }
        viewport() {
            return this.#viewport;
        }
        async pdf(options = {}) {
            const { timeout: ms = this._timeoutSettings.timeout(), path = undefined } = options;
            const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize, } = (0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.parsePDFOptions)(options, 'cm');
            const pageRanges = ranges ? ranges.split(', ') : [];
            await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.from)(this.mainFrame()
                .isolatedRealm()
                .evaluate(() => {
                return document.fonts.ready;
            })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(ms))));
            const data = await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.from)(this.#frame.browsingContext.print({
                background,
                margin,
                orientation: landscape ? 'landscape' : 'portrait',
                page: {
                    width,
                    height,
                },
                pageRanges,
                scale,
                shrinkToFit: !preferCSSPageSize,
            })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(ms))));
            const typedArray = (0,_util_encoding_js__WEBPACK_IMPORTED_MODULE_10__.stringToTypedArray)(data, true);
            await this._maybeWriteTypedArrayToFile(path, typedArray);
            return typedArray;
        }
        async createPDFStream(options) {
            const typedArray = await this.pdf(options);
            return new ReadableStream({
                start(controller) {
                    controller.enqueue(typedArray);
                    controller.close();
                },
            });
        }
        async _screenshot(options) {
            const { clip, type, captureBeyondViewport, quality } = options;
            if (options.omitBackground !== undefined && options.omitBackground) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'omitBackground'.`);
            }
            if (options.optimizeForSpeed !== undefined && options.optimizeForSpeed) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'optimizeForSpeed'.`);
            }
            if (options.fromSurface !== undefined && !options.fromSurface) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'fromSurface'.`);
            }
            if (clip !== undefined && clip.scale !== undefined && clip.scale !== 1) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'scale' in 'clip'.`);
            }
            let box;
            if (clip) {
                if (captureBeyondViewport) {
                    box = clip;
                }
                else {
                    // The clip is always with respect to the document coordinates, so we
                    // need to convert this to viewport coordinates when we aren't capturing
                    // beyond the viewport.
                    const [pageLeft, pageTop] = await this.evaluate(() => {
                        if (!window.visualViewport) {
                            throw new Error('window.visualViewport is not supported.');
                        }
                        return [
                            window.visualViewport.pageLeft,
                            window.visualViewport.pageTop,
                        ];
                    });
                    box = {
                        ...clip,
                        x: clip.x - pageLeft,
                        y: clip.y - pageTop,
                    };
                }
            }
            const data = await this.#frame.browsingContext.captureScreenshot({
                origin: captureBeyondViewport ? 'document' : 'viewport',
                format: {
                    type: `image/${type}`,
                    ...(quality !== undefined ? { quality: quality / 100 } : {}),
                },
                ...(box ? { clip: { type: 'box', ...box } } : {}),
            });
            return data;
        }
        async createCDPSession() {
            return await this.#frame.createCDPSession();
        }
        async bringToFront() {
            await this.#frame.browsingContext.activate();
        }
        async evaluateOnNewDocument(pageFunction, ...args) {
            const expression = evaluationExpression(pageFunction, ...args);
            const script = await this.#frame.browsingContext.addPreloadScript(expression);
            return { identifier: script };
        }
        async removeScriptToEvaluateOnNewDocument(id) {
            await this.#frame.browsingContext.removePreloadScript(id);
        }
        async exposeFunction(name, pptrFunction) {
            return await this.mainFrame().exposeFunction(name, 'default' in pptrFunction ? pptrFunction.default : pptrFunction);
        }
        isDragInterceptionEnabled() {
            return false;
        }
        async setCacheEnabled(enabled) {
            if (!this.#browserContext.browser().cdpSupported) {
                await this.#frame.browsingContext.setCacheBehavior(enabled ? 'default' : 'bypass');
                return;
            }
            // TODO: handle CDP-specific cases such as mprach.
            await this._client().send('Network.setCacheDisabled', {
                cacheDisabled: !enabled,
            });
        }
        async cookies(...urls) {
            const normalizedUrls = (urls.length ? urls : [this.url()]).map(url => {
                return new URL(url);
            });
            const cookies = await this.#frame.browsingContext.getCookies();
            return cookies
                .map(cookie => {
                return bidiToPuppeteerCookie(cookie);
            })
                .filter(cookie => {
                return normalizedUrls.some(url => {
                    return testUrlMatchCookie(cookie, url);
                });
            });
        }
        isServiceWorkerBypassed() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        target() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        waitForFileChooser() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        workers() {
            return [...this.#workers];
        }
        #userInterception;
        async setRequestInterception(enable) {
            this.#userInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#userInterception, enable);
        }
        /**
         * @internal
         */
        _extraHTTPHeaders = {};
        #extraHeadersInterception;
        async setExtraHTTPHeaders(headers) {
            const extraHTTPHeaders = {};
            for (const [key, value] of Object.entries(headers)) {
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.isString)(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
                extraHTTPHeaders[key.toLowerCase()] = value;
            }
            this._extraHTTPHeaders = extraHTTPHeaders;
            this.#extraHeadersInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#extraHeadersInterception, Boolean(Object.keys(this._extraHTTPHeaders).length));
        }
        /**
         * @internal
         */
        _credentials = null;
        #authInterception;
        async authenticate(credentials) {
            this.#authInterception = await this.#toggleInterception(["authRequired" /* Bidi.Network.InterceptPhase.AuthRequired */], this.#authInterception, Boolean(credentials));
            this._credentials = credentials;
        }
        async #toggleInterception(phases, interception, expected) {
            if (expected && !interception) {
                return await this.#frame.browsingContext.addIntercept({
                    phases,
                });
            }
            else if (!expected && interception) {
                await this.#frame.browsingContext.userContext.browser.removeIntercept(interception);
                return;
            }
            return interception;
        }
        setDragInterception() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        setBypassServiceWorker() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        async setOfflineMode(enabled) {
            if (!this.#browserContext.browser().cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
            }
            if (!this.#emulatedNetworkConditions) {
                this.#emulatedNetworkConditions = {
                    offline: false,
                    upload: -1,
                    download: -1,
                    latency: 0,
                };
            }
            this.#emulatedNetworkConditions.offline = enabled;
            return await this.#applyNetworkConditions();
        }
        async emulateNetworkConditions(networkConditions) {
            if (!this.#browserContext.browser().cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
            }
            if (!this.#emulatedNetworkConditions) {
                this.#emulatedNetworkConditions = {
                    offline: false,
                    upload: -1,
                    download: -1,
                    latency: 0,
                };
            }
            this.#emulatedNetworkConditions.upload = networkConditions
                ? networkConditions.upload
                : -1;
            this.#emulatedNetworkConditions.download = networkConditions
                ? networkConditions.download
                : -1;
            this.#emulatedNetworkConditions.latency = networkConditions
                ? networkConditions.latency
                : 0;
            return await this.#applyNetworkConditions();
        }
        async #applyNetworkConditions() {
            if (!this.#emulatedNetworkConditions) {
                return;
            }
            await this._client().send('Network.emulateNetworkConditions', {
                offline: this.#emulatedNetworkConditions.offline,
                latency: this.#emulatedNetworkConditions.latency,
                uploadThroughput: this.#emulatedNetworkConditions.upload,
                downloadThroughput: this.#emulatedNetworkConditions.download,
            });
        }
        async setCookie(...cookies) {
            const pageURL = this.url();
            const pageUrlStartsWithHTTP = pageURL.startsWith('http');
            for (const cookie of cookies) {
                let cookieUrl = cookie.url || '';
                if (!cookieUrl && pageUrlStartsWithHTTP) {
                    cookieUrl = pageURL;
                }
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(cookieUrl !== 'about:blank', `Blank page can not have cookie "${cookie.name}"`);
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(!String.prototype.startsWith.call(cookieUrl || '', 'data:'), `Data URL page can not have cookie "${cookie.name}"`);
                const normalizedUrl = URL.canParse(cookieUrl)
                    ? new URL(cookieUrl)
                    : undefined;
                const domain = cookie.domain ?? normalizedUrl?.hostname;
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(domain !== undefined, `At least one of the url and domain needs to be specified`);
                const bidiCookie = {
                    domain: domain,
                    name: cookie.name,
                    value: {
                        type: 'string',
                        value: cookie.value,
                    },
                    ...(cookie.path !== undefined ? { path: cookie.path } : {}),
                    ...(cookie.httpOnly !== undefined ? { httpOnly: cookie.httpOnly } : {}),
                    ...(cookie.secure !== undefined ? { secure: cookie.secure } : {}),
                    ...(cookie.sameSite !== undefined
                        ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) }
                        : {}),
                    ...(cookie.expires !== undefined ? { expiry: cookie.expires } : {}),
                    // Chrome-specific properties.
                    ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, 'sameParty', 'sourceScheme', 'priority', 'url'),
                };
                if (cookie.partitionKey !== undefined) {
                    await this.browserContext().userContext.setCookie(bidiCookie, cookie.partitionKey);
                }
                else {
                    await this.#frame.browsingContext.setCookie(bidiCookie);
                }
            }
        }
        async deleteCookie(...cookies) {
            await Promise.all(cookies.map(async (deleteCookieRequest) => {
                const cookieUrl = deleteCookieRequest.url ?? this.url();
                const normalizedUrl = URL.canParse(cookieUrl)
                    ? new URL(cookieUrl)
                    : undefined;
                const domain = deleteCookieRequest.domain ?? normalizedUrl?.hostname;
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(domain !== undefined, `At least one of the url and domain needs to be specified`);
                const filter = {
                    domain: domain,
                    name: deleteCookieRequest.name,
                    ...(deleteCookieRequest.path !== undefined
                        ? { path: deleteCookieRequest.path }
                        : {}),
                };
                await this.#frame.browsingContext.deleteCookie(filter);
            }));
        }
        async removeExposedFunction(name) {
            await this.#frame.removeExposedFunction(name);
        }
        metrics() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        async goBack(options = {}) {
            return await this.#go(-1, options);
        }
        async goForward(options = {}) {
            return await this.#go(1, options);
        }
        async #go(delta, options) {
            const controller = new AbortController();
            try {
                const [response] = await Promise.all([
                    this.waitForNavigation({
                        ...options,
                        signal: controller.signal,
                    }),
                    this.#frame.browsingContext.traverseHistory(delta),
                ]);
                return response;
            }
            catch (error) {
                controller.abort();
                if ((0,_util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_11__.isErrorLike)(error)) {
                    if (error.message.includes('no such history entry')) {
                        return null;
                    }
                }
                throw error;
            }
        }
        waitForDevicePrompt() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
    };
})();

function evaluationExpression(fun, ...args) {
    return `() => {${(0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.evaluationString)(fun, ...args)}}`;
}
/**
 * Check domains match.
 * According to cookies spec, this check should match subdomains as well, but CDP
 * implementation does not do that, so this method matches only the exact domains, not
 * what is written in the spec:
 * https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3
 */
function testUrlMatchCookieHostname(cookie, normalizedUrl) {
    const cookieDomain = cookie.domain.toLowerCase();
    const urlHostname = normalizedUrl.hostname.toLowerCase();
    return cookieDomain === urlHostname;
}
/**
 * Check paths match.
 * Spec: https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4
 */
function testUrlMatchCookiePath(cookie, normalizedUrl) {
    const uriPath = normalizedUrl.pathname;
    const cookiePath = cookie.path;
    if (uriPath === cookiePath) {
        // The cookie-path and the request-path are identical.
        return true;
    }
    if (uriPath.startsWith(cookiePath)) {
        // The cookie-path is a prefix of the request-path.
        if (cookiePath.endsWith('/')) {
            // The last character of the cookie-path is %x2F ("/").
            return true;
        }
        if (uriPath[cookiePath.length] === '/') {
            // The first character of the request-path that is not included in the cookie-path
            // is a %x2F ("/") character.
            return true;
        }
    }
    return false;
}
/**
 * Checks the cookie matches the URL according to the spec:
 */
function testUrlMatchCookie(cookie, url) {
    const normalizedUrl = new URL(url);
    (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(cookie !== undefined);
    if (!testUrlMatchCookieHostname(cookie, normalizedUrl)) {
        return false;
    }
    return testUrlMatchCookiePath(cookie, normalizedUrl);
}
function bidiToPuppeteerCookie(bidiCookie) {
    const partitionKey = bidiCookie[CDP_SPECIFIC_PREFIX + 'partitionKey'];
    function getParitionKey() {
        if (typeof partitionKey === 'string') {
            return { partitionKey };
        }
        if (typeof partitionKey === 'object' && partitionKey !== null) {
            return {
                // TODO: a breaking change in Puppeteer is required to change
                // partitionKey type and report the composite partition key.
                partitionKey: partitionKey.topLevelSite,
            };
        }
        return {};
    }
    return {
        name: bidiCookie.name,
        // Presents binary value as base64 string.
        value: bidiCookie.value.value,
        domain: bidiCookie.domain,
        path: bidiCookie.path,
        size: bidiCookie.size,
        httpOnly: bidiCookie.httpOnly,
        secure: bidiCookie.secure,
        sameSite: convertCookiesSameSiteBiDiToCdp(bidiCookie.sameSite),
        expires: bidiCookie.expiry ?? -1,
        session: bidiCookie.expiry === undefined || bidiCookie.expiry <= 0,
        // Extending with CDP-specific properties with `goog:` prefix.
        ...cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, 'sameParty', 'sourceScheme', 'partitionKeyOpaque', 'priority'),
        ...getParitionKey(),
    };
}
const CDP_SPECIFIC_PREFIX = 'goog:';
/**
 * Gets CDP-specific properties from the BiDi cookie and returns them as a new object.
 */
function cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
        if (bidiCookie[CDP_SPECIFIC_PREFIX + property] !== undefined) {
            result[property] = bidiCookie[CDP_SPECIFIC_PREFIX + property];
        }
    }
    return result;
}
/**
 * Gets CDP-specific properties from the cookie, adds CDP-specific prefixes and returns
 * them as a new object which can be used in BiDi.
 */
function cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookieParam, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
        if (cookieParam[property] !== undefined) {
            result[CDP_SPECIFIC_PREFIX + property] = cookieParam[property];
        }
    }
    return result;
}
function convertCookiesSameSiteBiDiToCdp(sameSite) {
    return sameSite === 'strict' ? 'Strict' : sameSite === 'lax' ? 'Lax' : 'None';
}
function convertCookiesSameSiteCdpToBiDi(sameSite) {
    return sameSite === 'Strict'
        ? "strict" /* Bidi.Network.SameSite.Strict */
        : sameSite === 'Lax'
            ? "lax" /* Bidi.Network.SameSite.Lax */
            : "none" /* Bidi.Network.SameSite.None */;
}
//# sourceMappingURL=Page.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiFrameRealm: () => (/* binding */ BidiFrameRealm),
/* harmony export */   BidiRealm: () => (/* binding */ BidiRealm),
/* harmony export */   BidiWorkerRealm: () => (/* binding */ BidiWorkerRealm)
/* harmony export */ });
/* harmony import */ var _api_Realm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js");
/* harmony import */ var _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cdp/AriaQueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js");
/* harmony import */ var _common_LazyArg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/LazyArg.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js");
/* harmony import */ var _common_ScriptInjector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/ScriptInjector.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/AsyncIterableUtil.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js");
/* harmony import */ var _util_Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Function.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ExposedFunction.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Serializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});













/**
 * @internal
 */
class BidiRealm extends _api_Realm_js__WEBPACK_IMPORTED_MODULE_0__.Realm {
    realm;
    constructor(realm, timeoutSettings) {
        super(timeoutSettings);
        this.realm = realm;
    }
    initialize() {
        this.realm.on('destroyed', ({ reason }) => {
            this.taskManager.terminateAll(new Error(reason));
            this.dispose();
        });
        this.realm.on('updated', () => {
            this.internalPuppeteerUtil = undefined;
            void this.taskManager.rerunAll();
        });
    }
    internalPuppeteerUtil;
    get puppeteerUtil() {
        const promise = Promise.resolve();
        _common_ScriptInjector_js__WEBPACK_IMPORTED_MODULE_3__.scriptInjector.inject(script => {
            if (this.internalPuppeteerUtil) {
                void this.internalPuppeteerUtil.then(handle => {
                    void handle.dispose();
                });
            }
            this.internalPuppeteerUtil = promise.then(() => {
                return this.evaluateHandle(script);
            });
        }, !this.internalPuppeteerUtil);
        return this.internalPuppeteerUtil;
    }
    async evaluateHandle(pageFunction, ...args) {
        return await this.#evaluate(false, pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
        return await this.#evaluate(true, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
        const sourceUrlComment = (0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.getSourceUrlComment)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
            _common_util_js__WEBPACK_IMPORTED_MODULE_4__.PuppeteerURL.INTERNAL_URL);
        let responsePromise;
        const resultOwnership = returnByValue
            ? "none" /* Bidi.Script.ResultOwnership.None */
            : "root" /* Bidi.Script.ResultOwnership.Root */;
        const serializationOptions = returnByValue
            ? {}
            : {
                maxObjectDepth: 0,
                maxDomDepth: 0,
            };
        if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(pageFunction)) {
            const expression = _common_util_js__WEBPACK_IMPORTED_MODULE_4__.SOURCE_URL_REGEX.test(pageFunction)
                ? pageFunction
                : `${pageFunction}\n${sourceUrlComment}\n`;
            responsePromise = this.realm.evaluate(expression, true, {
                resultOwnership,
                userActivation: true,
                serializationOptions,
            });
        }
        else {
            let functionDeclaration = (0,_util_Function_js__WEBPACK_IMPORTED_MODULE_6__.stringifyFunction)(pageFunction);
            functionDeclaration = _common_util_js__WEBPACK_IMPORTED_MODULE_4__.SOURCE_URL_REGEX.test(functionDeclaration)
                ? functionDeclaration
                : `${functionDeclaration}\n${sourceUrlComment}\n`;
            responsePromise = this.realm.callFunction(functionDeclaration, 
            /* awaitPromise= */ true, {
                // LazyArgs are used only internally and should not affect the order
                // evaluate calls for the public APIs.
                arguments: args.some(arg => {
                    return arg instanceof _common_LazyArg_js__WEBPACK_IMPORTED_MODULE_2__.LazyArg;
                })
                    ? await Promise.all(args.map(arg => {
                        return this.serializeAsync(arg);
                    }))
                    : args.map(arg => {
                        return this.serialize(arg);
                    }),
                resultOwnership,
                userActivation: true,
                serializationOptions,
            });
        }
        const result = await responsePromise;
        if ('type' in result && result.type === 'exception') {
            throw (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.createEvaluationError)(result.exceptionDetails);
        }
        return returnByValue
            ? _Deserializer_js__WEBPACK_IMPORTED_MODULE_7__.BidiDeserializer.deserialize(result.result)
            : this.createHandle(result.result);
    }
    createHandle(result) {
        if ((result.type === 'node' || result.type === 'window') &&
            this instanceof BidiFrameRealm) {
            return _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle.from(result, this);
        }
        return _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__.BidiJSHandle.from(result, this);
    }
    async serializeAsync(arg) {
        if (arg instanceof _common_LazyArg_js__WEBPACK_IMPORTED_MODULE_2__.LazyArg) {
            arg = await arg.get(this);
        }
        return this.serialize(arg);
    }
    serialize(arg) {
        if (arg instanceof _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__.BidiJSHandle || arg instanceof _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle) {
            if (arg.realm !== this) {
                if (!(arg.realm instanceof BidiFrameRealm) ||
                    !(this instanceof BidiFrameRealm)) {
                    throw new Error("Trying to evaluate JSHandle from different global types. Usually this means you're using a handle from a worker in a page or vice versa.");
                }
                if (arg.realm.environment !== this.environment) {
                    throw new Error("Trying to evaluate JSHandle from different frames. Usually this means you're using a handle from a page on a different page.");
                }
            }
            if (arg.disposed) {
                throw new Error('JSHandle is disposed!');
            }
            return arg.remoteValue();
        }
        return _Serializer_js__WEBPACK_IMPORTED_MODULE_11__.BidiSerializer.serialize(arg);
    }
    async destroyHandles(handles) {
        if (this.disposed) {
            return;
        }
        const handleIds = handles
            .map(({ id }) => {
            return id;
        })
            .filter((id) => {
            return id !== undefined;
        });
        if (handleIds.length === 0) {
            return;
        }
        await this.realm.disown(handleIds).catch(error => {
            // Exceptions might happen in case of a page been navigated or closed.
            // Swallow these since they are harmless and we don't leak anything in this case.
            (0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.debugError)(error);
        });
    }
    async adoptHandle(handle) {
        return (await this.evaluateHandle(node => {
            return node;
        }, handle));
    }
    async transferHandle(handle) {
        if (handle.realm === this) {
            return handle;
        }
        const transferredHandle = this.adoptHandle(handle);
        await handle.dispose();
        return await transferredHandle;
    }
}
/**
 * @internal
 */
class BidiFrameRealm extends BidiRealm {
    static from(realm, frame) {
        const frameRealm = new BidiFrameRealm(realm, frame);
        frameRealm.#initialize();
        return frameRealm;
    }
    #frame;
    constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#frame = frame;
    }
    #initialize() {
        super.initialize();
        // This should run first.
        this.realm.on('updated', () => {
            this.environment.clearDocumentHandle();
            this.#bindingsInstalled = false;
        });
    }
    #bindingsInstalled = false;
    get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!this.#bindingsInstalled) {
            promise = Promise.all([
                _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__.ExposeableFunction.from(this.environment, '__ariaQuerySelector', _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__.ARIAQueryHandler.queryOne, !!this.sandbox),
                _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__.ExposeableFunction.from(this.environment, '__ariaQuerySelectorAll', async (element, selector) => {
                    const results = _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__.ARIAQueryHandler.queryAll(element, selector);
                    return await element.realm.evaluateHandle((...elements) => {
                        return elements;
                    }, ...(await _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_5__.AsyncIterableUtil.collect(results)));
                }, !!this.sandbox),
            ]);
            this.#bindingsInstalled = true;
        }
        return promise.then(() => {
            return super.puppeteerUtil;
        });
    }
    get sandbox() {
        return this.realm.sandbox;
    }
    get environment() {
        return this.#frame;
    }
    async adoptBackendNode(backendNodeId) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const { object } = await this.#frame.client.send('DOM.resolveNode', {
                backendNodeId,
                executionContextId: await this.realm.resolveExecutionContextId(),
            });
            const handle = __addDisposableResource(env_1, _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle.from({
                handle: object.objectId,
                type: 'node',
            }, this), false);
            // We need the sharedId, so we perform the following to obtain it.
            return await handle.evaluateHandle(element => {
                return element;
            });
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
}
/**
 * @internal
 */
class BidiWorkerRealm extends BidiRealm {
    static from(realm, worker) {
        const workerRealm = new BidiWorkerRealm(realm, worker);
        workerRealm.initialize();
        return workerRealm;
    }
    #worker;
    constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#worker = frame;
    }
    get environment() {
        return this.#worker;
    }
    async adoptBackendNode() {
        throw new Error('Cannot adopt DOM nodes into a worker.');
    }
}
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiSerializer: () => (/* binding */ BidiSerializer)
/* harmony export */ });
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @internal
 */
class UnserializableError extends Error {
}
/**
 * @internal
 */
class BidiSerializer {
    static serialize(arg) {
        switch (typeof arg) {
            case 'symbol':
            case 'function':
                throw new UnserializableError(`Unable to serializable ${typeof arg}`);
            case 'object':
                return this.#serializeObject(arg);
            case 'undefined':
                return {
                    type: 'undefined',
                };
            case 'number':
                return this.#serializeNumber(arg);
            case 'bigint':
                return {
                    type: 'bigint',
                    value: arg.toString(),
                };
            case 'string':
                return {
                    type: 'string',
                    value: arg,
                };
            case 'boolean':
                return {
                    type: 'boolean',
                    value: arg,
                };
        }
    }
    static #serializeNumber(arg) {
        let value;
        if (Object.is(arg, -0)) {
            value = '-0';
        }
        else if (Object.is(arg, Infinity)) {
            value = 'Infinity';
        }
        else if (Object.is(arg, -Infinity)) {
            value = '-Infinity';
        }
        else if (Object.is(arg, NaN)) {
            value = 'NaN';
        }
        else {
            value = arg;
        }
        return {
            type: 'number',
            value,
        };
    }
    static #serializeObject(arg) {
        if (arg === null) {
            return {
                type: 'null',
            };
        }
        else if (Array.isArray(arg)) {
            const parsedArray = arg.map(subArg => {
                return this.serialize(subArg);
            });
            return {
                type: 'array',
                value: parsedArray,
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(arg)) {
            try {
                JSON.stringify(arg);
            }
            catch (error) {
                if (error instanceof TypeError &&
                    error.message.startsWith('Converting circular structure to JSON')) {
                    error.message += ' Recursive objects are not allowed.';
                }
                throw error;
            }
            const parsedObject = [];
            for (const key in arg) {
                parsedObject.push([this.serialize(key), this.serialize(arg[key])]);
            }
            return {
                type: 'object',
                value: parsedObject,
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(arg)) {
            return {
                type: 'regexp',
                value: {
                    pattern: arg.source,
                    flags: arg.flags,
                },
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isDate)(arg)) {
            return {
                type: 'date',
                value: arg.toISOString(),
            };
        }
        throw new UnserializableError('Custom object serialization not possible. Use plain objects instead.');
    }
}
//# sourceMappingURL=Serializer.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowserTarget: () => (/* binding */ BidiBrowserTarget),
/* harmony export */   BidiFrameTarget: () => (/* binding */ BidiFrameTarget),
/* harmony export */   BidiPageTarget: () => (/* binding */ BidiPageTarget),
/* harmony export */   BidiWorkerTarget: () => (/* binding */ BidiWorkerTarget)
/* harmony export */ });
/* harmony import */ var _api_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiBrowserTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #browser;
    constructor(browser) {
        super();
        this.#browser = browser;
    }
    asPage() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    url() {
        return '';
    }
    createCDPSession() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.BROWSER;
    }
    browser() {
        return this.#browser;
    }
    browserContext() {
        return this.#browser.defaultBrowserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiPageTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async page() {
        return this.#page;
    }
    async asPage() {
        return _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#page.mainFrame().browsingContext);
    }
    url() {
        return this.#page.url();
    }
    createCDPSession() {
        return this.#page.createCDPSession();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.PAGE;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#page.browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiFrameTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #frame;
    #page;
    constructor(frame) {
        super();
        this.#frame = frame;
    }
    async page() {
        if (this.#page === undefined) {
            this.#page = _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#frame.browsingContext);
        }
        return this.#page;
    }
    async asPage() {
        return _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#frame.browsingContext);
    }
    url() {
        return this.#frame.url();
    }
    createCDPSession() {
        return this.#frame.createCDPSession();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.PAGE;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#frame.page().browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiWorkerTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #worker;
    constructor(worker) {
        super();
        this.#worker = worker;
    }
    async page() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    async asPage() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    url() {
        return this.#worker.url();
    }
    createCDPSession() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.OTHER;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#worker.frame.page().browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js":
/*!*************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiWebWorker: () => (/* binding */ BidiWebWorker)
/* harmony export */ });
/* harmony import */ var _api_WebWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiWebWorker extends _api_WebWorker_js__WEBPACK_IMPORTED_MODULE_0__.WebWorker {
    static from(frame, realm) {
        const worker = new BidiWebWorker(frame, realm);
        return worker;
    }
    #frame;
    #realm;
    constructor(frame, realm) {
        super(realm.origin);
        this.#frame = frame;
        this.#realm = _Realm_js__WEBPACK_IMPORTED_MODULE_2__.BidiWorkerRealm.from(realm, this);
    }
    get frame() {
        return this.#frame;
    }
    mainRealm() {
        return this.#realm;
    }
    get client() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
//# sourceMappingURL=WebWorker.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowser: () => (/* reexport safe */ _Browser_js__WEBPACK_IMPORTED_MODULE_1__.BidiBrowser),
/* harmony export */   BidiBrowserContext: () => (/* reexport safe */ _BrowserContext_js__WEBPACK_IMPORTED_MODULE_2__.BidiBrowserContext),
/* harmony export */   BidiConnection: () => (/* reexport safe */ _Connection_js__WEBPACK_IMPORTED_MODULE_3__.BidiConnection),
/* harmony export */   BidiElementHandle: () => (/* reexport safe */ _ElementHandle_js__WEBPACK_IMPORTED_MODULE_4__.BidiElementHandle),
/* harmony export */   BidiFrame: () => (/* reexport safe */ _Frame_js__WEBPACK_IMPORTED_MODULE_5__.BidiFrame),
/* harmony export */   BidiFrameRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiFrameRealm),
/* harmony export */   BidiHTTPRequest: () => (/* reexport safe */ _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__.BidiHTTPRequest),
/* harmony export */   BidiHTTPResponse: () => (/* reexport safe */ _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_7__.BidiHTTPResponse),
/* harmony export */   BidiJSHandle: () => (/* reexport safe */ _JSHandle_js__WEBPACK_IMPORTED_MODULE_9__.BidiJSHandle),
/* harmony export */   BidiKeyboard: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiKeyboard),
/* harmony export */   BidiMouse: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiMouse),
/* harmony export */   BidiPage: () => (/* reexport safe */ _Page_js__WEBPACK_IMPORTED_MODULE_10__.BidiPage),
/* harmony export */   BidiRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiRealm),
/* harmony export */   BidiTouchscreen: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiTouchscreen),
/* harmony export */   BidiWorkerRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiWorkerRealm),
/* harmony export */   connectBidiOverCdp: () => (/* reexport safe */ _BidiOverCdp_js__WEBPACK_IMPORTED_MODULE_0__.connectBidiOverCdp),
/* harmony export */   requests: () => (/* reexport safe */ _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__.requests)
/* harmony export */ });
/* harmony import */ var _BidiOverCdp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BidiOverCdp.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js");
/* harmony import */ var _Browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js");
/* harmony import */ var _BrowserContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _Frame_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js");
/* harmony import */ var _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js");
/* harmony import */ var _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js");
/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */












//# sourceMappingURL=bidi.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Browser: () => (/* binding */ Browser)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js");
/* harmony import */ var _UserContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});





/**
 * @internal
 */
let Browser = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _close_decorators;
    let _addPreloadScript_decorators;
    let _removeIntercept_decorators;
    let _removePreloadScript_decorators;
    let _createUserContext_decorators;
    return class Browser extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: obj => "close" in obj, get: obj => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: obj => "addPreloadScript" in obj, get: obj => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removeIntercept_decorators, { kind: "method", name: "removeIntercept", static: false, private: false, access: { has: obj => "removeIntercept" in obj, get: obj => obj.removeIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: obj => "removePreloadScript" in obj, get: obj => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createUserContext_decorators, { kind: "method", name: "createUserContext", static: false, private: false, access: { has: obj => "createUserContext" in obj, get: obj => obj.createUserContext }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(session) {
            const browser = new Browser(session);
            await browser.#initialize();
            return browser;
        }
        #closed = (__runInitializers(this, _instanceExtraInitializers), false);
        #reason;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #userContexts = new Map();
        session;
        #sharedWorkers = new Map();
        constructor(session) {
            super();
            this.session = session;
        }
        async #initialize() {
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
            sessionEmitter.once('ended', ({ reason }) => {
                this.dispose(reason);
            });
            sessionEmitter.on('script.realmCreated', info => {
                if (info.type !== 'shared-worker') {
                    return;
                }
                this.#sharedWorkers.set(info.realm, _Realm_js__WEBPACK_IMPORTED_MODULE_3__.SharedWorkerRealm.from(this, info.realm, info.origin));
            });
            await this.#syncUserContexts();
            await this.#syncBrowsingContexts();
        }
        async #syncUserContexts() {
            const { result: { userContexts }, } = await this.session.send('browser.getUserContexts', {});
            for (const context of userContexts) {
                this.#createUserContext(context.userContext);
            }
        }
        async #syncBrowsingContexts() {
            // In case contexts are created or destroyed during `getTree`, we use this
            // set to detect them.
            const contextIds = new Set();
            let contexts;
            {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const sessionEmitter = __addDisposableResource(env_1, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session), false);
                    sessionEmitter.on('browsingContext.contextCreated', info => {
                        contextIds.add(info.context);
                    });
                    const { result } = await this.session.send('browsingContext.getTree', {});
                    contexts = result.contexts;
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources(env_1);
                }
            }
            // Simulating events so contexts are created naturally.
            for (const info of contexts) {
                if (!contextIds.has(info.context)) {
                    this.session.emit('browsingContext.contextCreated', info);
                }
                if (info.children) {
                    contexts.push(...info.children);
                }
            }
        }
        #createUserContext(id) {
            const userContext = _UserContext_js__WEBPACK_IMPORTED_MODULE_4__.UserContext.create(this, id);
            this.#userContexts.set(userContext.id, userContext);
            const userContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(userContext));
            userContextEmitter.once('closed', () => {
                userContextEmitter.removeAllListeners();
                this.#userContexts.delete(userContext.id);
            });
            return userContext;
        }
        get closed() {
            return this.#closed;
        }
        get defaultUserContext() {
            // SAFETY: A UserContext is always created for the default context.
            return this.#userContexts.get(_UserContext_js__WEBPACK_IMPORTED_MODULE_4__.UserContext.DEFAULT);
        }
        get disconnected() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.disconnected;
        }
        get userContexts() {
            return this.#userContexts.values();
        }
        dispose(reason, closed = false) {
            this.#closed = closed;
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async close() {
            try {
                await this.session.send('browser.close', {});
            }
            finally {
                this.dispose('Browser already closed.', true);
            }
        }
        async addPreloadScript(functionDeclaration, options = {}) {
            const { result: { script }, } = await this.session.send('script.addPreloadScript', {
                functionDeclaration,
                ...options,
                contexts: options.contexts?.map(context => {
                    return context.id;
                }),
            });
            return script;
        }
        async removeIntercept(intercept) {
            await this.session.send('network.removeIntercept', {
                intercept,
            });
        }
        async removePreloadScript(script) {
            await this.session.send('script.removePreloadScript', {
                script,
            });
        }
        async createUserContext() {
            const { result: { userContext: context }, } = await this.session.send('browser.createUserContext', {});
            return this.#createUserContext(context);
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _close_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _addPreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _removeIntercept_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _removePreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _createUserContext_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Browser was disconnected, probably because the session ended.';
            if (this.closed) {
                this.emit('closed', { reason: this.#reason });
            }
            this.emit('disconnected', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js":
/*!************************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowsingContext: () => (/* binding */ BrowsingContext)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Navigation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Navigation.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js");
/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js");
/* harmony import */ var _UserPrompt_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UserPrompt.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};







/**
 * @internal
 */
let BrowsingContext = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _activate_decorators;
    let _captureScreenshot_decorators;
    let _close_decorators;
    let _traverseHistory_decorators;
    let _navigate_decorators;
    let _reload_decorators;
    let _setCacheBehavior_decorators;
    let _print_decorators;
    let _handleUserPrompt_decorators;
    let _setViewport_decorators;
    let _performActions_decorators;
    let _releaseActions_decorators;
    let _createWindowRealm_decorators;
    let _addPreloadScript_decorators;
    let _addIntercept_decorators;
    let _removePreloadScript_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setFiles_decorators;
    let _subscribe_decorators;
    let _addInterception_decorators;
    let _deleteCookie_decorators;
    let _locateNodes_decorators;
    return class BrowsingContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _deleteCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                    // SAFETY: Disposal implies this exists.
                    return context.#reason;
                })];
            _locateNodes_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                    // SAFETY: Disposal implies this exists.
                    return context.#reason;
                })];
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _activate_decorators, { kind: "method", name: "activate", static: false, private: false, access: { has: obj => "activate" in obj, get: obj => obj.activate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _captureScreenshot_decorators, { kind: "method", name: "captureScreenshot", static: false, private: false, access: { has: obj => "captureScreenshot" in obj, get: obj => obj.captureScreenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: obj => "close" in obj, get: obj => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _traverseHistory_decorators, { kind: "method", name: "traverseHistory", static: false, private: false, access: { has: obj => "traverseHistory" in obj, get: obj => obj.traverseHistory }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _navigate_decorators, { kind: "method", name: "navigate", static: false, private: false, access: { has: obj => "navigate" in obj, get: obj => obj.navigate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _reload_decorators, { kind: "method", name: "reload", static: false, private: false, access: { has: obj => "reload" in obj, get: obj => obj.reload }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCacheBehavior_decorators, { kind: "method", name: "setCacheBehavior", static: false, private: false, access: { has: obj => "setCacheBehavior" in obj, get: obj => obj.setCacheBehavior }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _print_decorators, { kind: "method", name: "print", static: false, private: false, access: { has: obj => "print" in obj, get: obj => obj.print }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _handleUserPrompt_decorators, { kind: "method", name: "handleUserPrompt", static: false, private: false, access: { has: obj => "handleUserPrompt" in obj, get: obj => obj.handleUserPrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setViewport_decorators, { kind: "method", name: "setViewport", static: false, private: false, access: { has: obj => "setViewport" in obj, get: obj => obj.setViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _performActions_decorators, { kind: "method", name: "performActions", static: false, private: false, access: { has: obj => "performActions" in obj, get: obj => obj.performActions }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _releaseActions_decorators, { kind: "method", name: "releaseActions", static: false, private: false, access: { has: obj => "releaseActions" in obj, get: obj => obj.releaseActions }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createWindowRealm_decorators, { kind: "method", name: "createWindowRealm", static: false, private: false, access: { has: obj => "createWindowRealm" in obj, get: obj => obj.createWindowRealm }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: obj => "addPreloadScript" in obj, get: obj => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addIntercept_decorators, { kind: "method", name: "addIntercept", static: false, private: false, access: { has: obj => "addIntercept" in obj, get: obj => obj.addIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: obj => "removePreloadScript" in obj, get: obj => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: obj => "getCookies" in obj, get: obj => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: obj => "setCookie" in obj, get: obj => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: obj => "setFiles" in obj, get: obj => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: obj => "subscribe" in obj, get: obj => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addInterception_decorators, { kind: "method", name: "addInterception", static: false, private: false, access: { has: obj => "addInterception" in obj, get: obj => obj.addInterception }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _deleteCookie_decorators, { kind: "method", name: "deleteCookie", static: false, private: false, access: { has: obj => "deleteCookie" in obj, get: obj => obj.deleteCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: obj => "locateNodes" in obj, get: obj => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(userContext, parent, id, url, originalOpener) {
            const browsingContext = new BrowsingContext(userContext, parent, id, url, originalOpener);
            browsingContext.#initialize();
            return browsingContext;
        }
        #navigation = __runInitializers(this, _instanceExtraInitializers);
        #reason;
        #url;
        #children = new Map();
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #realms = new Map();
        #requests = new Map();
        defaultRealm;
        id;
        parent;
        userContext;
        originalOpener;
        constructor(context, parent, id, url, originalOpener) {
            super();
            this.#url = url;
            this.id = id;
            this.parent = parent;
            this.userContext = context;
            this.originalOpener = originalOpener;
            this.defaultRealm = this.#createWindowRealm();
        }
        #initialize() {
            const userContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.userContext));
            userContextEmitter.once('closed', ({ reason }) => {
                this.dispose(`Browsing context already closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.contextCreated', info => {
                if (info.parent !== this.id) {
                    return;
                }
                const browsingContext = BrowsingContext.from(this.userContext, this, info.context, info.url, info.originalOpener);
                this.#children.set(info.context, browsingContext);
                const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(browsingContext));
                browsingContextEmitter.once('closed', () => {
                    browsingContextEmitter.removeAllListeners();
                    this.#children.delete(browsingContext.id);
                });
                this.emit('browsingcontext', { browsingContext });
            });
            sessionEmitter.on('browsingContext.contextDestroyed', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.dispose('Browsing context already closed.');
            });
            sessionEmitter.on('browsingContext.domContentLoaded', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.#url = info.url;
                this.emit('DOMContentLoaded', undefined);
            });
            sessionEmitter.on('browsingContext.load', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.#url = info.url;
                this.emit('load', undefined);
            });
            sessionEmitter.on('browsingContext.navigationStarted', info => {
                if (info.context !== this.id) {
                    return;
                }
                // Note: we should not update this.#url at this point since the context
                // has not finished navigating to the info.url yet.
                for (const [id, request] of this.#requests) {
                    if (request.disposed) {
                        this.#requests.delete(id);
                    }
                }
                // If the navigation hasn't finished, then this is nested navigation. The
                // current navigation will handle this.
                if (this.#navigation !== undefined && !this.#navigation.disposed) {
                    return;
                }
                // Note the navigation ID is null for this event.
                this.#navigation = _Navigation_js__WEBPACK_IMPORTED_MODULE_3__.Navigation.from(this);
                const navigationEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#navigation));
                for (const eventName of ['fragment', 'failed', 'aborted']) {
                    navigationEmitter.once(eventName, ({ url }) => {
                        navigationEmitter[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
                        this.#url = url;
                    });
                }
                this.emit('navigation', { navigation: this.#navigation });
            });
            sessionEmitter.on('network.beforeRequestSent', event => {
                if (event.context !== this.id) {
                    return;
                }
                if (this.#requests.has(event.request.request)) {
                    // Means the request is a redirect. This is handled in Request.
                    // Or an Auth event was issued
                    return;
                }
                const request = _Request_js__WEBPACK_IMPORTED_MODULE_5__.Request.from(this, event);
                this.#requests.set(request.id, request);
                this.emit('request', { request });
            });
            sessionEmitter.on('log.entryAdded', entry => {
                if (entry.source.context !== this.id) {
                    return;
                }
                this.emit('log', { entry });
            });
            sessionEmitter.on('browsingContext.userPromptOpened', info => {
                if (info.context !== this.id) {
                    return;
                }
                const userPrompt = _UserPrompt_js__WEBPACK_IMPORTED_MODULE_6__.UserPrompt.from(this, info);
                this.emit('userprompt', { userPrompt });
            });
        }
        get #session() {
            return this.userContext.browser.session;
        }
        get children() {
            return this.#children.values();
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get realms() {
            // eslint-disable-next-line @typescript-eslint/no-this-alias -- Required
            const self = this;
            return (function* () {
                yield self.defaultRealm;
                yield* self.#realms.values();
            })();
        }
        get top() {
            let context = this;
            for (let { parent } = context; parent; { parent } = context) {
                context = parent;
            }
            return context;
        }
        get url() {
            return this.#url;
        }
        #createWindowRealm(sandbox) {
            const realm = _Realm_js__WEBPACK_IMPORTED_MODULE_4__.WindowRealm.from(this, sandbox);
            realm.on('worker', realm => {
                this.emit('worker', { realm });
            });
            return realm;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async activate() {
            await this.#session.send('browsingContext.activate', {
                context: this.id,
            });
        }
        async captureScreenshot(options = {}) {
            const { result: { data }, } = await this.#session.send('browsingContext.captureScreenshot', {
                context: this.id,
                ...options,
            });
            return data;
        }
        async close(promptUnload) {
            await Promise.all([...this.#children.values()].map(async (child) => {
                await child.close(promptUnload);
            }));
            await this.#session.send('browsingContext.close', {
                context: this.id,
                promptUnload,
            });
        }
        async traverseHistory(delta) {
            await this.#session.send('browsingContext.traverseHistory', {
                context: this.id,
                delta,
            });
        }
        async navigate(url, wait) {
            await this.#session.send('browsingContext.navigate', {
                context: this.id,
                url,
                wait,
            });
        }
        async reload(options = {}) {
            await this.#session.send('browsingContext.reload', {
                context: this.id,
                ...options,
            });
        }
        async setCacheBehavior(cacheBehavior) {
            // @ts-expect-error not in BiDi types yet.
            await this.#session.send('network.setCacheBehavior', {
                contexts: [this.id],
                cacheBehavior,
            });
        }
        async print(options = {}) {
            const { result: { data }, } = await this.#session.send('browsingContext.print', {
                context: this.id,
                ...options,
            });
            return data;
        }
        async handleUserPrompt(options = {}) {
            await this.#session.send('browsingContext.handleUserPrompt', {
                context: this.id,
                ...options,
            });
        }
        async setViewport(options = {}) {
            await this.#session.send('browsingContext.setViewport', {
                context: this.id,
                ...options,
            });
        }
        async performActions(actions) {
            await this.#session.send('input.performActions', {
                context: this.id,
                actions,
            });
        }
        async releaseActions() {
            await this.#session.send('input.releaseActions', {
                context: this.id,
            });
        }
        createWindowRealm(sandbox) {
            return this.#createWindowRealm(sandbox);
        }
        async addPreloadScript(functionDeclaration, options = {}) {
            return await this.userContext.browser.addPreloadScript(functionDeclaration, {
                ...options,
                contexts: [this],
            });
        }
        async addIntercept(options) {
            const { result: { intercept }, } = await this.userContext.browser.session.send('network.addIntercept', {
                ...options,
                contexts: [this.id],
            });
            return intercept;
        }
        async removePreloadScript(script) {
            await this.userContext.browser.removePreloadScript(script);
        }
        async getCookies(options = {}) {
            const { result: { cookies }, } = await this.#session.send('storage.getCookies', {
                ...options,
                partition: {
                    type: 'context',
                    context: this.id,
                },
            });
            return cookies;
        }
        async setCookie(cookie) {
            await this.#session.send('storage.setCookie', {
                cookie,
                partition: {
                    type: 'context',
                    context: this.id,
                },
            });
        }
        async setFiles(element, files) {
            await this.#session.send('input.setFiles', {
                context: this.id,
                element,
                files,
            });
        }
        async subscribe(events) {
            await this.#session.subscribe(events, [this.id]);
        }
        async addInterception(events) {
            await this.#session.subscribe(events, [this.id]);
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _activate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _captureScreenshot_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _close_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _traverseHistory_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _navigate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _reload_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCacheBehavior_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _print_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _handleUserPrompt_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setViewport_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _performActions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _releaseActions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _createWindowRealm_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addPreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addIntercept_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _removePreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _getCookies_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setFiles_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _subscribe_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addInterception_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Browsing context already closed, probably because the user context closed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async deleteCookie(...cookieFilters) {
            await Promise.all(cookieFilters.map(async (filter) => {
                await this.#session.send('storage.deleteCookies', {
                    filter: filter,
                    partition: {
                        type: 'context',
                        context: this.id,
                    },
                });
            }));
        }
        async locateNodes(locator, startNodes) {
            // TODO: add other locateNodes options if needed.
            const result = await this.#session.send('browsingContext.locateNodes', {
                context: this.id,
                locator,
                startNodes: startNodes.length ? startNodes : undefined,
            });
            return result.result.nodes;
        }
    };
})();

//# sourceMappingURL=BrowsingContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Navigation: () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let Navigation = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return class Navigation extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(context) {
            const navigation = new Navigation(context);
            navigation.#initialize();
            return navigation;
        }
        #request = __runInitializers(this, _instanceExtraInitializers);
        #navigation;
        #browsingContext;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #id;
        constructor(context) {
            super();
            this.#browsingContext = context;
        }
        #initialize() {
            const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#browsingContext));
            browsingContextEmitter.once('closed', () => {
                this.emit('failed', {
                    url: this.#browsingContext.url,
                    timestamp: new Date(),
                });
                this.dispose();
            });
            browsingContextEmitter.on('request', ({ request }) => {
                if (request.navigation === undefined ||
                    // If a request with a navigation ID comes in, then the navigation ID is
                    // for this navigation.
                    !this.#matches(request.navigation)) {
                    return;
                }
                this.#request = request;
                this.emit('request', request);
                const requestEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#request));
                requestEmitter.on('redirect', request => {
                    this.#request = request;
                });
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.navigationStarted', info => {
                if (info.context !== this.#browsingContext.id ||
                    this.#navigation !== undefined) {
                    return;
                }
                this.#navigation = Navigation.from(this.#browsingContext);
            });
            for (const eventName of [
                'browsingContext.domContentLoaded',
                'browsingContext.load',
            ]) {
                sessionEmitter.on(eventName, info => {
                    if (info.context !== this.#browsingContext.id ||
                        info.navigation === null ||
                        !this.#matches(info.navigation)) {
                        return;
                    }
                    this.dispose();
                });
            }
            for (const [eventName, event] of [
                ['browsingContext.fragmentNavigated', 'fragment'],
                ['browsingContext.navigationFailed', 'failed'],
                ['browsingContext.navigationAborted', 'aborted'],
            ]) {
                sessionEmitter.on(eventName, info => {
                    if (info.context !== this.#browsingContext.id ||
                        // Note we don't check if `navigation` is null since `null` means the
                        // fragment navigated.
                        !this.#matches(info.navigation)) {
                        return;
                    }
                    this.emit(event, {
                        url: info.url,
                        timestamp: new Date(info.timestamp),
                    });
                    this.dispose();
                });
            }
        }
        #matches(navigation) {
            if (this.#navigation !== undefined && !this.#navigation.disposed) {
                return false;
            }
            if (this.#id === undefined) {
                this.#id = navigation;
                return true;
            }
            return this.#id === navigation;
        }
        get #session() {
            return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
            return this.#disposables.disposed;
        }
        get request() {
            return this.#request;
        }
        get navigation() {
            return this.#navigation;
        }
        dispose() {
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Navigation.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DedicatedWorkerRealm: () => (/* binding */ DedicatedWorkerRealm),
/* harmony export */   Realm: () => (/* binding */ Realm),
/* harmony export */   SharedWorkerRealm: () => (/* binding */ SharedWorkerRealm),
/* harmony export */   WindowRealm: () => (/* binding */ WindowRealm)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var _a;



/**
 * @internal
 */
let Realm = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _disown_decorators;
    let _callFunction_decorators;
    let _evaluate_decorators;
    let _resolveExecutionContextId_decorators;
    return class Realm extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _disown_decorators, { kind: "method", name: "disown", static: false, private: false, access: { has: obj => "disown" in obj, get: obj => obj.disown }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _callFunction_decorators, { kind: "method", name: "callFunction", static: false, private: false, access: { has: obj => "callFunction" in obj, get: obj => obj.callFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: obj => "evaluate" in obj, get: obj => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _resolveExecutionContextId_decorators, { kind: "method", name: "resolveExecutionContextId", static: false, private: false, access: { has: obj => "resolveExecutionContextId" in obj, get: obj => obj.resolveExecutionContextId }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        id;
        origin;
        executionContextId;
        constructor(id, origin) {
            super();
            this.id = id;
            this.origin = origin;
        }
        get disposed() {
            return this.#reason !== undefined;
        }
        get target() {
            return { realm: this.id };
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async disown(handles) {
            await this.session.send('script.disown', {
                target: this.target,
                handles,
            });
        }
        async callFunction(functionDeclaration, awaitPromise, options = {}) {
            const { result } = await this.session.send('script.callFunction', {
                functionDeclaration,
                awaitPromise,
                target: this.target,
                ...options,
            });
            return result;
        }
        async evaluate(expression, awaitPromise, options = {}) {
            const { result } = await this.session.send('script.evaluate', {
                expression,
                awaitPromise,
                target: this.target,
                ...options,
            });
            return result;
        }
        async resolveExecutionContextId() {
            if (!this.executionContextId) {
                const { result } = await this.session.connection.send('cdp.resolveRealm', { realm: this.id });
                this.executionContextId = result.executionContextId;
            }
            return this.executionContextId;
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _disown_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _callFunction_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _evaluate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _resolveExecutionContextId_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Realm already destroyed, probably because all associated browsing contexts closed.';
            this.emit('destroyed', { reason: this.#reason });
            this.disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

/**
 * @internal
 */
class WindowRealm extends Realm {
    static from(context, sandbox) {
        const realm = new WindowRealm(context, sandbox);
        realm.#initialize();
        return realm;
    }
    browsingContext;
    sandbox;
    #workers = new Map();
    constructor(context, sandbox) {
        super('', '');
        this.browsingContext = context;
        this.sandbox = sandbox;
    }
    #initialize() {
        const browsingContextEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browsingContext));
        browsingContextEmitter.on('closed', ({ reason }) => {
            this.dispose(reason);
        });
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'window' ||
                info.context !== this.browsingContext.id ||
                info.sandbox !== this.sandbox) {
                return;
            }
            this.id = info.realm;
            this.origin = info.origin;
            this.executionContextId = undefined;
            this.emit('updated', this);
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                realmEmitter.removeAllListeners();
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        return this.browsingContext.userContext.browser.session;
    }
    get target() {
        return { context: this.browsingContext.id, sandbox: this.sandbox };
    }
}
/**
 * @internal
 */
class DedicatedWorkerRealm extends Realm {
    static from(owner, id, origin) {
        const realm = new _a(owner, id, origin);
        realm.#initialize();
        return realm;
    }
    #workers = new Map();
    owners;
    constructor(owner, id, origin) {
        super(id, origin);
        this.owners = new Set([owner]);
    }
    #initialize() {
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmDestroyed', info => {
            if (info.realm !== this.id) {
                return;
            }
            this.dispose('Realm already destroyed.');
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = _a.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        // SAFETY: At least one owner will exist.
        return this.owners.values().next().value.session;
    }
}
_a = DedicatedWorkerRealm;
/**
 * @internal
 */
class SharedWorkerRealm extends Realm {
    static from(browser, id, origin) {
        const realm = new SharedWorkerRealm(browser, id, origin);
        realm.#initialize();
        return realm;
    }
    #workers = new Map();
    browser;
    constructor(browser, id, origin) {
        super(id, origin);
        this.browser = browser;
    }
    #initialize() {
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmDestroyed', info => {
            if (info.realm !== this.id) {
                return;
            }
            this.dispose('Realm already destroyed.');
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        return this.browser.session;
    }
}
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Request: () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let Request = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return class Request extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, event) {
            const request = new Request(browsingContext, event);
            request.#initialize();
            return request;
        }
        #error = __runInitializers(this, _instanceExtraInitializers);
        #redirect;
        #response;
        #browsingContext;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #event;
        constructor(browsingContext, event) {
            super();
            this.#browsingContext = browsingContext;
            this.#event = event;
        }
        #initialize() {
            const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#browsingContext));
            browsingContextEmitter.once('closed', ({ reason }) => {
                this.#error = reason;
                this.emit('error', this.#error);
                this.dispose();
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('network.beforeRequestSent', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    event.redirectCount !== this.#event.redirectCount + 1) {
                    return;
                }
                this.#redirect = Request.from(this.#browsingContext, event);
                this.emit('redirect', this.#redirect);
                this.dispose();
            });
            sessionEmitter.on('network.authRequired', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    // Don't try to authenticate for events that are not blocked
                    !event.isBlocked) {
                    return;
                }
                this.emit('authenticate', undefined);
            });
            sessionEmitter.on('network.fetchError', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    this.#event.redirectCount !== event.redirectCount) {
                    return;
                }
                this.#error = event.errorText;
                this.emit('error', this.#error);
                this.dispose();
            });
            sessionEmitter.on('network.responseCompleted', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    this.#event.redirectCount !== event.redirectCount) {
                    return;
                }
                this.#response = event.response;
                this.#event.request.timings = event.request.timings;
                this.emit('success', this.#response);
                // In case this is a redirect.
                if (this.#response.status >= 300 && this.#response.status < 400) {
                    return;
                }
                this.dispose();
            });
        }
        get #session() {
            return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
            return this.#disposables.disposed;
        }
        get error() {
            return this.#error;
        }
        get headers() {
            return this.#event.request.headers;
        }
        get id() {
            return this.#event.request.request;
        }
        get initiator() {
            return this.#event.initiator;
        }
        get method() {
            return this.#event.request.method;
        }
        get navigation() {
            return this.#event.navigation ?? undefined;
        }
        get redirect() {
            return this.#redirect;
        }
        get lastRedirect() {
            let redirect = this.#redirect;
            while (redirect) {
                if (redirect && !redirect.#redirect) {
                    return redirect;
                }
                redirect = redirect.#redirect;
            }
            return redirect;
        }
        get response() {
            return this.#response;
        }
        get url() {
            return this.#event.request.url;
        }
        get isBlocked() {
            return this.#event.isBlocked;
        }
        get resourceType() {
            // @ts-expect-error non-standard attribute.
            return this.#event.request['goog:resourceType'] ?? undefined;
        }
        get postData() {
            // @ts-expect-error non-standard attribute.
            return this.#event.request['goog:postData'] ?? undefined;
        }
        get hasPostData() {
            // @ts-expect-error non-standard attribute.
            return this.#event.request['goog:hasPostData'] ?? false;
        }
        async continueRequest({ url, method, headers, cookies, body, }) {
            await this.#session.send('network.continueRequest', {
                request: this.id,
                url,
                method,
                headers,
                body,
                cookies,
            });
        }
        async failRequest() {
            await this.#session.send('network.failRequest', {
                request: this.id,
            });
        }
        async provideResponse({ statusCode, reasonPhrase, headers, body, }) {
            await this.#session.send('network.provideResponse', {
                request: this.id,
                statusCode,
                reasonPhrase,
                headers,
                body,
            });
        }
        async continueWithAuth(parameters) {
            if (parameters.action === 'provideCredentials') {
                await this.#session.send('network.continueWithAuth', {
                    request: this.id,
                    action: parameters.action,
                    credentials: parameters.credentials,
                });
            }
            else {
                await this.#session.send('network.continueWithAuth', {
                    request: this.id,
                    action: parameters.action,
                });
            }
        }
        dispose() {
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        timing() {
            return this.#event.request.timings;
        }
    };
})();

//# sourceMappingURL=Request.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Session: () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Browser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};




/**
 * @internal
 */
let Session = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _connection_decorators;
    let _connection_initializers = [];
    let _connection_extraInitializers = [];
    let _dispose_decorators;
    let _send_decorators;
    let _subscribe_decorators;
    let _addIntercepts_decorators;
    let _end_decorators;
    return class Session extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _connection_decorators, { kind: "accessor", name: "connection", static: false, private: false, access: { has: obj => "connection" in obj, get: obj => obj.connection, set: (obj, value) => { obj.connection = value; } }, metadata: _metadata }, _connection_initializers, _connection_extraInitializers);
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _send_decorators, { kind: "method", name: "send", static: false, private: false, access: { has: obj => "send" in obj, get: obj => obj.send }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: obj => "subscribe" in obj, get: obj => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addIntercepts_decorators, { kind: "method", name: "addIntercepts", static: false, private: false, access: { has: obj => "addIntercepts" in obj, get: obj => obj.addIntercepts }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _end_decorators, { kind: "method", name: "end", static: false, private: false, access: { has: obj => "end" in obj, get: obj => obj.end }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(connection, capabilities) {
            const { result } = await connection.send('session.new', {
                capabilities,
            });
            const session = new Session(connection, result);
            await session.#initialize();
            return session;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #info;
        browser;
        #connection_accessor_storage = __runInitializers(this, _connection_initializers, void 0);
        get connection() { return this.#connection_accessor_storage; }
        set connection(value) { this.#connection_accessor_storage = value; }
        constructor(connection, info) {
            super();
            __runInitializers(this, _connection_extraInitializers);
            this.#info = info;
            this.connection = connection;
        }
        async #initialize() {
            // SAFETY: We use `any` to allow assignment of the readonly property.
            this.browser = await _Browser_js__WEBPACK_IMPORTED_MODULE_3__.Browser.from(this);
            const browserEmitter = this.#disposables.use(this.browser);
            browserEmitter.once('closed', ({ reason }) => {
                this.dispose(reason);
            });
            // TODO: Currently, some implementations do not emit navigationStarted event
            // for fragment navigations (as per spec) and some do. This could emits a
            // synthetic navigationStarted to work around this inconsistency.
            const seen = new WeakSet();
            this.on('browsingContext.fragmentNavigated', info => {
                if (seen.has(info)) {
                    return;
                }
                seen.add(info);
                this.emit('browsingContext.navigationStarted', info);
                this.emit('browsingContext.fragmentNavigated', info);
            });
        }
        get capabilities() {
            return this.#info.capabilities;
        }
        get disposed() {
            return this.ended;
        }
        get ended() {
            return this.#reason !== undefined;
        }
        get id() {
            return this.#info.sessionId;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        /**
         * Currently, there is a 1:1 relationship between the session and the
         * session. In the future, we might support multiple sessions and in that
         * case we always needs to make sure that the session for the right session
         * object is used, so we implement this method here, although it's not defined
         * in the spec.
         */
        async send(method, params) {
            return await this.connection.send(method, params);
        }
        async subscribe(events, contexts) {
            await this.send('session.subscribe', {
                events,
                contexts,
            });
        }
        async addIntercepts(events, contexts) {
            await this.send('session.subscribe', {
                events,
                contexts,
            });
        }
        async end() {
            try {
                await this.send('session.end', {});
            }
            finally {
                this.dispose(`Session already ended.`);
            }
        }
        [(_connection_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.bubble)()], _dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _send_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _subscribe_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _addIntercepts_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _end_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Session already destroyed, probably because the connection broke.';
            this.emit('ended', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Session.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js":
/*!********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UserContext: () => (/* binding */ UserContext)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _BrowsingContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BrowsingContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};





/**
 * @internal
 */
let UserContext = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _createBrowsingContext_decorators;
    let _remove_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setPermissions_decorators;
    return class UserContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createBrowsingContext_decorators, { kind: "method", name: "createBrowsingContext", static: false, private: false, access: { has: obj => "createBrowsingContext" in obj, get: obj => obj.createBrowsingContext }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _remove_decorators, { kind: "method", name: "remove", static: false, private: false, access: { has: obj => "remove" in obj, get: obj => obj.remove }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: obj => "getCookies" in obj, get: obj => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: obj => "setCookie" in obj, get: obj => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setPermissions_decorators, { kind: "method", name: "setPermissions", static: false, private: false, access: { has: obj => "setPermissions" in obj, get: obj => obj.setPermissions }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static DEFAULT = 'default';
        static create(browser, id) {
            const context = new UserContext(browser, id);
            context.#initialize();
            return context;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        // Note these are only top-level contexts.
        #browsingContexts = new Map();
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack();
        #id;
        browser;
        constructor(browser, id) {
            super();
            this.#id = id;
            this.browser = browser;
        }
        #initialize() {
            const browserEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browser));
            browserEmitter.once('closed', ({ reason }) => {
                this.dispose(`User context was closed: ${reason}`);
            });
            browserEmitter.once('disconnected', ({ reason }) => {
                this.dispose(`User context was closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.contextCreated', info => {
                if (info.parent) {
                    return;
                }
                if (info.userContext !== this.#id) {
                    return;
                }
                const browsingContext = _BrowsingContext_js__WEBPACK_IMPORTED_MODULE_4__.BrowsingContext.from(this, undefined, info.context, info.url, info.originalOpener);
                this.#browsingContexts.set(browsingContext.id, browsingContext);
                const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(browsingContext));
                browsingContextEmitter.on('closed', () => {
                    browsingContextEmitter.removeAllListeners();
                    this.#browsingContexts.delete(browsingContext.id);
                });
                this.emit('browsingcontext', { browsingContext });
            });
        }
        get #session() {
            return this.browser.session;
        }
        get browsingContexts() {
            return this.#browsingContexts.values();
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get id() {
            return this.#id;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol]();
        }
        async createBrowsingContext(type, options = {}) {
            const { result: { context: contextId }, } = await this.#session.send('browsingContext.create', {
                type,
                ...options,
                referenceContext: options.referenceContext?.id,
                userContext: this.#id,
            });
            const browsingContext = this.#browsingContexts.get(contextId);
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(browsingContext, 'The WebDriver BiDi implementation is failing to create a browsing context correctly.');
            // We use an array to avoid the promise from being awaited.
            return browsingContext;
        }
        async remove() {
            try {
                await this.#session.send('browser.removeUserContext', {
                    userContext: this.#id,
                });
            }
            finally {
                this.dispose('User context already closed.');
            }
        }
        async getCookies(options = {}, sourceOrigin = undefined) {
            const { result: { cookies }, } = await this.#session.send('storage.getCookies', {
                ...options,
                partition: {
                    type: 'storageKey',
                    userContext: this.#id,
                    sourceOrigin,
                },
            });
            return cookies;
        }
        async setCookie(cookie, sourceOrigin) {
            await this.#session.send('storage.setCookie', {
                cookie,
                partition: {
                    type: 'storageKey',
                    sourceOrigin,
                    userContext: this.id,
                },
            });
        }
        async setPermissions(origin, descriptor, state) {
            await this.#session.send('permissions.setPermission', {
                origin,
                descriptor,
                state,
                userContext: this.#id,
            });
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.inertIfDisposed], _createBrowsingContext_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _remove_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _getCookies_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setPermissions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol)]() {
            this.#reason ??=
                'User context already closed, probably because the browser disconnected/closed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=UserContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UserPrompt: () => (/* binding */ UserPrompt)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let UserPrompt = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _handle_decorators;
    return class UserPrompt extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _handle_decorators, { kind: "method", name: "handle", static: false, private: false, access: { has: obj => "handle" in obj, get: obj => obj.handle }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, info) {
            const userPrompt = new UserPrompt(browsingContext, info);
            userPrompt.#initialize();
            return userPrompt;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        #result;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        browsingContext;
        info;
        constructor(context, info) {
            super();
            this.browsingContext = context;
            this.info = info;
        }
        #initialize() {
            const browserContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browsingContext));
            browserContextEmitter.once('closed', ({ reason }) => {
                this.dispose(`User prompt already closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.userPromptClosed', parameters => {
                if (parameters.context !== this.browsingContext.id) {
                    return;
                }
                this.#result = parameters;
                this.emit('handled', parameters);
                this.dispose('User prompt already handled.');
            });
        }
        get #session() {
            return this.browsingContext.userContext.browser.session;
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get handled() {
            if (this.info.handler === "accept" /* Bidi.Session.UserPromptHandlerType.Accept */ ||
                this.info.handler === "dismiss" /* Bidi.Session.UserPromptHandlerType.Dismiss */) {
                return true;
            }
            return this.#result !== undefined;
        }
        get result() {
            return this.#result;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async handle(options = {}) {
            await this.#session.send('browsingContext.handleUserPrompt', {
                ...options,
                context: this.info.context,
            });
            // SAFETY: `handled` is triggered before the above promise resolved.
            return this.#result;
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _handle_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(prompt => {
                // SAFETY: Disposal implies this exists.
                return prompt.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'User prompt already closed, probably because the associated browsing context was destroyed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=UserPrompt.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEvaluationError: () => (/* binding */ createEvaluationError),
/* harmony export */   rewriteNavigationError: () => (/* binding */ rewriteNavigationError)
/* harmony export */ });
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
function createEvaluationError(details) {
    if (details.exception.type !== 'error') {
        return _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__.BidiDeserializer.deserialize(details.exception);
    }
    const [name = '', ...parts] = details.text.split(': ');
    const message = parts.join(': ');
    const error = new Error(message);
    error.name = name;
    // The first line is this function which we ignore.
    const stackLines = [];
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
        for (const frame of details.stackTrace.callFrames.reverse()) {
            if (_common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.isPuppeteerURL(frame.url) &&
                frame.url !== _common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.INTERNAL_URL) {
                const url = _common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.parse(frame.url);
                stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
            }
            else {
                stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
            }
            if (stackLines.length >= Error.stackTraceLimit) {
                break;
            }
        }
    }
    error.stack = [details.text, ...stackLines].join('\n');
    return error;
}
/**
 * @internal
 */
function rewriteNavigationError(message, ms) {
    return error => {
        if (error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError) {
            error.message += ` at ${message}`;
        }
        else if (error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError) {
            error.message = `Navigation timeout of ${ms} ms exceeded`;
        }
        throw error;
    };
}
//# sourceMappingURL=util.js.map

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcHVwcGV0ZWVyLWNvcmVfbGliX2VzbV9wdXBwZXRlZXJfYmlkaV9iaWRpX2pzLmNqcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQy9DLDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCx3QkFBd0IsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDMUQsZ0RBQStDLEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2pJLDJCQUEyQixtQkFBTyxDQUFDLGdHQUFzQjtBQUN6RCxtREFBa0QsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDMUk7Ozs7Ozs7Ozs7O0FDOUJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUIsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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QTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QXlCO0FBQ3pCOzs7Ozs7Ozs7OztBQ2pDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqUmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1DQUFtQyxpQkFBaUIsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixtREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFD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YTtBQUM5QjtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBLGtCQUFrQiw4REFBYTtBQUMvQjtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tFO0FBQ2pCO0FBQ0k7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsOERBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBWTtBQUM1Qiw4QkFBOEIseURBQVk7QUFDMUMsNEJBQTRCLHlEQUFZO0FBQ3hDLDZDQUE2Qyx3Q0FBd0MsR0FBRyxrQkFBa0IsS0FBSyxlQUFlLGdCQUFnQixpQkFBaUIsR0FBRyxtQkFBbUI7QUFDckw7QUFDQTtBQUNBLDBDQUEwQyxxQ0FBcUMsR0FBRyxVQUFVLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2QkFBNkIsNERBQWE7QUFDMUMsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQSxrQ0FBa0MsMkRBQVk7QUFDOUMscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9CaWRpTWFwcGVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9CaWRpTm9PcFBhcnNlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvQmlkaVNlcnZlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvQ29tbWFuZFByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvT3V0Z29pbmdNZXNzYWdlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2Jyb3dzZXIvQnJvd3NlclByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9jZHAvQ2RwUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2NkcC9DZHBUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvY2RwL0NkcFRhcmdldE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvY29udGV4dC9Ccm93c2luZ0NvbnRleHRJbXBsLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2NvbnRleHQvQnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2NvbnRleHQvQnJvd3NpbmdDb250ZXh0U3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9pbnB1dC9BY3Rpb25EaXNwYXRjaGVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2lucHV0L0lucHV0UHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2lucHV0L0lucHV0U291cmNlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2lucHV0L0lucHV0U3RhdGUuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvaW5wdXQvSW5wdXRTdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvaW5wdXQvVVNLZXlib2FyZExheW91dC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9pbnB1dC9rZXlVdGlscy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9sb2cvTG9nTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9sb2cvbG9nSGVscGVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL25ldHdvcmsvTmV0d29ya1Byb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9uZXR3b3JrL05ldHdvcmtSZXF1ZXN0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL25ldHdvcmsvTmV0d29ya1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvbmV0d29yay9OZXR3b3JrVXRpbHMuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvcGVybWlzc2lvbnMvUGVybWlzc2lvbnNQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L0NoYW5uZWxQcm94eS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvUHJlbG9hZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvUHJlbG9hZFNjcmlwdFN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L1JlYWxtLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3NjcmlwdC9SZWFsbVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L1NjcmlwdFByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvU2hhcmVkSWQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L1dpbmRvd1JlYWxtLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3NjcmlwdC9Xb3JrZXJSZWFsbS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zZXNzaW9uL0V2ZW50TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zZXNzaW9uL1Nlc3Npb25Qcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2Vzc2lvbi9TdWJzY3JpcHRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3Nlc3Npb24vZXZlbnRzLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3N0b3JhZ2UvU3RvcmFnZVByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3Byb3RvY29sL0Vycm9yUmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9jZHAuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9jaHJvbWl1bS1iaWRpLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvcHJvdG9jb2wvZ2VuZXJhdGVkL3dlYmRyaXZlci1iaWRpLXBlcm1pc3Npb25zLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvcHJvdG9jb2wvZ2VuZXJhdGVkL3dlYmRyaXZlci1iaWRpLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvcHJvdG9jb2wvcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9CYXNlNjQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9CdWZmZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9EZWZhdWx0TWFwLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvdXRpbHMvRGVmZXJyZWQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9EaXN0aW5jdFZhbHVlcy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0dyYXBoZW1lVG9vbHMuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9JZFdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9NdXRleC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL1Byb2Nlc3NpbmdRdWV1ZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL1VybFBhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy91bml0Q29udmVyc2lvbnMuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy91dWlkLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy91cmxwYXR0ZXJuLXBvbHlmaWxsL2Rpc3QvdXJscGF0dGVybi5janMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvaW5kZXguY2pzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9taXR0L2Rpc3QvbWl0dC5tanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvQmlkaU92ZXJDZHAuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9Ccm93c2VyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9DRFBTZXNzaW9uLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0Nvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvRGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0RpYWxvZy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9FbGVtZW50SGFuZGxlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0V4cG9zZWRGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9GcmFtZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9IVFRQUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9IVFRQUmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvSlNIYW5kbGUuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvUGFnZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9SZWFsbS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9TZXJpYWxpemVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL1RhcmdldC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9XZWJXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvYmlkaS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9jb3JlL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9Ccm93c2luZ0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9OYXZpZ2F0aW9uLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL2NvcmUvUmVhbG0uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9SZXF1ZXN0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL2NvcmUvU2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9jb3JlL1VzZXJDb250ZXh0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL2NvcmUvVXNlclByb21wdC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk91dGdvaW5nTWVzc2FnZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5CaWRpU2VydmVyID0gdm9pZCAwO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBlbnRyeSBwb2ludCB0byB0aGUgQmlEaSBNYXBwZXIgbmFtZXNwYWNlLlxuICogT3RoZXIgbW9kdWxlcyBzaG91bGQgb25seSBhY2Nlc3MgZXhwb3J0cyBkZWZpbmVkIGluIHRoaXMgZmlsZS5cbiAqIFhYWDogQWRkIEVTbGludCBydWxlIGZvciB0aGlzIChodHRwczovL2dpdGh1Yi5jb20vaW1wb3J0LWpzL2VzbGludC1wbHVnaW4taW1wb3J0L2Jsb2IvbWFpbi9kb2NzL3J1bGVzL25vLXJlc3RyaWN0ZWQtcGF0aHMubWQpXG4gKi9cbnZhciBCaWRpU2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi9CaWRpU2VydmVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlkaVNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlkaVNlcnZlcl9qc18xLkJpZGlTZXJ2ZXI7IH0gfSk7XG52YXIgRXZlbnRFbWl0dGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRXZlbnRFbWl0dGVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRFbWl0dGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXI7IH0gfSk7XG52YXIgT3V0Z29pbmdNZXNzYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9PdXRnb2luZ01lc3NhZ2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPdXRnb2luZ01lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE91dGdvaW5nTWVzc2FnZV9qc18xLk91dGdvaW5nTWVzc2FnZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZGlNYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmlkaU5vT3BQYXJzZXIgPSB2b2lkIDA7XG5jbGFzcyBCaWRpTm9PcFBhcnNlciB7XG4gICAgLy8gQnJvd3NlciBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZVJlbW92ZVVzZXJDb250ZXh0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBCcm93c2luZyBDb250ZXh0IGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlQWN0aXZhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlQ2FwdHVyZVNjcmVlbnNob3RQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlQ2xvc2VQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUdldFRyZWVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlSGFuZGxlVXNlclByb21wdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VMb2NhdGVOb2Rlc1BhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VOYXZpZ2F0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VQcmludFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VSZWxvYWRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlU2V0Vmlld3BvcnRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlVHJhdmVyc2VIaXN0b3J5UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBDRFAgZG9tYWluXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgcGFyc2VHZXRTZXNzaW9uUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVJlc29sdmVSZWFsbVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VTZW5kQ29tbWFuZFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgLy8gU2NyaXB0IGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlQWRkUHJlbG9hZFNjcmlwdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VDYWxsRnVuY3Rpb25QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlRGlzb3duUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUV2YWx1YXRlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUdldFJlYWxtc1BhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VSZW1vdmVQcmVsb2FkU2NyaXB0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBJbnB1dCBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZVBlcmZvcm1BY3Rpb25zUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVJlbGVhc2VBY3Rpb25zUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVNldEZpbGVzUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBOZXR3b3JrIGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlQWRkSW50ZXJjZXB0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUNvbnRpbnVlUmVxdWVzdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VDb250aW51ZVJlc3BvbnNlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUNvbnRpbnVlV2l0aEF1dGhQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlRmFpbFJlcXVlc3RQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlUHJvdmlkZVJlc3BvbnNlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVJlbW92ZUludGVyY2VwdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgLy8gUGVybWlzc2lvbnMgZG9tYWluXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgcGFyc2VTZXRQZXJtaXNzaW9uc1BhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgLy8gU2Vzc2lvbiBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZVN1YnNjcmliZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgLy8gU3RvcmFnZSBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZURlbGV0ZUNvb2tpZXNQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlR2V0Q29va2llc1BhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VTZXRDb29raWVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuZXhwb3J0cy5CaWRpTm9PcFBhcnNlciA9IEJpZGlOb09wUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmlkaU5vT3BQYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmlkaVNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IEV2ZW50RW1pdHRlcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL0V2ZW50RW1pdHRlci5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IFByb2Nlc3NpbmdRdWV1ZV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL1Byb2Nlc3NpbmdRdWV1ZS5qc1wiKTtcbmNvbnN0IENvbW1hbmRQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRQcm9jZXNzb3IuanNcIik7XG5jb25zdCBDZHBUYXJnZXRNYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2NkcC9DZHBUYXJnZXRNYW5hZ2VyLmpzXCIpO1xuY29uc3QgQnJvd3NpbmdDb250ZXh0U3RvcmFnZV9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9jb250ZXh0L0Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuanNcIik7XG5jb25zdCBOZXR3b3JrU3RvcmFnZV9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9uZXR3b3JrL05ldHdvcmtTdG9yYWdlLmpzXCIpO1xuY29uc3QgUHJlbG9hZFNjcmlwdFN0b3JhZ2VfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2NyaXB0L1ByZWxvYWRTY3JpcHRTdG9yYWdlLmpzXCIpO1xuY29uc3QgUmVhbG1TdG9yYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3NjcmlwdC9SZWFsbVN0b3JhZ2UuanNcIik7XG5jb25zdCBFdmVudE1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2Vzc2lvbi9FdmVudE1hbmFnZXIuanNcIik7XG5jbGFzcyBCaWRpU2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyX2pzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAjbWVzc2FnZVF1ZXVlO1xuICAgICN0cmFuc3BvcnQ7XG4gICAgI2NvbW1hbmRQcm9jZXNzb3I7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IG5ldyBCcm93c2luZ0NvbnRleHRTdG9yYWdlX2pzXzEuQnJvd3NpbmdDb250ZXh0U3RvcmFnZSgpO1xuICAgICNyZWFsbVN0b3JhZ2UgPSBuZXcgUmVhbG1TdG9yYWdlX2pzXzEuUmVhbG1TdG9yYWdlKCk7XG4gICAgI3ByZWxvYWRTY3JpcHRTdG9yYWdlID0gbmV3IFByZWxvYWRTY3JpcHRTdG9yYWdlX2pzXzEuUHJlbG9hZFNjcmlwdFN0b3JhZ2UoKTtcbiAgICAjbG9nZ2VyO1xuICAgICNoYW5kbGVJbmNvbWluZ01lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICB2b2lkIHRoaXMuI2NvbW1hbmRQcm9jZXNzb3IucHJvY2Vzc0NvbW1hbmQobWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAjcHJvY2Vzc091dGdvaW5nTWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlRW50cnkpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VFbnRyeS5tZXNzYWdlO1xuICAgICAgICBpZiAobWVzc2FnZUVudHJ5LmNoYW5uZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VbJ2NoYW5uZWwnXSA9IG1lc3NhZ2VFbnRyeS5jaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI3RyYW5zcG9ydC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKGJpZGlUcmFuc3BvcnQsIGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHNlbGZUYXJnZXRJZCwgZGVmYXVsdFVzZXJDb250ZXh0SWQsIHBhcnNlciwgbG9nZ2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy4jbWVzc2FnZVF1ZXVlID0gbmV3IFByb2Nlc3NpbmdRdWV1ZV9qc18xLlByb2Nlc3NpbmdRdWV1ZSh0aGlzLiNwcm9jZXNzT3V0Z29pbmdNZXNzYWdlLCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQgPSBiaWRpVHJhbnNwb3J0O1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQuc2V0T25NZXNzYWdlKHRoaXMuI2hhbmRsZUluY29taW5nTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXJfanNfMS5FdmVudE1hbmFnZXIodGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtTdG9yYWdlID0gbmV3IE5ldHdvcmtTdG9yYWdlX2pzXzEuTmV0d29ya1N0b3JhZ2UodGhpcy4jZXZlbnRNYW5hZ2VyLCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLCBicm93c2VyQ2RwQ2xpZW50LCBsb2dnZXIpO1xuICAgICAgICB0aGlzLiNjb21tYW5kUHJvY2Vzc29yID0gbmV3IENvbW1hbmRQcm9jZXNzb3JfanNfMS5Db21tYW5kUHJvY2Vzc29yKGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgdGhpcy4jcmVhbG1TdG9yYWdlLCB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZSwgbmV0d29ya1N0b3JhZ2UsIHBhcnNlciwgYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gaWdub3JlIGNlcnRpZmljYXRlIGVycm9ycyB3aGVuIHNlcnZpY2Ugd29ya2VyIGlzIGZldGNoZWQuXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdTZWN1cml0eS5zZXRJZ25vcmVDZXJ0aWZpY2F0ZUVycm9ycycsIHtcbiAgICAgICAgICAgICAgICBpZ25vcmU6IG9wdGlvbnMuYWNjZXB0SW5zZWN1cmVDZXJ0cyA/PyBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3IENkcFRhcmdldE1hbmFnZXJfanNfMS5DZHBUYXJnZXRNYW5hZ2VyKGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHNlbGZUYXJnZXRJZCwgdGhpcy4jZXZlbnRNYW5hZ2VyLCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZSwgZGVmYXVsdFVzZXJDb250ZXh0SWQsIG9wdGlvbnM/LnVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpO1xuICAgICAgICAgICAgLy8gTmVlZGVkIHRvIGdldCBldmVudHMgYWJvdXQgbmV3IHRhcmdldHMuXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuc2V0RGlzY292ZXJUYXJnZXRzJywge1xuICAgICAgICAgICAgICAgIGRpc2NvdmVyOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOZWVkZWQgdG8gYXV0b21hdGljYWxseSBhdHRhY2ggdG8gbmV3IHRhcmdldHMuXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuc2V0QXV0b0F0dGFjaCcsIHtcbiAgICAgICAgICAgICAgICBhdXRvQXR0YWNoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdhaXRGb3JEZWJ1Z2dlck9uU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jdG9wTGV2ZWxDb250ZXh0c0xvYWRlZCgpO1xuICAgICAgICB9LCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIub24oXCJldmVudFwiIC8qIEV2ZW50TWFuYWdlckV2ZW50cy5FdmVudCAqLywgKHsgbWVzc2FnZSwgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0T3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRQcm9jZXNzb3Iub24oXCJyZXNwb25zZVwiIC8qIENvbW1hbmRQcm9jZXNzb3JFdmVudHMuUmVzcG9uc2UgKi8sICh7IG1lc3NhZ2UsIGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdE91dGdvaW5nTWVzc2FnZShtZXNzYWdlLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgQmlEaSBNYXBwZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZUFuZFN0YXJ0KGJpZGlUcmFuc3BvcnQsIGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHNlbGZUYXJnZXRJZCwgcGFyc2VyLCBsb2dnZXIpIHtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgY29udGV4dCBpcyBub3QgZXhwb3NlZCBpbiBUYXJnZXQuZ2V0QnJvd3NlckNvbnRleHRzIGJ1dCBjYW5cbiAgICAgICAgLy8gYmUgb2JzZXJ2ZWQgdmlhIFRhcmdldC5nZXRUYXJnZXRzLiBUbyBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgYnJvd3NlclxuICAgICAgICAvLyBjb250ZXh0LCB3ZSBjaGVjayB3aGljaCBvbmUgaXMgbWVudGlvbmVkIGluIFRhcmdldC5nZXRUYXJnZXRzIGFuZCBub3QgaW5cbiAgICAgICAgLy8gVGFyZ2V0LmdldEJyb3dzZXJDb250ZXh0cy5cbiAgICAgICAgY29uc3QgW3sgYnJvd3NlckNvbnRleHRJZHMgfSwgeyB0YXJnZXRJbmZvcyB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGJyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1RhcmdldC5nZXRCcm93c2VyQ29udGV4dHMnKSxcbiAgICAgICAgICAgIGJyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1RhcmdldC5nZXRUYXJnZXRzJyksXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgZGVmYXVsdFVzZXJDb250ZXh0SWQgPSAnZGVmYXVsdCc7XG4gICAgICAgIGZvciAoY29uc3QgaW5mbyBvZiB0YXJnZXRJbmZvcykge1xuICAgICAgICAgICAgaWYgKGluZm8uYnJvd3NlckNvbnRleHRJZCAmJlxuICAgICAgICAgICAgICAgICFicm93c2VyQ29udGV4dElkcy5pbmNsdWRlcyhpbmZvLmJyb3dzZXJDb250ZXh0SWQpKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFVzZXJDb250ZXh0SWQgPSBpbmZvLmJyb3dzZXJDb250ZXh0SWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmVyID0gbmV3IEJpZGlTZXJ2ZXIoYmlkaVRyYW5zcG9ydCwgY2RwQ29ubmVjdGlvbiwgYnJvd3NlckNkcENsaWVudCwgc2VsZlRhcmdldElkLCBkZWZhdWx0VXNlckNvbnRleHRJZCwgcGFyc2VyLCBsb2dnZXIpO1xuICAgICAgICByZXR1cm4gc2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBCaURpIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZW1pdE91dGdvaW5nTWVzc2FnZShtZXNzYWdlRW50cnksIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuI21lc3NhZ2VRdWV1ZS5hZGQobWVzc2FnZUVudHJ5LCBldmVudCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgI3RvcExldmVsQ29udGV4dHNMb2FkZWQoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2VcbiAgICAgICAgICAgIC5nZXRUb3BMZXZlbENvbnRleHRzKClcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IGMubGlmZWN5Y2xlTG9hZGVkKCkpKTtcbiAgICB9XG59XG5leHBvcnRzLkJpZGlTZXJ2ZXIgPSBCaWRpU2VydmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmlkaVNlcnZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IEV2ZW50RW1pdHRlcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL0V2ZW50RW1pdHRlci5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IEJpZGlOb09wUGFyc2VyX2pzXzEgPSByZXF1aXJlKFwiLi9CaWRpTm9PcFBhcnNlci5qc1wiKTtcbmNvbnN0IEJyb3dzZXJQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYnJvd3Nlci9Ccm93c2VyUHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgQ2RwUHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2NkcC9DZHBQcm9jZXNzb3IuanNcIik7XG5jb25zdCBCcm93c2luZ0NvbnRleHRQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY29udGV4dC9Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IuanNcIik7XG5jb25zdCBJbnB1dFByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9pbnB1dC9JbnB1dFByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IE5ldHdvcmtQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvbmV0d29yay9OZXR3b3JrUHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgUGVybWlzc2lvbnNQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcGVybWlzc2lvbnMvUGVybWlzc2lvbnNQcm9jZXNzb3IuanNcIik7XG5jb25zdCBTY3JpcHRQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2NyaXB0L1NjcmlwdFByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IFNlc3Npb25Qcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2Vzc2lvbi9TZXNzaW9uUHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgU3RvcmFnZVByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zdG9yYWdlL1N0b3JhZ2VQcm9jZXNzb3IuanNcIik7XG5jb25zdCBPdXRnb2luZ01lc3NhZ2VfanNfMSA9IHJlcXVpcmUoXCIuL091dGdvaW5nTWVzc2FnZS5qc1wiKTtcbmNsYXNzIENvbW1hbmRQcm9jZXNzb3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0XG4gICAgI2Jyb3dzZXJQcm9jZXNzb3I7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3NvcjtcbiAgICAjY2RwUHJvY2Vzc29yO1xuICAgICNpbnB1dFByb2Nlc3NvcjtcbiAgICAjbmV0d29ya1Byb2Nlc3NvcjtcbiAgICAjcGVybWlzc2lvbnNQcm9jZXNzb3I7XG4gICAgI3NjcmlwdFByb2Nlc3NvcjtcbiAgICAjc2Vzc2lvblByb2Nlc3NvcjtcbiAgICAjc3RvcmFnZVByb2Nlc3NvcjtcbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAjcGFyc2VyO1xuICAgICNsb2dnZXI7XG4gICAgY29uc3RydWN0b3IoY2RwQ29ubmVjdGlvbiwgYnJvd3NlckNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIHByZWxvYWRTY3JpcHRTdG9yYWdlLCBuZXR3b3JrU3RvcmFnZSwgcGFyc2VyID0gbmV3IEJpZGlOb09wUGFyc2VyX2pzXzEuQmlkaU5vT3BQYXJzZXIoKSwgaW5pdENvbm5lY3Rpb24sIGxvZ2dlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNwYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgIHRoaXMuI2Jyb3dzZXJQcm9jZXNzb3IgPSBuZXcgQnJvd3NlclByb2Nlc3Nvcl9qc18xLkJyb3dzZXJQcm9jZXNzb3IoYnJvd3NlckNkcENsaWVudCk7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3NvciA9IG5ldyBCcm93c2luZ0NvbnRleHRQcm9jZXNzb3JfanNfMS5Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IoYnJvd3NlckNkcENsaWVudCwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgZXZlbnRNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy4jY2RwUHJvY2Vzc29yID0gbmV3IENkcFByb2Nlc3Nvcl9qc18xLkNkcFByb2Nlc3Nvcihicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQpO1xuICAgICAgICB0aGlzLiNpbnB1dFByb2Nlc3NvciA9IG5ldyBJbnB1dFByb2Nlc3Nvcl9qc18xLklucHV0UHJvY2Vzc29yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UpO1xuICAgICAgICB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yID0gbmV3IE5ldHdvcmtQcm9jZXNzb3JfanNfMS5OZXR3b3JrUHJvY2Vzc29yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlKTtcbiAgICAgICAgdGhpcy4jcGVybWlzc2lvbnNQcm9jZXNzb3IgPSBuZXcgUGVybWlzc2lvbnNQcm9jZXNzb3JfanNfMS5QZXJtaXNzaW9uc1Byb2Nlc3Nvcihicm93c2VyQ2RwQ2xpZW50KTtcbiAgICAgICAgdGhpcy4jc2NyaXB0UHJvY2Vzc29yID0gbmV3IFNjcmlwdFByb2Nlc3Nvcl9qc18xLlNjcmlwdFByb2Nlc3NvcihldmVudE1hbmFnZXIsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIGxvZ2dlcik7XG4gICAgICAgIHRoaXMuI3Nlc3Npb25Qcm9jZXNzb3IgPSBuZXcgU2Vzc2lvblByb2Nlc3Nvcl9qc18xLlNlc3Npb25Qcm9jZXNzb3IoZXZlbnRNYW5hZ2VyLCBicm93c2VyQ2RwQ2xpZW50LCBpbml0Q29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMuI3N0b3JhZ2VQcm9jZXNzb3IgPSBuZXcgU3RvcmFnZVByb2Nlc3Nvcl9qc18xLlN0b3JhZ2VQcm9jZXNzb3IoYnJvd3NlckNkcENsaWVudCwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbG9nZ2VyKTtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgfVxuICAgIGFzeW5jICNwcm9jZXNzQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Nlc3Npb24uZW5kJzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBCcm93c2VyIGRvbWFpblxuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgICAgICBjYXNlICdicm93c2VyLmNsb3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlclByb2Nlc3Nvci5jbG9zZSgpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5jcmVhdGVVc2VyQ29udGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzZXJQcm9jZXNzb3IuY3JlYXRlVXNlckNvbnRleHQoY29tbWFuZC5wYXJhbXMpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5nZXRVc2VyQ29udGV4dHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2VyUHJvY2Vzc29yLmdldFVzZXJDb250ZXh0cygpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5yZW1vdmVVc2VyQ29udGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzZXJQcm9jZXNzb3IucmVtb3ZlVXNlckNvbnRleHQodGhpcy4jcGFyc2VyLnBhcnNlUmVtb3ZlVXNlckNvbnRleHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gQnJvd3NpbmcgQ29udGV4dCBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmFjdGl2YXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmFjdGl2YXRlKHRoaXMuI3BhcnNlci5wYXJzZUFjdGl2YXRlUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuY2FwdHVyZVNjcmVlbnNob3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IuY2FwdHVyZVNjcmVlbnNob3QodGhpcy4jcGFyc2VyLnBhcnNlQ2FwdHVyZVNjcmVlbnNob3RQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5jbG9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5jbG9zZSh0aGlzLiNwYXJzZXIucGFyc2VDbG9zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmNyZWF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5jcmVhdGUodGhpcy4jcGFyc2VyLnBhcnNlQ3JlYXRlUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuZ2V0VHJlZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5nZXRUcmVlKHRoaXMuI3BhcnNlci5wYXJzZUdldFRyZWVQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5oYW5kbGVVc2VyUHJvbXB0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmhhbmRsZVVzZXJQcm9tcHQodGhpcy4jcGFyc2VyLnBhcnNlSGFuZGxlVXNlclByb21wdFBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmxvY2F0ZU5vZGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmxvY2F0ZU5vZGVzKHRoaXMuI3BhcnNlci5wYXJzZUxvY2F0ZU5vZGVzUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQubmF2aWdhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IubmF2aWdhdGUodGhpcy4jcGFyc2VyLnBhcnNlTmF2aWdhdGVQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5wcmludCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5wcmludCh0aGlzLiNwYXJzZXIucGFyc2VQcmludFBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LnJlbG9hZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5yZWxvYWQodGhpcy4jcGFyc2VyLnBhcnNlUmVsb2FkUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuc2V0Vmlld3BvcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3Iuc2V0Vmlld3BvcnQodGhpcy4jcGFyc2VyLnBhcnNlU2V0Vmlld3BvcnRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC50cmF2ZXJzZUhpc3RvcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IudHJhdmVyc2VIaXN0b3J5KHRoaXMuI3BhcnNlci5wYXJzZVRyYXZlcnNlSGlzdG9yeVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgICAgICAgICAvLyBDRFAgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ2NkcC5nZXRTZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jY2RwUHJvY2Vzc29yLmdldFNlc3Npb24odGhpcy4jcGFyc2VyLnBhcnNlR2V0U2Vzc2lvblBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnY2RwLnJlc29sdmVSZWFsbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NkcFByb2Nlc3Nvci5yZXNvbHZlUmVhbG0odGhpcy4jcGFyc2VyLnBhcnNlUmVzb2x2ZVJlYWxtUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdjZHAuc2VuZENvbW1hbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBQcm9jZXNzb3Iuc2VuZENvbW1hbmQodGhpcy4jcGFyc2VyLnBhcnNlU2VuZENvbW1hbmRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gSW5wdXQgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnBlcmZvcm1BY3Rpb25zJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3IucGVyZm9ybUFjdGlvbnModGhpcy4jcGFyc2VyLnBhcnNlUGVyZm9ybUFjdGlvbnNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnJlbGVhc2VBY3Rpb25zJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3IucmVsZWFzZUFjdGlvbnModGhpcy4jcGFyc2VyLnBhcnNlUmVsZWFzZUFjdGlvbnNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnNldEZpbGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3Iuc2V0RmlsZXModGhpcy4jcGFyc2VyLnBhcnNlU2V0RmlsZXNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gTmV0d29yayBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5hZGRJbnRlcmNlcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmFkZEludGVyY2VwdCh0aGlzLiNwYXJzZXIucGFyc2VBZGRJbnRlcmNlcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmsuY29udGludWVSZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbmV0d29ya1Byb2Nlc3Nvci5jb250aW51ZVJlcXVlc3QodGhpcy4jcGFyc2VyLnBhcnNlQ29udGludWVSZXF1ZXN0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICduZXR3b3JrLmNvbnRpbnVlUmVzcG9uc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmNvbnRpbnVlUmVzcG9uc2UodGhpcy4jcGFyc2VyLnBhcnNlQ29udGludWVSZXNwb25zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5jb250aW51ZVdpdGhBdXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbmV0d29ya1Byb2Nlc3Nvci5jb250aW51ZVdpdGhBdXRoKHRoaXMuI3BhcnNlci5wYXJzZUNvbnRpbnVlV2l0aEF1dGhQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmsuZmFpbFJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmZhaWxSZXF1ZXN0KHRoaXMuI3BhcnNlci5wYXJzZUZhaWxSZXF1ZXN0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICduZXR3b3JrLnByb3ZpZGVSZXNwb25zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25ldHdvcmtQcm9jZXNzb3IucHJvdmlkZVJlc3BvbnNlKHRoaXMuI3BhcnNlci5wYXJzZVByb3ZpZGVSZXNwb25zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5yZW1vdmVJbnRlcmNlcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLnJlbW92ZUludGVyY2VwdCh0aGlzLiNwYXJzZXIucGFyc2VSZW1vdmVJbnRlcmNlcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmsuc2V0Q2FjaGVCZWhhdmlvcic6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKFwiTWV0aG9kICduZXR3b3JrLnNldENhY2hlQmVoYXZpb3InIGlzIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAgICAgICAgIC8vIFBlcm1pc3Npb25zIGRvbWFpblxuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgICAgICBjYXNlICdwZXJtaXNzaW9ucy5zZXRQZXJtaXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVybWlzc2lvbnNQcm9jZXNzb3Iuc2V0UGVybWlzc2lvbnModGhpcy4jcGFyc2VyLnBhcnNlU2V0UGVybWlzc2lvbnNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gU2NyaXB0IGRvbWFpblxuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgICAgICBjYXNlICdzY3JpcHQuYWRkUHJlbG9hZFNjcmlwdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5hZGRQcmVsb2FkU2NyaXB0KHRoaXMuI3BhcnNlci5wYXJzZUFkZFByZWxvYWRTY3JpcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdC5jYWxsRnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzY3JpcHRQcm9jZXNzb3IuY2FsbEZ1bmN0aW9uKHRoaXMuI3BhcnNlci5wYXJzZUNhbGxGdW5jdGlvblBhcmFtcyh0aGlzLiNwcm9jZXNzVGFyZ2V0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSkpO1xuICAgICAgICAgICAgY2FzZSAnc2NyaXB0LmRpc293bic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5kaXNvd24odGhpcy4jcGFyc2VyLnBhcnNlRGlzb3duUGFyYW1zKHRoaXMuI3Byb2Nlc3NUYXJnZXRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKSk7XG4gICAgICAgICAgICBjYXNlICdzY3JpcHQuZXZhbHVhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzY3JpcHRQcm9jZXNzb3IuZXZhbHVhdGUodGhpcy4jcGFyc2VyLnBhcnNlRXZhbHVhdGVQYXJhbXModGhpcy4jcHJvY2Vzc1RhcmdldFBhcmFtcyhjb21tYW5kLnBhcmFtcykpKTtcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdC5nZXRSZWFsbXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNzY3JpcHRQcm9jZXNzb3IuZ2V0UmVhbG1zKHRoaXMuI3BhcnNlci5wYXJzZUdldFJlYWxtc1BhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnc2NyaXB0LnJlbW92ZVByZWxvYWRTY3JpcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzY3JpcHRQcm9jZXNzb3IucmVtb3ZlUHJlbG9hZFNjcmlwdCh0aGlzLiNwYXJzZXIucGFyc2VSZW1vdmVQcmVsb2FkU2NyaXB0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAgICAgICAgIC8vIFNlc3Npb24gZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ3Nlc3Npb24ubmV3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc2Vzc2lvblByb2Nlc3Nvci5uZXcoY29tbWFuZC5wYXJhbXMpO1xuICAgICAgICAgICAgY2FzZSAnc2Vzc2lvbi5zdGF0dXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNzZXNzaW9uUHJvY2Vzc29yLnN0YXR1cygpO1xuICAgICAgICAgICAgY2FzZSAnc2Vzc2lvbi5zdWJzY3JpYmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzZXNzaW9uUHJvY2Vzc29yLnN1YnNjcmliZSh0aGlzLiNwYXJzZXIucGFyc2VTdWJzY3JpYmVQYXJhbXMoY29tbWFuZC5wYXJhbXMpLCBjb21tYW5kLmNoYW5uZWwpO1xuICAgICAgICAgICAgY2FzZSAnc2Vzc2lvbi51bnN1YnNjcmliZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Nlc3Npb25Qcm9jZXNzb3IudW5zdWJzY3JpYmUodGhpcy4jcGFyc2VyLnBhcnNlU3Vic2NyaWJlUGFyYW1zKGNvbW1hbmQucGFyYW1zKSwgY29tbWFuZC5jaGFubmVsKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gU3RvcmFnZSBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnc3RvcmFnZS5kZWxldGVDb29raWVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3RvcmFnZVByb2Nlc3Nvci5kZWxldGVDb29raWVzKHRoaXMuI3BhcnNlci5wYXJzZURlbGV0ZUNvb2tpZXNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0b3JhZ2UuZ2V0Q29va2llcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm9jZXNzb3IuZ2V0Q29va2llcyh0aGlzLiNwYXJzZXIucGFyc2VHZXRDb29raWVzUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdzdG9yYWdlLnNldENvb2tpZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm9jZXNzb3Iuc2V0Q29va2llKHRoaXMuI3BhcnNlci5wYXJzZVNldENvb2tpZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBrZXB0IG91dHNpZGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnQgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgLy8gRVNMaW50IEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgdHJpZ2dlcnMgaWYgYSBuZXdcbiAgICAgICAgLy8gY29tbWFuZCBpcyBhZGRlZC5cbiAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkNvbW1hbmRFeGNlcHRpb24oYFVua25vd24gY29tbWFuZCAnJHtjb21tYW5kLm1ldGhvZH0nLmApO1xuICAgIH1cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBhcyB6b2QudW5pb24gYWx3YXlzIHRha2UgdGhlIGZpcnN0IHNjaGVtYVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2ViZHJpdmVyLWJpZGkvaXNzdWVzLzYzNVxuICAgICNwcm9jZXNzVGFyZ2V0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHBhcmFtcyAmJlxuICAgICAgICAgICAgJ3RhcmdldCcgaW4gcGFyYW1zICYmXG4gICAgICAgICAgICB0eXBlb2YgcGFyYW1zLnRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgJiZcbiAgICAgICAgICAgICdjb250ZXh0JyBpbiBwYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRhcmdldFsncmVhbG0nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm9jZXNzQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBpZDogY29tbWFuZC5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVzcG9uc2VcIiAvKiBDb21tYW5kUHJvY2Vzc29yRXZlbnRzLlJlc3BvbnNlICovLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogT3V0Z29pbmdNZXNzYWdlX2pzXzEuT3V0Z29pbmdNZXNzYWdlLmNyZWF0ZVJlc29sdmVkKHJlc3BvbnNlLCBjb21tYW5kLmNoYW5uZWwpLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBjb21tYW5kLm1ldGhvZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHByb3RvY29sX2pzXzEuRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVzcG9uc2VcIiAvKiBDb21tYW5kUHJvY2Vzc29yRXZlbnRzLlJlc3BvbnNlICovLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE91dGdvaW5nTWVzc2FnZV9qc18xLk91dGdvaW5nTWVzc2FnZS5jcmVhdGVSZXNvbHZlZChlLnRvRXJyb3JSZXNwb25zZShjb21tYW5kLmlkKSwgY29tbWFuZC5jaGFubmVsKSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGNvbW1hbmQubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuYmlkaSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIgLyogQ29tbWFuZFByb2Nlc3NvckV2ZW50cy5SZXNwb25zZSAqLywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBPdXRnb2luZ01lc3NhZ2VfanNfMS5PdXRnb2luZ01lc3NhZ2UuY3JlYXRlUmVzb2x2ZWQobmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKS50b0Vycm9yUmVzcG9uc2UoY29tbWFuZC5pZCksIGNvbW1hbmQuY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBjb21tYW5kLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tbWFuZFByb2Nlc3NvciA9IENvbW1hbmRQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tYW5kUHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk91dGdvaW5nTWVzc2FnZSA9IHZvaWQgMDtcbmNsYXNzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgI21lc3NhZ2U7XG4gICAgI2NoYW5uZWw7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY2hhbm5lbCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy4jbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuI2NoYW5uZWwgPSBjaGFubmVsO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVByb21pc2UobWVzc2FnZVByb21pc2UsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VQcm9taXNlLnRoZW4oKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtpbmQgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBPdXRnb2luZ01lc3NhZ2UobWVzc2FnZS52YWx1ZSwgY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVJlc29sdmVkKG1lc3NhZ2UsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBraW5kOiAnc3VjY2VzcycsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE91dGdvaW5nTWVzc2FnZShtZXNzYWdlLCBjaGFubmVsKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGFubmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0Z29pbmdNZXNzYWdlID0gT3V0Z29pbmdNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0Z29pbmdNZXNzYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY2xhc3MgQnJvd3NlclByb2Nlc3NvciB7XG4gICAgI2Jyb3dzZXJDZHBDbGllbnQ7XG4gICAgY29uc3RydWN0b3IoYnJvd3NlckNkcENsaWVudCkge1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGl0IGlzIHB1dCBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wLlxuICAgICAgICAvLyBUaGlzIHdheSB3ZSBzZW5kIGJhY2sgdGhlIHJlc3BvbnNlIGJlZm9yZSBjbG9zaW5nIHRoZSB0YWIuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnQnJvd3Nlci5jbG9zZScpLCAwKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVVc2VyQ29udGV4dChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHByb3h5U2VydmVyOiBwYXJhbXNbJ2dvb2c6cHJveHlTZXJ2ZXInXSA/PyB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3h5QnlwYXNzTGlzdCA9IHBhcmFtc1snZ29vZzpwcm94eUJ5cGFzc0xpc3QnXSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcm94eUJ5cGFzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucHJveHlCeXBhc3NMaXN0ID0gcHJveHlCeXBhc3NMaXN0LmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmNyZWF0ZUJyb3dzZXJDb250ZXh0JywgcmVxdWVzdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQ29udGV4dDogY29udGV4dC5icm93c2VyQ29udGV4dElkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVVc2VyQ29udGV4dChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdXNlckNvbnRleHQgPSBwYXJhbXMudXNlckNvbnRleHQ7XG4gICAgICAgIGlmICh1c2VyQ29udGV4dCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ2BkZWZhdWx0YCB1c2VyIGNvbnRleHQgY2Fubm90IGJlIHJlbW92ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmRpc3Bvc2VCcm93c2VyQ29udGV4dCcsIHtcbiAgICAgICAgICAgICAgICBicm93c2VyQ29udGV4dElkOiB1c2VyQ29udGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOmNvbnRlbnQvYnJvd3Nlci9kZXZ0b29scy9wcm90b2NvbC90YXJnZXRfaGFuZGxlci5jYztsPTE0MjQ7ZHJjPWM2ODZlOGY0ZmQzNzkzMTI0NjlmZTAxOGY1YzM5MGU5YzhmMjBkMGRcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5zdGFydHNXaXRoKCdGYWlsZWQgdG8gZmluZCBjb250ZXh0IHdpdGggaWQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIGdldFVzZXJDb250ZXh0cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmdldEJyb3dzZXJDb250ZXh0cycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckNvbnRleHRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB1c2VyQ29udGV4dDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LmJyb3dzZXJDb250ZXh0SWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyUHJvY2Vzc29yID0gQnJvd3NlclByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2RwUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNsYXNzIENkcFByb2Nlc3NvciB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI3JlYWxtU3RvcmFnZTtcbiAgICAjY2RwQ29ubmVjdGlvbjtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZSA9IHJlYWxtU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jY2RwQ29ubmVjdGlvbiA9IGNkcENvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICBnZXRTZXNzaW9uKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gcGFyYW1zLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0KS5jZHBUYXJnZXQuY2RwU2Vzc2lvbklkO1xuICAgICAgICBpZiAoc2Vzc2lvbklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZXNzaW9uOiBzZXNzaW9uSWQgfTtcbiAgICB9XG4gICAgcmVzb2x2ZVJlYWxtKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gcGFyYW1zLnJlYWxtO1xuICAgICAgICBjb25zdCByZWFsbSA9IHRoaXMuI3JlYWxtU3RvcmFnZS5nZXRSZWFsbSh7IHJlYWxtSWQ6IGNvbnRleHQgfSk7XG4gICAgICAgIGlmIChyZWFsbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oYENvdWxkIG5vdCBmaW5kIHJlYWxtICR7cGFyYW1zLnJlYWxtfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGV4ZWN1dGlvbkNvbnRleHRJZDogcmVhbG0uZXhlY3V0aW9uQ29udGV4dElkIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmRDb21tYW5kKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBwYXJhbXMuc2Vzc2lvblxuICAgICAgICAgICAgPyB0aGlzLiNjZHBDb25uZWN0aW9uLmdldENkcENsaWVudChwYXJhbXMuc2Vzc2lvbilcbiAgICAgICAgICAgIDogdGhpcy4jYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbmRDb21tYW5kKHBhcmFtcy5tZXRob2QsIHBhcmFtcy5wYXJhbXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgc2Vzc2lvbjogcGFyYW1zLnNlc3Npb24sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DZHBQcm9jZXNzb3IgPSBDZHBQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZHBQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNkcFRhcmdldCA9IHZvaWQgMDtcbmNvbnN0IGNocm9taXVtX2JpZGlfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9jaHJvbWl1bS1iaWRpLmpzXCIpO1xuY29uc3QgRGVmZXJyZWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9EZWZlcnJlZC5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IEJyb3dzaW5nQ29udGV4dEltcGxfanNfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L0Jyb3dzaW5nQ29udGV4dEltcGwuanNcIik7XG5jb25zdCBMb2dNYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ01hbmFnZXIuanNcIik7XG5jbGFzcyBDZHBUYXJnZXQge1xuICAgICNpZDtcbiAgICAjY2RwQ2xpZW50O1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgICNyZWFsbVN0b3JhZ2U7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjcHJlbG9hZFNjcmlwdFN0b3JhZ2U7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI25ldHdvcmtTdG9yYWdlO1xuICAgICN1bmJsb2NrZWQgPSBuZXcgRGVmZXJyZWRfanNfMS5EZWZlcnJlZCgpO1xuICAgICN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcjtcbiAgICAjbG9nZ2VyO1xuICAgICNuZXR3b3JrRG9tYWluRW5hYmxlZCA9IGZhbHNlO1xuICAgICNmZXRjaERvbWFpblN0YWdlcyA9IHtcbiAgICAgICAgcmVxdWVzdDogZmFsc2UsXG4gICAgICAgIHJlc3BvbnNlOiBmYWxzZSxcbiAgICAgICAgYXV0aDogZmFsc2UsXG4gICAgfTtcbiAgICBzdGF0aWMgY3JlYXRlKHRhcmdldElkLCBjZHBDbGllbnQsIGJyb3dzZXJDZHBDbGllbnQsIHJlYWxtU3RvcmFnZSwgZXZlbnRNYW5hZ2VyLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbmV0d29ya1N0b3JhZ2UsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgY2RwVGFyZ2V0ID0gbmV3IENkcFRhcmdldCh0YXJnZXRJZCwgY2RwQ2xpZW50LCBicm93c2VyQ2RwQ2xpZW50LCBldmVudE1hbmFnZXIsIHJlYWxtU3RvcmFnZSwgcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgbG9nZ2VyKTtcbiAgICAgICAgTG9nTWFuYWdlcl9qc18xLkxvZ01hbmFnZXIuY3JlYXRlKGNkcFRhcmdldCwgcmVhbG1TdG9yYWdlLCBldmVudE1hbmFnZXIsIGxvZ2dlcik7XG4gICAgICAgIGNkcFRhcmdldC4jc2V0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBhd2FpdC5cbiAgICAgICAgLy8gRGVmZXJyZWQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSB0YXJnZXQgaXMgdW5ibG9ja2VkLlxuICAgICAgICB2b2lkIGNkcFRhcmdldC4jdW5ibG9jaygpO1xuICAgICAgICByZXR1cm4gY2RwVGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgY2RwQ2xpZW50LCBicm93c2VyQ2RwQ2xpZW50LCBldmVudE1hbmFnZXIsIHJlYWxtU3RvcmFnZSwgcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuI2lkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuI2NkcENsaWVudCA9IGNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudCA9IGJyb3dzZXJDZHBDbGllbnQ7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlID0gcmVhbG1TdG9yYWdlO1xuICAgICAgICB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZSA9IHByZWxvYWRTY3JpcHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZSA9IG5ldHdvcmtTdG9yYWdlO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IgPSB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcjtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIGRlZmVycmVkIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gKi9cbiAgICBnZXQgdW5ibG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdW5ibG9ja2VkO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpZDtcbiAgICB9XG4gICAgZ2V0IGNkcENsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NkcENsaWVudDtcbiAgICB9XG4gICAgZ2V0IGJyb3dzZXJDZHBDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICAvKiogTmVlZGVkIGZvciBDRFAgZXNjYXBlIHBhdGguICovXG4gICAgZ2V0IGNkcFNlc3Npb25JZCgpIHtcbiAgICAgICAgLy8gU0FGRVRZIHdlIGdvdCB0aGUgY2xpZW50IGJ5IGl0J3MgaWQgZm9yIGNyZWF0aW5nXG4gICAgICAgIHJldHVybiB0aGlzLiNjZHBDbGllbnQuc2Vzc2lvbklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGFsbCB0aGUgcmVxdWlyZWQgQ0RQIGRvbWFpbnMgYW5kIHVuYmxvY2tzIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgYXN5bmMgI3VuYmxvY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmVuYWJsZScpLFxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBiZSBzb21lIGV4aXN0aW5nIGZyYW1lcyBpbiB0aGUgdGFyZ2V0LCBpZiByZWNvbm5lY3RpbmcgdG8gYW5cbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBicm93c2VyIGluc3RhbmNlLCBlLmcuIHZpYSBQdXBwZXRlZXIuIE5lZWQgdG8gcmVzdG9yZSB0aGUgYnJvd3NpbmdcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0cyBmb3IgdGhlIGZyYW1lcyB0byBjb3JyZWN0bHkgaGFuZGxlIGZ1cnRoZXIgZXZlbnRzLCBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYFJ1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWRgLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHNjaGVkdWxlIHRoaXMgdGFzayB0b2dldGhlciB3aXRoIGVuYWJsaW5nIGRvbWFpbnMgY29tbWFuZHMgdG9cbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSB0cmVlIGJlZm9yZSB0aGUgZXZlbnRzIChlLmcuIFJ1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWQpIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gY29taW5nLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL2Nocm9taXVtLWJpZGkvaXNzdWVzLzIyODJcbiAgICAgICAgICAgICAgICB0aGlzLiNjZHBDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdQYWdlLmdldEZyYW1lVHJlZScpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmcmFtZVRyZWUpID0+IHRoaXMuI3Jlc3RvcmVGcmFtZVRyZWVTdGF0ZShmcmFtZVRyZWUuZnJhbWVUcmVlKSksXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmVuYWJsZScpLFxuICAgICAgICAgICAgICAgIHRoaXMuI2NkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5zZXRMaWZlY3ljbGVFdmVudHNFbmFibGVkJywge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlTmV0d29ya0lmTmVlZGVkKCksXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuc2V0QXV0b0F0dGFjaCcsIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0F0dGFjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvckRlYnVnZ2VyT25TdGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLiNpbml0QW5kRXZhbHVhdGVQcmVsb2FkU2NyaXB0cygpLFxuICAgICAgICAgICAgICAgIHRoaXMuI2NkcENsaWVudC5zZW5kQ29tbWFuZCgnUnVudGltZS5ydW5JZldhaXRpbmdGb3JEZWJ1Z2dlcicpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsICdGYWlsZWQgdG8gdW5ibG9jayB0YXJnZXQnLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiBjbG9zZWQgYmVmb3JlIHRoZSBpbml0aWFsaXphdGlvbiBmaW5pc2hlZC5cbiAgICAgICAgICAgIGlmICghdGhpcy4jY2RwQ2xpZW50LmlzQ2xvc2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiN1bmJsb2NrZWQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN1bmJsb2NrZWQucmVzb2x2ZSh7XG4gICAgICAgICAgICBraW5kOiAnc3VjY2VzcycsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3Jlc3RvcmVGcmFtZVRyZWVTdGF0ZShmcmFtZVRyZWUpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZVRyZWUuZnJhbWU7XG4gICAgICAgIGNvbnN0IG1heWJlQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQoZnJhbWUuaWQpO1xuICAgICAgICBpZiAobWF5YmVDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmluZyBwYXJlbnQgb2YgYWxyZWFkeSBrbm93biBicm93c2luZyBjb250ZXh0LiBUaGlzIG1lYW5zIHRoZSB0YXJnZXQgaXNcbiAgICAgICAgICAgIC8vIE9PUGlGIGFuZCB0aGUgQmlEaSBzZXNzaW9uIHdhcyBjb25uZWN0ZWQgdG8gYWxyZWFkeSBleGlzdGluZyBicm93c2VyIGluc3RhbmNlLlxuICAgICAgICAgICAgaWYgKG1heWJlQ29udGV4dC5wYXJlbnRJZCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGZyYW1lLnBhcmVudElkICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgZnJhbWUucGFyZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1heWJlQ29udGV4dC5wYXJlbnRJZCA9IGZyYW1lLnBhcmVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZUNvbnRleHQgPT09IHVuZGVmaW5lZCAmJiBmcmFtZS5wYXJlbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIG5vdCB5ZXQga25vd24gbmVzdGVkIGZyYW1lcy4gVGhlIHRvcC1sZXZlbCBmcmFtZSBpcyBjcmVhdGVkIHdoZW4gdGhlXG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgYXR0YWNoZWQuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRCcm93c2luZ0NvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoZnJhbWUucGFyZW50SWQpO1xuICAgICAgICAgICAgQnJvd3NpbmdDb250ZXh0SW1wbF9qc18xLkJyb3dzaW5nQ29udGV4dEltcGwuY3JlYXRlKGZyYW1lLmlkLCBmcmFtZS5wYXJlbnRJZCwgcGFyZW50QnJvd3NpbmdDb250ZXh0LnVzZXJDb250ZXh0LCBwYXJlbnRCcm93c2luZ0NvbnRleHQuY2RwVGFyZ2V0LCB0aGlzLiNldmVudE1hbmFnZXIsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHRoaXMuI3JlYWxtU3RvcmFnZSwgZnJhbWUudXJsLCB1bmRlZmluZWQsIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yLCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lVHJlZS5jaGlsZEZyYW1lcz8ubWFwKChmcmFtZVRyZWUpID0+IHRoaXMuI3Jlc3RvcmVGcmFtZVRyZWVTdGF0ZShmcmFtZVRyZWUpKTtcbiAgICB9XG4gICAgYXN5bmMgdG9nZ2xlRmV0Y2hJZk5lZWRlZCgpIHtcbiAgICAgICAgY29uc3Qgc3RhZ2VzID0gdGhpcy4jbmV0d29ya1N0b3JhZ2UuZ2V0SW50ZXJjZXB0aW9uU3RhZ2VzKHRoaXMudG9wTGV2ZWxJZCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gT25seSB0b2dnbGUgaW50ZXJjZXB0aW9uIHdoZW4gTmV0d29yayBpcyBlbmFibGVkXG4gICAgICAgICF0aGlzLiNuZXR3b3JrRG9tYWluRW5hYmxlZCB8fFxuICAgICAgICAgICAgKHRoaXMuI2ZldGNoRG9tYWluU3RhZ2VzLnJlcXVlc3QgPT09IHN0YWdlcy5yZXF1ZXN0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jZmV0Y2hEb21haW5TdGFnZXMucmVzcG9uc2UgPT09IHN0YWdlcy5yZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2ZldGNoRG9tYWluU3RhZ2VzLmF1dGggPT09IHN0YWdlcy5hdXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gW107XG4gICAgICAgIHRoaXMuI2ZldGNoRG9tYWluU3RhZ2VzID0gc3RhZ2VzO1xuICAgICAgICBpZiAoc3RhZ2VzLnJlcXVlc3QgfHwgc3RhZ2VzLmF1dGgpIHtcbiAgICAgICAgICAgIC8vIENEUCBxdWlyayB3ZSBuZWVkIHJlcXVlc3QgaW50ZXJjZXB0aW9uIHdoZW4gd2UgaW50ZXJjZXB0IGF1dGhcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybFBhdHRlcm46ICcqJyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0U3RhZ2U6ICdSZXF1ZXN0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFnZXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybFBhdHRlcm46ICcqJyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0U3RhZ2U6ICdSZXNwb25zZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjZHBDbGllbnQuc2VuZENvbW1hbmQoJ0ZldGNoLmVuYWJsZScsIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJucyxcbiAgICAgICAgICAgICAgICBoYW5kbGVBdXRoUmVxdWVzdHM6IHN0YWdlcy5hdXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjZHBDbGllbnQuc2VuZENvbW1hbmQoJ0ZldGNoLmRpc2FibGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGJvdGggTmV0d29yayBhbmQgRmV0Y2ggZG9tYWlucy5cbiAgICAgKi9cbiAgICBhc3luYyB0b2dnbGVOZXR3b3JrSWZOZWVkZWQoKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSB0aGlzLmlzU3Vic2NyaWJlZFRvKGNocm9taXVtX2JpZGlfanNfMS5CaURpTW9kdWxlLk5ldHdvcmspO1xuICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdGhpcy4jbmV0d29ya0RvbWFpbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNuZXR3b3JrRG9tYWluRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKGVuYWJsZWQgPyAnTmV0d29yay5lbmFibGUnIDogJ05ldHdvcmsuZGlzYWJsZScpLFxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlRmV0Y2hJZk5lZWRlZCgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5kZWJ1Z0Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya0RvbWFpbkVuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjc2V0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuI2NkcENsaWVudC5vbignKicsIChldmVudCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgZW5jb3VudGVyIHVzZXMgZm9yIEV2ZW50RW1pdHRlciBvdGhlciB0aGFuIENEUCBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCB3ZSB3YW50IHRvIHNraXAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogYGNkcC4ke2V2ZW50fWAsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuY2RwU2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgUHJveHlDaGFubmVscyBmcm9tIGFsbCB0aGUgcHJlbG9hZCBzY3JpcHRzIG9mIHRoZSBnaXZlblxuICAgICAqIEJyb3dzaW5nQ29udGV4dC5cbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlXG4gICAgICAgICAgICAuZmluZCgpXG4gICAgICAgICAgICAuZmxhdE1hcCgoc2NyaXB0KSA9PiBzY3JpcHQuY2hhbm5lbHMpO1xuICAgIH1cbiAgICAvKiogTG9hZHMgYWxsIHRvcC1sZXZlbCBwcmVsb2FkIHNjcmlwdHMuICovXG4gICAgYXN5bmMgI2luaXRBbmRFdmFsdWF0ZVByZWxvYWRTY3JpcHRzKCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZVxuICAgICAgICAgICAgLmZpbmQoe1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBPT1BJRlxuICAgICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMudG9wTGV2ZWxJZCxcbiAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKHNjcmlwdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5pbml0SW5UYXJnZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0IHRvcExldmVsSWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kVG9wTGV2ZWxDb250ZXh0SWQodGhpcy5pZCkgPz8gdGhpcy5pZCk7XG4gICAgfVxuICAgIGlzU3Vic2NyaWJlZFRvKG1vZHVsZU9yRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50TWFuYWdlci5zdWJzY3JpcHRpb25NYW5hZ2VyLmlzU3Vic2NyaWJlZFRvKG1vZHVsZU9yRXZlbnQsIHRoaXMudG9wTGV2ZWxJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5DZHBUYXJnZXQgPSBDZHBUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZHBUYXJnZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNkcFRhcmdldE1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCBCcm93c2luZ0NvbnRleHRJbXBsX2pzXzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9Ccm93c2luZ0NvbnRleHRJbXBsLmpzXCIpO1xuY29uc3QgV29ya2VyUmVhbG1fanNfMSA9IHJlcXVpcmUoXCIuLi9zY3JpcHQvV29ya2VyUmVhbG0uanNcIik7XG5jb25zdCBDZHBUYXJnZXRfanNfMSA9IHJlcXVpcmUoXCIuL0NkcFRhcmdldC5qc1wiKTtcbmNvbnN0IGNkcFRvQmlkaVRhcmdldFR5cGVzID0ge1xuICAgIHNlcnZpY2Vfd29ya2VyOiAnc2VydmljZS13b3JrZXInLFxuICAgIHNoYXJlZF93b3JrZXI6ICdzaGFyZWQtd29ya2VyJyxcbiAgICB3b3JrZXI6ICdkZWRpY2F0ZWQtd29ya2VyJyxcbn07XG5jbGFzcyBDZHBUYXJnZXRNYW5hZ2VyIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICAjY2RwQ29ubmVjdGlvbjtcbiAgICAjdGFyZ2V0S2V5c1RvQmVJZ25vcmVkQnlBdXRvQXR0YWNoID0gbmV3IFNldCgpO1xuICAgICNzZWxmVGFyZ2V0SWQ7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjbmV0d29ya1N0b3JhZ2U7XG4gICAgI3ByZWxvYWRTY3JpcHRTdG9yYWdlO1xuICAgICNyZWFsbVN0b3JhZ2U7XG4gICAgI2RlZmF1bHRVc2VyQ29udGV4dElkO1xuICAgICNsb2dnZXI7XG4gICAgI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgIGNvbnN0cnVjdG9yKGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHNlbGZUYXJnZXRJZCwgZXZlbnRNYW5hZ2VyLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgZGVmYXVsdFVzZXJDb250ZXh0SWQsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jY2RwQ29ubmVjdGlvbiA9IGNkcENvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgICAgICB0aGlzLiN0YXJnZXRLZXlzVG9CZUlnbm9yZWRCeUF1dG9BdHRhY2guYWRkKHNlbGZUYXJnZXRJZCk7XG4gICAgICAgIHRoaXMuI3NlbGZUYXJnZXRJZCA9IHNlbGZUYXJnZXRJZDtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSBwcmVsb2FkU2NyaXB0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jbmV0d29ya1N0b3JhZ2UgPSBuZXR3b3JrU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlID0gcmVhbG1TdG9yYWdlO1xuICAgICAgICB0aGlzLiNkZWZhdWx0VXNlckNvbnRleHRJZCA9IGRlZmF1bHRVc2VyQ29udGV4dElkO1xuICAgICAgICB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciA9IHVuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuI3NldEV2ZW50TGlzdGVuZXJzKGJyb3dzZXJDZHBDbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgZm9yIGVhY2ggQ0RQIHNlc3Npb24sIHNpbmNlIHRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGVcbiAgICAgKiBmb3IgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgYWxsIHRhcmdldHMgYW5kIGJyb3dzaW5nIGNvbnRleHRzLlxuICAgICAqL1xuICAgICNzZXRFdmVudExpc3RlbmVycyhjZHBDbGllbnQpIHtcbiAgICAgICAgY2RwQ2xpZW50Lm9uKCdUYXJnZXQuYXR0YWNoZWRUb1RhcmdldCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2hhbmRsZUF0dGFjaGVkVG9UYXJnZXRFdmVudChwYXJhbXMsIGNkcENsaWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjZHBDbGllbnQub24oJ1RhcmdldC5kZXRhY2hlZEZyb21UYXJnZXQnLCB0aGlzLiNoYW5kbGVEZXRhY2hlZEZyb21UYXJnZXRFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY2RwQ2xpZW50Lm9uKCdUYXJnZXQudGFyZ2V0SW5mb0NoYW5nZWQnLCB0aGlzLiNoYW5kbGVUYXJnZXRJbmZvQ2hhbmdlZEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICBjZHBDbGllbnQub24oJ0luc3BlY3Rvci50YXJnZXRDcmFzaGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jaGFuZGxlVGFyZ2V0Q3Jhc2hlZEV2ZW50KGNkcENsaWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjZHBDbGllbnQub24oJ1BhZ2UuZnJhbWVBdHRhY2hlZCcsIHRoaXMuI2hhbmRsZUZyYW1lQXR0YWNoZWRFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY2RwQ2xpZW50Lm9uKCdQYWdlLmZyYW1lRGV0YWNoZWQnLCB0aGlzLiNoYW5kbGVGcmFtZURldGFjaGVkRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgICNoYW5kbGVGcmFtZUF0dGFjaGVkRXZlbnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEJyb3dzaW5nQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQocGFyYW1zLnBhcmVudEZyYW1lSWQpO1xuICAgICAgICBpZiAocGFyZW50QnJvd3NpbmdDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEJyb3dzaW5nQ29udGV4dEltcGxfanNfMS5Ccm93c2luZ0NvbnRleHRJbXBsLmNyZWF0ZShwYXJhbXMuZnJhbWVJZCwgcGFyYW1zLnBhcmVudEZyYW1lSWQsIHBhcmVudEJyb3dzaW5nQ29udGV4dC51c2VyQ29udGV4dCwgcGFyZW50QnJvd3NpbmdDb250ZXh0LmNkcFRhcmdldCwgdGhpcy4jZXZlbnRNYW5hZ2VyLCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIFxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgZG9uJ3Qga25vdyB0aGUgVVJMIG9mIHRoZSBmcmFtZSB5ZXQsIHNvIGl0IHdpbGwgYmUgdXBkYXRlZFxuICAgICAgICAgICAgLy8gbGF0ZXIuXG4gICAgICAgICAgICAnYWJvdXQ6YmxhbmsnLCB1bmRlZmluZWQsIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yLCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNoYW5kbGVGcmFtZURldGFjaGVkRXZlbnQocGFyYW1zKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgT09QaUYgbm8gbmVlZCBpbiBkZWxldGluZyBCcm93c2luZ0NvbnRleHQuXG4gICAgICAgIGlmIChwYXJhbXMucmVhc29uID09PSAnc3dhcCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRDb250ZXh0KHBhcmFtcy5mcmFtZUlkKT8uZGlzcG9zZSgpO1xuICAgIH1cbiAgICAjaGFuZGxlQXR0YWNoZWRUb1RhcmdldEV2ZW50KHBhcmFtcywgcGFyZW50U2Vzc2lvbkNkcENsaWVudCkge1xuICAgICAgICBjb25zdCB7IHNlc3Npb25JZCwgdGFyZ2V0SW5mbyB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCB0YXJnZXRDZHBDbGllbnQgPSB0aGlzLiNjZHBDb25uZWN0aW9uLmdldENkcENsaWVudChzZXNzaW9uSWQpO1xuICAgICAgICBjb25zdCBkZXRhY2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBEZXRhY2hlcyBhbmQgcmVzdW1lcyB0aGUgdGFyZ2V0IHN1cHByZXNzaW5nIGVycm9ycy5cbiAgICAgICAgICAgIGF3YWl0IHRhcmdldENkcENsaWVudFxuICAgICAgICAgICAgICAgIC5zZW5kQ29tbWFuZCgnUnVudGltZS5ydW5JZldhaXRpbmdGb3JEZWJ1Z2dlcicpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcGFyZW50U2Vzc2lvbkNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmRldGFjaEZyb21UYXJnZXQnLCBwYXJhbXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgZXJyb3IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuI3NlbGZUYXJnZXRJZCAhPT0gdGFyZ2V0SW5mby50YXJnZXRJZCkge1xuICAgICAgICAgICAgLy8gU2VydmljZSB3b3JrZXJzIGFyZSBzcGVjaWFsIGNhc2UgYmVjYXVzZSB0aGV5IGF0dGFjaCB0byB0aGVcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgdGFyZ2V0IGFuZCB0aGUgcGFnZSB0YXJnZXQgKHNvIHR3aWNlIHBlciB3b3JrZXIpIGR1cmluZ1xuICAgICAgICAgICAgLy8gdGhlIHJlZ3VsYXIgYXV0by1hdHRhY2ggYW5kIG1pZ2h0IGhhbmcgaWYgdGhlIENEUCBzZXNzaW9uIG9uXG4gICAgICAgICAgICAvLyB0aGUgYnJvd3NlciBsZXZlbCBpcyBub3QgZGV0YWNoZWQuIFRoZSBsb2dpYyB0byBkZXRhY2ggdGhlXG4gICAgICAgICAgICAvLyByaWdodCBzZXNzaW9uIGlzIGhhbmRsZWQgaW4gdGhlIHN3aXRjaCBiZWxvdy5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRhcmdldEluZm8udHlwZSA9PT0gJ3NlcnZpY2Vfd29ya2VyJ1xuICAgICAgICAgICAgICAgID8gYCR7cGFyZW50U2Vzc2lvbkNkcENsaWVudC5zZXNzaW9uSWR9XyR7dGFyZ2V0SW5mby50YXJnZXRJZH1gXG4gICAgICAgICAgICAgICAgOiB0YXJnZXRJbmZvLnRhcmdldElkO1xuICAgICAgICAgICAgLy8gTWFwcGVyIGdlbmVyYWxseSBvbmx5IG5lZWRzIG9uZSBzZXNzaW9uIHBlciB0YXJnZXQuIElmIHdlXG4gICAgICAgICAgICAvLyByZWNlaXZlIGFkZGl0aW9uYWwgYXV0by1hdHRhY2hlZCBzZXNzaW9ucywgdGhhdCBpcyB2ZXJ5IGxpa2VseVxuICAgICAgICAgICAgLy8gY29taW5nIGZyb20gY3VzdG9tIENEUCBzZXNzaW9ucy5cbiAgICAgICAgICAgIGlmICh0aGlzLiN0YXJnZXRLZXlzVG9CZUlnbm9yZWRCeUF1dG9BdHRhY2guaGFzKHRhcmdldEtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdG8gbGVhdmUgdGhlIHNlc3Npb24gdW50b3VjaGVkLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3RhcmdldEtleXNUb0JlSWdub3JlZEJ5QXV0b0F0dGFjaC5hZGQodGFyZ2V0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRhcmdldEluZm8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGFnZSc6XG4gICAgICAgICAgICBjYXNlICdpZnJhbWUnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3NlbGZUYXJnZXRJZCA9PT0gdGFyZ2V0SW5mby50YXJnZXRJZCkge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIGRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNkcFRhcmdldCA9IHRoaXMuI2NyZWF0ZUNkcFRhcmdldCh0YXJnZXRDZHBDbGllbnQsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQodGFyZ2V0SW5mby50YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlQ29udGV4dCAmJiB0YXJnZXRJbmZvLnR5cGUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9PUGlGLlxuICAgICAgICAgICAgICAgICAgICBtYXliZUNvbnRleHQudXBkYXRlQ2RwVGFyZ2V0KGNkcFRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyQ29udGV4dCA9IHRhcmdldEluZm8uYnJvd3NlckNvbnRleHRJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5mby5icm93c2VyQ29udGV4dElkICE9PSB0aGlzLiNkZWZhdWx0VXNlckNvbnRleHRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRJbmZvLmJyb3dzZXJDb250ZXh0SWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXcgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgQnJvd3NpbmdDb250ZXh0SW1wbF9qc18xLkJyb3dzaW5nQ29udGV4dEltcGwuY3JlYXRlKHRhcmdldEluZm8udGFyZ2V0SWQsIG51bGwsIHVzZXJDb250ZXh0LCBjZHBUYXJnZXQsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgdGhpcy4jcmVhbG1TdG9yYWdlLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFjazogd2hlbiBhIG5ldyB0YXJnZXQgY3JlYXRlZCwgQ0RQIGVtaXRzIHRhcmdldEluZm9DaGFuZ2VkIHdpdGggYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdXJsLCBhbmQgbmF2aWdhdGVzIGl0IHRvIGFib3V0OmJsYW5rIGxhdGVyLiBXaGVuIHRoZSBldmVudCBpcyBlbWl0dGVkIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleGlzdGluZyB0YXJnZXQgKHJlY29ubmVjdCksIHRoZSB1cmwgaXMgYWxyZWFkeSBrbm93biwgYW5kIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRzIHdpbGwgbm90IGJlIGVtaXR0ZWQgYW55bW9yZS4gUmVwbGFjaW5nIGVtcHR5IHVybCB3aXRoIGBhYm91dDpibGFua2BcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRvIGhhbmRsZSBib3RoIGNhc2VzIGluIHRoZSBzYW1lIHdheS5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCI3LjMuMi4xIENyZWF0aW5nIGJyb3dzaW5nIGNvbnRleHRzXCIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvY3VtZW50LXNlcXVlbmNlcy5odG1sI2NyZWF0aW5nLWJyb3dzaW5nLWNvbnRleHRzXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHdobyB0byBkZWFsIHdpdGggbm9uLW51bGwgY3JlYXRvciBhbmQgaXRzIGBjcmVhdG9yT3JpZ2luYC5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5mby51cmwgPT09ICcnID8gJ2Fib3V0OmJsYW5rJyA6IHRhcmdldEluZm8udXJsLCB0YXJnZXRJbmZvLm9wZW5lckZyYW1lSWQgPz8gdGFyZ2V0SW5mby5vcGVuZXJJZCwgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2Vfd29ya2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ3dvcmtlcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsbSA9IHRoaXMuI3JlYWxtU3RvcmFnZS5maW5kUmVhbG0oe1xuICAgICAgICAgICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IHBhcmVudFNlc3Npb25DZHBDbGllbnQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGJyb3dzaW5nIGNvbnRleHQsIHRoaXMgd29ya2VyIGlzIGFscmVhZHkgdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXJlYWxtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwVGFyZ2V0ID0gdGhpcy4jY3JlYXRlQ2RwVGFyZ2V0KHRhcmdldENkcENsaWVudCwgdGFyZ2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGFuZGxlV29ya2VyVGFyZ2V0KGNkcFRvQmlkaVRhcmdldFR5cGVzW3RhcmdldEluZm8udHlwZV0sIGNkcFRhcmdldCwgcmVhbG0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIENEUCwgd2Ugb25seSBlbWl0IHNoYXJlZCB3b3JrZXJzIG9uIHRoZSBicm93c2VyIGFuZCBub3QgdGhlIHNldCBvZlxuICAgICAgICAgICAgLy8gZnJhbWVzIHRoYXQgdXNlIHRoZSBzaGFyZWQgd29ya2VyLiBJZiB3ZSBjaGFuZ2UgdGhpcyBpbiB0aGUgZnV0dXJlIHRvXG4gICAgICAgICAgICAvLyBiZWhhdmUgbGlrZSBzZXJ2aWNlIHdvcmtlcnMgKGVtaXRzIG9uIGJvdGggYnJvd3NlciBhbmQgZnJhbWUgdGFyZ2V0cyksXG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYmxvY2sgYW5kIG1lcmdlIHNlcnZpY2Ugd29ya2VycyB3aXRoIHRoZSBhYm92ZSBvbmUuXG4gICAgICAgICAgICBjYXNlICdzaGFyZWRfd29ya2VyJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNkcFRhcmdldCA9IHRoaXMuI2NyZWF0ZUNkcFRhcmdldCh0YXJnZXRDZHBDbGllbnQsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhbmRsZVdvcmtlclRhcmdldChjZHBUb0JpZGlUYXJnZXRUeXBlc1t0YXJnZXRJbmZvLnR5cGVdLCBjZHBUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZXZUb29scyBvciBzb21lIG90aGVyIG5vdCBzdXBwb3J0ZWQgYnkgQmlEaSB0YXJnZXQuIEp1c3QgcmVsZWFzZVxuICAgICAgICAvLyBkZWJ1Z2dlciBhbmQgaWdub3JlIHRoZW0uXG4gICAgICAgIHZvaWQgZGV0YWNoKCk7XG4gICAgfVxuICAgICNjcmVhdGVDZHBUYXJnZXQodGFyZ2V0Q2RwQ2xpZW50LCB0YXJnZXRJbmZvKSB7XG4gICAgICAgIHRoaXMuI3NldEV2ZW50TGlzdGVuZXJzKHRhcmdldENkcENsaWVudCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IENkcFRhcmdldF9qc18xLkNkcFRhcmdldC5jcmVhdGUodGFyZ2V0SW5mby50YXJnZXRJZCwgdGFyZ2V0Q2RwQ2xpZW50LCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LCB0aGlzLiNyZWFsbVN0b3JhZ2UsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHRoaXMuI25ldHdvcmtTdG9yYWdlLCB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgdGhpcy4jbG9nZ2VyKTtcbiAgICAgICAgdGhpcy4jbmV0d29ya1N0b3JhZ2Uub25DZHBUYXJnZXRDcmVhdGVkKHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgICN3b3JrZXJzID0gbmV3IE1hcCgpO1xuICAgICNoYW5kbGVXb3JrZXJUYXJnZXQocmVhbG1UeXBlLCBjZHBUYXJnZXQsIG93bmVyUmVhbG0pIHtcbiAgICAgICAgY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGVjdXRpb25Db250ZXh0Q3JlYXRlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdW5pcXVlSWQsIGlkLCBvcmlnaW4gfSA9IHBhcmFtcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgd29ya2VyUmVhbG0gPSBuZXcgV29ya2VyUmVhbG1fanNfMS5Xb3JrZXJSZWFsbShjZHBUYXJnZXQuY2RwQ2xpZW50LCB0aGlzLiNldmVudE1hbmFnZXIsIGlkLCB0aGlzLiNsb2dnZXIsICgwLCBCcm93c2luZ0NvbnRleHRJbXBsX2pzXzEuc2VyaWFsaXplT3JpZ2luKShvcmlnaW4pLCBvd25lclJlYWxtID8gW293bmVyUmVhbG1dIDogW10sIHVuaXF1ZUlkLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIHJlYWxtVHlwZSk7XG4gICAgICAgICAgICB0aGlzLiN3b3JrZXJzLnNldChjZHBUYXJnZXQuY2RwU2Vzc2lvbklkLCB3b3JrZXJSZWFsbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjaGFuZGxlRGV0YWNoZWRGcm9tVGFyZ2V0RXZlbnQoeyBzZXNzaW9uSWQsIHRhcmdldElkLCB9KSB7XG4gICAgICAgIGlmICh0YXJnZXRJZCkge1xuICAgICAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UuZmluZCh7IHRhcmdldElkIH0pLm1hcCgocHJlbG9hZFNjcmlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIHByZWxvYWRTY3JpcHQuZGlzcG9zZSh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kQ29udGV4dEJ5U2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy4jd29ya2Vycy5nZXQoc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlLmRlbGV0ZVJlYWxtcyh7XG4gICAgICAgICAgICAgICAgY2RwU2Vzc2lvbklkOiB3b3JrZXIuY2RwQ2xpZW50LnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICNoYW5kbGVUYXJnZXRJbmZvQ2hhbmdlZEV2ZW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kQ29udGV4dChwYXJhbXMudGFyZ2V0SW5mby50YXJnZXRJZCk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uVGFyZ2V0SW5mb0NoYW5nZWQocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjaGFuZGxlVGFyZ2V0Q3Jhc2hlZEV2ZW50KGNkcENsaWVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIHByaW1hcmlseSB1c2VkIGZvciBzZXJ2aWNlIGFuZCBzaGFyZWQgd29ya2Vycy4gQ0RQIHRlbmRzIHRvIG5vdFxuICAgICAgICAvLyBzaWduYWwgdGhleSBjbG9zZWQgZ3JhY2VmdWxseSBhbmQgaW5zdGVhZCBzYXlzIHRoZXkgY3Jhc2hlZCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhleSBhcmUgY2xvc2VkLlxuICAgICAgICBjb25zdCByZWFsbXMgPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtcyh7XG4gICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IGNkcENsaWVudC5zZXNzaW9uSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWxtIG9mIHJlYWxtcykge1xuICAgICAgICAgICAgcmVhbG0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DZHBUYXJnZXRNYW5hZ2VyID0gQ2RwVGFyZ2V0TWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNkcFRhcmdldE1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0SW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuc2VyaWFsaXplT3JpZ2luID0gc2VyaWFsaXplT3JpZ2luO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGFzc2VydF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2Fzc2VydC5qc1wiKTtcbmNvbnN0IERlZmVycmVkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRGVmZXJyZWQuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCB1bml0Q29udmVyc2lvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91bml0Q29udmVyc2lvbnMuanNcIik7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXVpZFwiKTtcbmNvbnN0IFdpbmRvd1JlYWxtX2pzXzEgPSByZXF1aXJlKFwiLi4vc2NyaXB0L1dpbmRvd1JlYWxtLmpzXCIpO1xuY2xhc3MgQnJvd3NpbmdDb250ZXh0SW1wbCB7XG4gICAgc3RhdGljIExPR0dFUl9QUkVGSVggPSBgJHtsb2dfanNfMS5Mb2dUeXBlLmRlYnVnfTpicm93c2luZ0NvbnRleHRgO1xuICAgIC8qKiBUaGUgSUQgb2YgdGhpcyBicm93c2luZyBjb250ZXh0LiAqL1xuICAgICNpZDtcbiAgICB1c2VyQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHBhcmVudCBicm93c2luZyBjb250ZXh0LlxuICAgICAqIElmIG51bGwsIHRoaXMgaXMgYSB0b3AtbGV2ZWwgY29udGV4dC5cbiAgICAgKi9cbiAgICAjcGFyZW50SWQgPSBudWxsO1xuICAgIC8qKiBEaXJlY3QgY2hpbGRyZW4gYnJvd3NpbmcgY29udGV4dHMuICovXG4gICAgI2NoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICNsaWZlY3ljbGUgPSB7XG4gICAgICAgIERPTUNvbnRlbnRMb2FkZWQ6IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCksXG4gICAgICAgIGxvYWQ6IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCksXG4gICAgfTtcbiAgICAjbmF2aWdhdGlvbiA9IHtcbiAgICAgICAgd2l0aGluRG9jdW1lbnQ6IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCksXG4gICAgfTtcbiAgICAjdXJsO1xuICAgICNldmVudE1hbmFnZXI7XG4gICAgI3JlYWxtU3RvcmFnZTtcbiAgICAjbG9hZGVySWQ7XG4gICAgI2NkcFRhcmdldDtcbiAgICAvLyBUaGUgZGVmZXJyZWQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBkZWZhdWx0IHJlYWxtIGlzIGNyZWF0ZWQuXG4gICAgI2RlZmF1bHRSZWFsbURlZmVycmVkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAjbG9nZ2VyO1xuICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBwcmV2aW91c2x5IHNldCB2aWV3cG9ydC5cbiAgICAjcHJldmlvdXNWaWV3cG9ydCA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIC8vIFRoZSBVUkwgb2YgdGhlIG5hdmlnYXRpb24gdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuIEEgd29ya2Fyb3VuZCBvZiB0aGUgQ0RQXG4gICAgLy8gbGFja2luZyBVUkwgZm9yIHRoZSBwZW5kaW5nIG5hdmlnYXRpb24gZXZlbnRzLCBlLmcuIGBQYWdlLmZyYW1lU3RhcnRlZExvYWRpbmdgLlxuICAgIC8vIFNldCBvbiBgUGFnZS5uYXZpZ2F0ZWAsIGBQYWdlLnJlbG9hZGAgY29tbWFuZHMgYW5kIG9uIGRlcHJlY2F0ZWQgQ0RQIGV2ZW50XG4gICAgLy8gYFBhZ2UuZnJhbWVTY2hlZHVsZWROYXZpZ2F0aW9uYC5cbiAgICAjcGVuZGluZ05hdmlnYXRpb25Vcmw7XG4gICAgI3ZpcnR1YWxOYXZpZ2F0aW9uSWQgPSAoMCwgdXVpZF8xLnV1aWR2NCkoKTtcbiAgICAjb3JpZ2luYWxPcGVuZXI7XG4gICAgLy8gU2V0IHdoZW4gdGhlIHVzZXIgcHJvbXB0IGlzIG9wZW5lZC4gUmVxdWlyZWQgdG8gcHJvdmlkZSB0aGUgdHlwZSBpbiBjbG9zaW5nIGV2ZW50LlxuICAgICNsYXN0VXNlclByb21wdFR5cGU7XG4gICAgI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgIGNvbnN0cnVjdG9yKGlkLCBwYXJlbnRJZCwgdXNlckNvbnRleHQsIGNkcFRhcmdldCwgZXZlbnRNYW5hZ2VyLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIHVybCwgb3JpZ2luYWxPcGVuZXIsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0ID0gY2RwVGFyZ2V0O1xuICAgICAgICB0aGlzLiNpZCA9IGlkO1xuICAgICAgICB0aGlzLiNwYXJlbnRJZCA9IHBhcmVudElkO1xuICAgICAgICB0aGlzLnVzZXJDb250ZXh0ID0gdXNlckNvbnRleHQ7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZSA9IHJlYWxtU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IgPSB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcjtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI29yaWdpbmFsT3BlbmVyID0gb3JpZ2luYWxPcGVuZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoaWQsIHBhcmVudElkLCB1c2VyQ29udGV4dCwgY2RwVGFyZ2V0LCBldmVudE1hbmFnZXIsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgdXJsLCBvcmlnaW5hbE9wZW5lciwgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEJyb3dzaW5nQ29udGV4dEltcGwoaWQsIHBhcmVudElkLCB1c2VyQ29udGV4dCwgY2RwVGFyZ2V0LCBldmVudE1hbmFnZXIsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgdXJsLCBvcmlnaW5hbE9wZW5lciwgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIGxvZ2dlcik7XG4gICAgICAgIGNvbnRleHQuI2luaXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5hZGRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuYWRkQ2hpbGQoY29udGV4dC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSG9sZCBvbiB0aGUgYGNvbnRleHRDcmVhdGVkYCBldmVudCB1bnRpbCB0aGUgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gVGhpcyBpcyByZXF1aXJlZCxcbiAgICAgICAgLy8gYXMgdGhlIHBhcmVudCBvZiB0aGUgY29udGV4dCBjYW4gYmUgc2V0IGxhdGVyIGluIGNhc2Ugb2YgcmVjb25uZWN0aW5nIHRvIGFuXG4gICAgICAgIC8vIGV4aXN0aW5nIGJyb3dzZXIgaW5zdGFuY2UgKyBPT1BpRi5cbiAgICAgICAgZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyUHJvbWlzZUV2ZW50KGNvbnRleHQudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Db250ZXh0Q3JlYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBjb250ZXh0LnNlcmlhbGl6ZVRvQmlkaVZhbHVlKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksIGNvbnRleHQuaWQsIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLkNvbnRleHRDcmVhdGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgIC8vIGB0aW1lc3RhbXBgIGZyb20gdGhlIGV2ZW50IGlzIE1vbm90b25pY1RpbWUsIG5vdCByZWFsIHRpbWUsIHNvXG4gICAgICAgIC8vIHRoZSBiZXN0IE1hcHBlciBjYW4gZG8gaXMgdG8gc2V0IHRoZSB0aW1lc3RhbXAgdG8gdGhlIGVwb2NoIHRpbWVcbiAgICAgICAgLy8gb2YgdGhlIGV2ZW50IGFycml2ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9OZXR3b3JrLyN0eXBlLU1vbm90b25pY1RpbWVcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvY3VtZW50LXNlcXVlbmNlcy5odG1sI25hdmlnYWJsZVxuICAgICAqL1xuICAgIGdldCBuYXZpZ2FibGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xvYWRlcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWaXJ0dWFsIG5hdmlnYXRpb24gSUQuIFJlcXVpcmVkLCBhcyBDRFAgYGxvYWRlcklkYCBjYW5ub3QgYmUgbWFwcGVkIDE6MSB0byBhbGwgdGhlXG4gICAgICogbmF2aWdhdGlvbnMgKGUuZy4gc2FtZSBkb2N1bWVudCBuYXZpZ2F0aW9ucykuIFVwZGF0ZWQgYWZ0ZXIgZWFjaCBuYXZpZ2F0aW9uLFxuICAgICAqIGluY2x1ZGluZyBzYW1lLWRvY3VtZW50IG9uZXMuXG4gICAgICovXG4gICAgZ2V0IHZpcnR1YWxOYXZpZ2F0aW9uSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN2aXJ0dWFsTmF2aWdhdGlvbklkO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLiNkZWxldGVBbGxDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UuZGVsZXRlUmVhbG1zKHtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiB0aGlzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICBpZiAoIXRoaXMuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuI2NoaWxkcmVuLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWlsIGFsbCBvbmdvaW5nIG5hdmlnYXRpb25zLlxuICAgICAgICB0aGlzLiNmYWlsTGlmZWN5Y2xlSWZOb3RGaW5pc2hlZCgpO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Db250ZXh0RGVzdHJveWVkLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnNlcmlhbGl6ZVRvQmlkaVZhbHVlKCksXG4gICAgICAgIH0sIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmRlbGV0ZUNvbnRleHRCeUlkKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgSUQgb2YgdGhpcyBjb250ZXh0LiAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcGFyZW50IGNvbnRleHQgSUQuICovXG4gICAgZ2V0IHBhcmVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50SWQ7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBwYXJlbnQgY29udGV4dCBJRCBhbmQgdXBkYXRlcyBwYXJlbnQncyBjaGlsZHJlbi4gKi9cbiAgICBzZXQgcGFyZW50SWQocGFyZW50SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsICdQYXJlbnQgY29udGV4dCBhbHJlYWR5IHNldCcpO1xuICAgICAgICAgICAgLy8gQ2Fubm90IGRvIGFueXRoaW5nIGV4Y2VwdCBsb2dnaW5nLCBhcyB0aHJvd2luZyB3aWxsIHN0b3AgZXZlbnQgcHJvY2Vzc2luZy4gU29cbiAgICAgICAgICAgIC8vIGp1c3QgcmV0dXJuLFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgIGlmICghdGhpcy5pc1RvcExldmVsQ29udGV4dCgpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRDaGlsZCh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcGFyZW50IGNvbnRleHQuICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQodGhpcy5wYXJlbnRJZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFsbCBkaXJlY3QgY2hpbGRyZW4gY29udGV4dHMuICovXG4gICAgZ2V0IGRpcmVjdENoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuI2NoaWxkcmVuXS5tYXAoKGlkKSA9PiB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoaWQpKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIGNoaWxkcmVuIGNvbnRleHRzLCBmbGF0dGVuZWQuICovXG4gICAgZ2V0IGFsbENoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGlyZWN0Q2hpbGRyZW47XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5jb25jYXQoLi4uY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuYWxsQ2hpbGRyZW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB0b3AtbGV2ZWwgY29udGV4dC5cbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29udGV4dCBJRCBpcyBudWxsLlxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWxDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50SWQgPT09IG51bGw7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgdG9wQ29udGV4dCA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0b3BDb250ZXh0LnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgdG9wQ29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IHRvcENvbnRleHQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BDb250ZXh0O1xuICAgIH1cbiAgICBhZGRDaGlsZChjaGlsZElkKSB7XG4gICAgICAgIHRoaXMuI2NoaWxkcmVuLmFkZChjaGlsZElkKTtcbiAgICB9XG4gICAgI2RlbGV0ZUFsbENoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLmRpcmVjdENoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmRpc3Bvc2UoKSk7XG4gICAgfVxuICAgIGdldCBjZHBUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjZHBUYXJnZXQ7XG4gICAgfVxuICAgIHVwZGF0ZUNkcFRhcmdldChjZHBUYXJnZXQpIHtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0ID0gY2RwVGFyZ2V0O1xuICAgICAgICB0aGlzLiNpbml0TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN1cmw7XG4gICAgfVxuICAgIGFzeW5jIGxpZmVjeWNsZUxvYWRlZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jbGlmZWN5Y2xlLmxvYWQ7XG4gICAgfVxuICAgIGFzeW5jIHRhcmdldFVuYmxvY2tlZE9yVGhyb3coKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NkcFRhcmdldC51bmJsb2NrZWQ7XG4gICAgICAgIGlmIChyZXN1bHQua2luZCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE9yQ3JlYXRlU2FuZGJveChzYW5kYm94KSB7XG4gICAgICAgIGlmIChzYW5kYm94ID09PSB1bmRlZmluZWQgfHwgc2FuZGJveCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgcmVhbG0gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY3JlYXRlZCBhdCB0aGlzIHBvaW50LCBzbyByZXR1cm4gYSBkZWZlcnJlZC5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF5YmVTYW5kYm94ZXMgPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtcyh7XG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHRJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHNhbmRib3gsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWF5YmVTYW5kYm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmNyZWF0ZUlzb2xhdGVkV29ybGQnLCB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICB3b3JsZE5hbWU6IHNhbmRib3gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGBSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkYCBzaG91bGQgYmUgZW1pdHRlZCBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIGNvbW1hbmQgaXMgZG9uZS5cbiAgICAgICAgICAgIG1heWJlU2FuZGJveGVzID0gdGhpcy4jcmVhbG1TdG9yYWdlLmZpbmRSZWFsbXMoe1xuICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHNhbmRib3gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKG1heWJlU2FuZGJveGVzLmxlbmd0aCAhPT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZSBzYW5kYm94IHRvIGJlIGNyZWF0ZWQgZHVlIHRvIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vIGZyYW1lcy4gSW4gdGhpcyBjYXNlLCBpdCdzIGFsd2F5cyB0aGUgZmlyc3Qgb25lIChpLmUuIHRoZSBvbGRlc3Qgb25lKVxuICAgICAgICAvLyB0aGF0IGlzIG1vcmUgcmVsZXZhbnQgc2luY2UgdGhlIHVzZXIgbWF5IGhhdmUgc2V0IHRoYXQgb25lIHVwIGFscmVhZHlcbiAgICAgICAgLy8gdGhyb3VnaCBldmFsdWF0aW9uLlxuICAgICAgICByZXR1cm4gbWF5YmVTYW5kYm94ZXNbMF07XG4gICAgfVxuICAgIHNlcmlhbGl6ZVRvQmlkaVZhbHVlKG1heERlcHRoID0gMCwgYWRkUGFyZW50RmllbGQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICB1c2VyQ29udGV4dDogdGhpcy51c2VyQ29udGV4dCxcbiAgICAgICAgICAgIG9yaWdpbmFsT3BlbmVyOiB0aGlzLiNvcmlnaW5hbE9wZW5lciA/PyBudWxsLFxuICAgICAgICAgICAgY2hpbGRyZW46IG1heERlcHRoID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy5kaXJlY3RDaGlsZHJlbi5tYXAoKGMpID0+IGMuc2VyaWFsaXplVG9CaWRpVmFsdWUobWF4RGVwdGggLSAxLCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgLi4uKGFkZFBhcmVudEZpZWxkID8geyBwYXJlbnQ6IHRoaXMuI3BhcmVudElkIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uVGFyZ2V0SW5mb0NoYW5nZWQocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IHBhcmFtcy50YXJnZXRJbmZvLnVybDtcbiAgICB9XG4gICAgI2luaXRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1BhZ2UuZnJhbWVOYXZpZ2F0ZWQnLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCAhPT0gcGFyYW1zLmZyYW1lLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jdXJsID0gcGFyYW1zLmZyYW1lLnVybCArIChwYXJhbXMuZnJhbWUudXJsRnJhZ21lbnQgPz8gJycpO1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBBdCB0aGUgcG9pbnQgdGhlIHBhZ2UgaXMgaW5pdGlhbGl6ZWQsIGFsbCB0aGUgbmVzdGVkIGlmcmFtZXMgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHBhZ2UgYXJlIGRldGFjaGVkIGFuZCByZWFsbXMgYXJlIGRlc3Ryb3llZC5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiBmcm9tIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLiNkZWxldGVBbGxDaGlsZHJlbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUGFnZS5uYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkICE9PSBwYXJhbXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdOYXZpZ2F0aW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gQnJvd3NpbmdDb250ZXh0SW1wbC5nZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIHRoaXMuI3VybCA9IHBhcmFtcy51cmw7XG4gICAgICAgICAgICB0aGlzLiNuYXZpZ2F0aW9uLndpdGhpbkRvY3VtZW50LnJlc29sdmUoKTtcbiAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuRnJhZ21lbnROYXZpZ2F0ZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiN1cmwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIHRoaXMuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUGFnZS5mcmFtZVN0YXJ0ZWRMb2FkaW5nJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQgIT09IHBhcmFtcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgdmlydHVhbCBuYXZpZ2F0aW9uIGlkLlxuICAgICAgICAgICAgdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCA9ICgwLCB1dWlkXzEudXVpZHY0KSgpO1xuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5OYXZpZ2F0aW9uU3RhcnRlZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBCcm93c2luZ0NvbnRleHRJbXBsLmdldFRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgVVJMIG9mIHRoZSBuYXZpZ2F0aW9uIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLiBBbHRob3VnaCB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB5ZXQga25vd24gaW4gY2FzZSBvZiB1c2VyLWluaXRpYXRlZCBuYXZpZ2F0aW9ucywgaXQgaXMgcG9zc2libGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZSB0aGUgVVJMIGluIGNhc2Ugb2YgQmlEaS1pbml0aWF0ZWQgbmF2aWdhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb3ZpZGUgcHJvcGVyIFVSTCBpbiBjYXNlIG9mIHVzZXItaW5pdGlhdGVkIG5hdmlnYXRpb25zLlxuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuI3BlbmRpbmdOYXZpZ2F0aW9uVXJsID8/ICdVTktOT1dOJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgdGhpcy5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBkb24ndCB1c2UgZGVwcmVjYXRlZCBgUGFnZS5mcmFtZVNjaGVkdWxlZE5hdmlnYXRpb25gIGV2ZW50LlxuICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50Lm9uKCdQYWdlLmZyYW1lU2NoZWR1bGVkTmF2aWdhdGlvbicsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkICE9PSBwYXJhbXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdOYXZpZ2F0aW9uVXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1BhZ2UubGlmZWN5Y2xlRXZlbnQnLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCAhPT0gcGFyYW1zLmZyYW1lSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLm5hbWUgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2RvY3VtZW50Q2hhbmdlZChwYXJhbXMubG9hZGVySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubmFtZSA9PT0gJ2NvbW1pdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsb2FkZXJJZCA9IHBhcmFtcy5sb2FkZXJJZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtYXBwZXIgYXR0YWNoZWQgdG8gdGhlIHBhZ2UgbGF0ZSwgaXQgbWlnaHQgbWlzcyBpbml0IGFuZFxuICAgICAgICAgICAgLy8gY29tbWl0IGV2ZW50cy4gSW4gdGhhdCBjYXNlLCBzYXZlIHRoZSBmaXJzdCBsb2FkZXJJZCBmb3IgdGhpc1xuICAgICAgICAgICAgLy8gZnJhbWVJZC5cbiAgICAgICAgICAgIGlmICghdGhpcy4jbG9hZGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsb2FkZXJJZCA9IHBhcmFtcy5sb2FkZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudCBmcm9tIG5vdCBjdXJyZW50IG5hdmlnYXRpb24uXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxvYWRlcklkICE9PSB0aGlzLiNsb2FkZXJJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IEJyb3dzaW5nQ29udGV4dEltcGwuZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnRE9NQ29udGVudExvYWRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLkRvbUNvbnRlbnRMb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy4jdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9hZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLkxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy4jdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5sb2FkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50Lm9uKCdSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXhEYXRhLCBuYW1lLCB1bmlxdWVJZCwgaWQgfSA9IHBhcmFtcy5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKCFhdXhEYXRhIHx8IGF1eERhdGEuZnJhbWVJZCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmlnaW47XG4gICAgICAgICAgICBsZXQgc2FuZGJveDtcbiAgICAgICAgICAgIC8vIE9ubHkgdGhlc2UgZXhlY3V0aW9uIGNvbnRleHRzIGFyZSBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAgICAgICAgICAgIHN3aXRjaCAoYXV4RGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaXNvbGF0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBzYW5kYm94ID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FuZGJveCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGNvbnRleHQgaXRzZWxmLCBidXQgaW4gQ0RQXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBhbiBlbXB0eSBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5kZWJ1Z0Vycm9yLCAnVW5leHBlY3RlZGx5LCBpc29sYXRlZCByZWFsbSBjcmVhdGVkIGJlZm9yZSB0aGUgZGVmYXVsdCBvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5pc0ZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkLnJlc3VsdC5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gVGhpcyBmYWxsYmFjayBpcyBub3QgZXhwZWN0ZWQgdG8gYmUgZXZlciByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gc2VyaWFsaXplT3JpZ2luKHBhcmFtcy5jb250ZXh0Lm9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gbmV3IFdpbmRvd1JlYWxtX2pzXzEuV2luZG93UmVhbG0odGhpcy5pZCwgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudCwgdGhpcy4jZXZlbnRNYW5hZ2VyLCBpZCwgdGhpcy4jbG9nZ2VyLCBvcmlnaW4sIHVuaXF1ZUlkLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIHNhbmRib3gpO1xuICAgICAgICAgICAgaWYgKGF1eERhdGEuaXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQucmVzb2x2ZShyZWFsbSk7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBDaGFubmVsUHJveHkgbGlzdGVuZXJzIGZvciBhbGwgdGhlIGNoYW5uZWxzIG9mIGFsbCB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcmVsb2FkIHNjcmlwdHMgcmVsYXRlZCB0byB0aGlzIEJyb3dzaW5nQ29udGV4dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBleHRlbmQgZm9yIG5vdCBkZWZhdWx0IHJlYWxtcyBieSB0aGUgc2FuZGJveCBuYW1lLlxuICAgICAgICAgICAgICAgIHZvaWQgUHJvbWlzZS5hbGwodGhpcy4jY2RwVGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC5nZXRDaGFubmVscygpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwuc3RhcnRMaXN0ZW5lckZyb21XaW5kb3cocmVhbG0sIHRoaXMuI2V2ZW50TWFuYWdlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1J1bnRpbWUuZXhlY3V0aW9uQ29udGV4dERlc3Ryb3llZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5pc0ZpbmlzaGVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQucmVzdWx0LmV4ZWN1dGlvbkNvbnRleHRJZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV4ZWN1dGlvbkNvbnRleHRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZS5kZWxldGVSZWFsbXMoe1xuICAgICAgICAgICAgICAgIGNkcFNlc3Npb25JZDogdGhpcy4jY2RwVGFyZ2V0LmNkcFNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHBhcmFtcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1J1bnRpbWUuZXhlY3V0aW9uQ29udGV4dHNDbGVhcmVkJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQucmVqZWN0KG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbignZXhlY3V0aW9uIGNvbnRleHRzIGNsZWFyZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZCA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UuZGVsZXRlUmVhbG1zKHtcbiAgICAgICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IHRoaXMuI2NkcFRhcmdldC5jZHBTZXNzaW9uSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1BhZ2UuamF2YXNjcmlwdERpYWxvZ0Nsb3NlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2VwdGVkID0gcGFyYW1zLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLiNsYXN0VXNlclByb21wdFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ1VuZXhwZWN0ZWRseSBubyBvcGVuaW5nIHByb21wdCBldmVudCBiZWZvcmUgY2xvc2luZyBvbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuVXNlclByb21wdENsb3NlZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGBsYXN0VXNlclByb21wdFR5cGVgIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQgaGVyZSwgc28gZmFsbGJhY2sgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYFVOS05PV05gLiBUaGUgZmFsbGJhY2sgaXMgcmVxdWlyZWQgdG8gcHJldmVudCB0ZXN0cyBmcm9tIGhhbmdpbmcgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdGluZyBmb3IgdGhlIGNsb3NpbmcgZXZlbnQuIFRoZSBjYXN0IGlzIHJlcXVpcmVkLCBhcyB0aGUgYFVOS05PV05gIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBzdGFuZGFyZC5cbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy4jbGFzdFVzZXJQcm9tcHRUeXBlID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAnVU5LTk9XTicsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJUZXh0OiBhY2NlcHRlZCAmJiBwYXJhbXMudXNlcklucHV0ID8gcGFyYW1zLnVzZXJJbnB1dCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLiNsYXN0VXNlclByb21wdFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50Lm9uKCdQYWdlLmphdmFzY3JpcHREaWFsb2dPcGVuaW5nJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0VHlwZSA9IEJyb3dzaW5nQ29udGV4dEltcGwuI2dldFByb21wdFR5cGUocGFyYW1zLnR5cGUpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBsYXN0IHByb21wdCB0eXBlIHRvIHByb3ZpZGUgaXQgaW4gY2xvc2luZyBldmVudC5cbiAgICAgICAgICAgIHRoaXMuI2xhc3RVc2VyUHJvbXB0VHlwZSA9IHByb21wdFR5cGU7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRIYW5kbGVyID0gdGhpcy4jZ2V0UHJvbXB0SGFuZGxlcihwcm9tcHRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuVXNlclByb21wdE9wZW5lZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogcHJvbXB0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvbXB0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIC4uLihwYXJhbXMudHlwZSA9PT0gJ3Byb21wdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBkZWZhdWx0VmFsdWU6IHBhcmFtcy5kZWZhdWx0UHJvbXB0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvbXB0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIC8vIEJhc2VkIG9uIGB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcmAsIGNoZWNrIGlmIHRoZSBwcm9tcHQgc2hvdWxkIGJlIGhhbmRsZWRcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IChgYWNjZXB0YCwgYGRpc21pc3NgKSBvciB3YWl0IGZvciB0aGUgdXNlciB0byBkbyBpdC5cbiAgICAgICAgICAgICAgICBjYXNlIFwiYWNjZXB0XCIgLyogU2Vzc2lvbi5Vc2VyUHJvbXB0SGFuZGxlclR5cGUuQWNjZXB0ICovOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuaGFuZGxlVXNlclByb21wdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc21pc3NcIiAvKiBTZXNzaW9uLlVzZXJQcm9tcHRIYW5kbGVyVHlwZS5EaXNtaXNzICovOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuaGFuZGxlVXNlclByb21wdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpZ25vcmVcIiAvKiBTZXNzaW9uLlVzZXJQcm9tcHRIYW5kbGVyVHlwZS5JZ25vcmUgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljICNnZXRQcm9tcHRUeXBlKGNkcFR5cGUpIHtcbiAgICAgICAgc3dpdGNoIChjZHBUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGVydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYWxlcnRcIiAvKiBCcm93c2luZ0NvbnRleHQuVXNlclByb21wdFR5cGUuQWxlcnQgKi87XG4gICAgICAgICAgICBjYXNlICdiZWZvcmV1bmxvYWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImJlZm9yZXVubG9hZFwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5CZWZvcmV1bmxvYWQgKi87XG4gICAgICAgICAgICBjYXNlICdjb25maXJtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb25maXJtXCIgLyogQnJvd3NpbmdDb250ZXh0LlVzZXJQcm9tcHRUeXBlLkNvbmZpcm0gKi87XG4gICAgICAgICAgICBjYXNlICdwcm9tcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInByb21wdFwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Qcm9tcHQgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2dldFByb21wdEhhbmRsZXIocHJvbXB0VHlwZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJvbXB0SGFuZGxlciA9IFwiZGlzbWlzc1wiIC8qIFNlc3Npb24uVXNlclByb21wdEhhbmRsZXJUeXBlLkRpc21pc3MgKi87XG4gICAgICAgIHN3aXRjaCAocHJvbXB0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFsZXJ0XCIgLyogQnJvd3NpbmdDb250ZXh0LlVzZXJQcm9tcHRUeXBlLkFsZXJ0ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmFsZXJ0ID8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yPy5kZWZhdWx0ID8/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9tcHRIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJiZWZvcmV1bmxvYWRcIiAvKiBCcm93c2luZ0NvbnRleHQuVXNlclByb21wdFR5cGUuQmVmb3JldW5sb2FkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmJlZm9yZVVubG9hZCA/P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcj8uZGVmYXVsdCA/P1xuICAgICAgICAgICAgICAgICAgICBcImFjY2VwdFwiIC8qIFNlc3Npb24uVXNlclByb21wdEhhbmRsZXJUeXBlLkFjY2VwdCAqLyk7XG4gICAgICAgICAgICBjYXNlIFwiY29uZmlybVwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Db25maXJtICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmNvbmZpcm0gPz9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmRlZmF1bHQgPz9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21wdEhhbmRsZXIpO1xuICAgICAgICAgICAgY2FzZSBcInByb21wdFwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Qcm9tcHQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcj8ucHJvbXB0ID8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yPy5kZWZhdWx0ID8/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9tcHRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjZG9jdW1lbnRDaGFuZ2VkKGxvYWRlcklkKSB7XG4gICAgICAgIC8vIFNhbWUgZG9jdW1lbnQgbmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKGxvYWRlcklkID09PSB1bmRlZmluZWQgfHwgdGhpcy4jbG9hZGVySWQgPT09IGxvYWRlcklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jbmF2aWdhdGlvbi53aXRoaW5Eb2N1bWVudC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbi53aXRoaW5Eb2N1bWVudCA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsb2dnZXI/LihCcm93c2luZ0NvbnRleHRJbXBsLkxPR0dFUl9QUkVGSVgsICdEb2N1bWVudCBjaGFuZ2VkIChuYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXNldExpZmVjeWNsZUlmRmluaXNoZWQoKTtcbiAgICAgICAgdGhpcy4jbG9hZGVySWQgPSBsb2FkZXJJZDtcbiAgICB9XG4gICAgI3Jlc2V0TGlmZWN5Y2xlSWZGaW5pc2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKEJyb3dzaW5nQ29udGV4dEltcGwuTE9HR0VSX1BSRUZJWCwgJ0RvY3VtZW50IGNoYW5nZWQgKERPTUNvbnRlbnRMb2FkZWQpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xpZmVjeWNsZS5sb2FkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5sb2FkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKEJyb3dzaW5nQ29udGV4dEltcGwuTE9HR0VSX1BSRUZJWCwgJ0RvY3VtZW50IGNoYW5nZWQgKGxvYWQpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZhaWxMaWZlY3ljbGVJZk5vdEZpbmlzaGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLnJlamVjdChuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oJ25hdmlnYXRpb24gY2FuY2VsZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiNsaWZlY3ljbGUubG9hZC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLiNsaWZlY3ljbGUubG9hZC5yZWplY3QobmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKCduYXZpZ2F0aW9uIGNhbmNlbGVkJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlKHVybCwgd2FpdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgSW52YWxpZCBVUkw6ICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgbmF2aWdhdGlvbiBVUkwgdG8gcHJvdmlkZSBpdCBpbiBgYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25TdGFydGVkYFxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogZGV0ZWN0IG5hdmlnYXRpb24gc3RhcnQgbm90IGZyb20gQ0RQLiBDaGVjayBpZlxuICAgICAgICAvLyAgYFBhZ2UuZnJhbWVSZXF1ZXN0ZWROYXZpZ2F0aW9uYCBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICB0aGlzLiNwZW5kaW5nTmF2aWdhdGlvblVybCA9IHVybDtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGxvYWRpbmcgZXJyb3JzLlxuICAgICAgICBjb25zdCBjZHBOYXZpZ2F0ZVJlc3VsdCA9IGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UubmF2aWdhdGUnLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBmcmFtZUlkOiB0aGlzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNkcE5hdmlnYXRlUmVzdWx0LmVycm9yVGV4dCkge1xuICAgICAgICAgICAgLy8gSWYgbmF2aWdhdGlvbiBmYWlsZWQsIG5vIHBlbmRpbmcgbmF2aWdhdGlvbiBpcyBsZWZ0LlxuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLk5hdmlnYXRpb25GYWlsZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogQnJvd3NpbmdDb250ZXh0SW1wbC5nZXRUaW1lc3RhbXAoKSxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbihjZHBOYXZpZ2F0ZVJlc3VsdC5lcnJvclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RvY3VtZW50Q2hhbmdlZChjZHBOYXZpZ2F0ZVJlc3VsdC5sb2FkZXJJZCk7XG4gICAgICAgIHN3aXRjaCAod2FpdCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmFjdGl2ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5JbnRlcmFjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICAvLyBObyBgbG9hZGVySWRgIG1lYW5zIHNhbWUtZG9jdW1lbnQgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoY2RwTmF2aWdhdGVSZXN1bHQubG9hZGVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNuYXZpZ2F0aW9uLndpdGhpbkRvY3VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jbGlmZWN5Y2xlLkRPTUNvbnRlbnRMb2FkZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCIgLyogQnJvd3NpbmdDb250ZXh0LlJlYWRpbmVzc1N0YXRlLkNvbXBsZXRlICovOlxuICAgICAgICAgICAgICAgIC8vIE5vIGBsb2FkZXJJZGAgbWVhbnMgc2FtZS1kb2N1bWVudCBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChjZHBOYXZpZ2F0ZVJlc3VsdC5sb2FkZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI25hdmlnYXRpb24ud2l0aGluRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUubG9hZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAvLyBVcmwgY2FuIGNoYW5nZSBkdWUgdG8gcmVkaXJlY3QgZ2V0IHRoZSBsYXRlc3Qgb25lLlxuICAgICAgICAgICAgdXJsOiB3YWl0ID09PSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLyA/IHVybCA6IHRoaXMuI3VybCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVsb2FkKGlnbm9yZUNhY2hlLCB3YWl0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpO1xuICAgICAgICB0aGlzLiNyZXNldExpZmVjeWNsZUlmRmluaXNoZWQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5yZWxvYWQnLCB7XG4gICAgICAgICAgICBpZ25vcmVDYWNoZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAod2FpdCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmFjdGl2ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5JbnRlcmFjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUuRE9NQ29udGVudExvYWRlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5Db21wbGV0ZSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUubG9hZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBkZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgIGlmICh2aWV3cG9ydCA9PT0gbnVsbCAmJiBkZXZpY2VQaXhlbFJhdGlvID09PSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdFbXVsYXRpb24uY2xlYXJEZXZpY2VNZXRyaWNzT3ZlcnJpZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGFwcGxpZWRWaWV3cG9ydDtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVmlld3BvcnQgPSB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3cG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVmlld3BvcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0ID0gYXBwbGllZFZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0VtdWxhdGlvbi5zZXREZXZpY2VNZXRyaWNzT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuI3ByZXZpb3VzVmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogZGV2aWNlUGl4ZWxSYXRpbyA/IGRldmljZVBpeGVsUmF0aW8gOiAwLFxuICAgICAgICAgICAgICAgICAgICBtb2JpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkb250U2V0VmlzaWJsZVNpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jcnNyYy5vcmcvYy9jb250ZW50L2Jyb3dzZXIvZGV2dG9vbHMvcHJvdG9jb2wvZW11bGF0aW9uX2hhbmRsZXIuY2M7bD0yNTc7ZHJjPTJmNmVlZTg0Y2Y5OGQ0MjI3ZTdjNDE3MThkZDcxYjgyZjI2ZDkwZmZcbiAgICAgICAgICAgICAgICAnV2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgbXVzdCBiZSBwb3NpdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdQcm92aWRlZCB2aWV3cG9ydCBkaW1lbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVVc2VyUHJvbXB0KGFjY2VwdCwgdXNlclRleHQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5oYW5kbGVKYXZhU2NyaXB0RGlhbG9nJywge1xuICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHQgPz8gdHJ1ZSxcbiAgICAgICAgICAgIHByb21wdFRleHQ6IHVzZXJUZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYWN0aXZhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UuYnJpbmdUb0Zyb250Jyk7XG4gICAgfVxuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5zaG90KHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oYE5vbi10b3AtbGV2ZWwgJ2NvbnRleHQnICgke3BhcmFtcy5jb250ZXh0fSkgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXRQYXJhbWV0ZXJzID0gZ2V0SW1hZ2VGb3JtYXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICAgIC8vIFhYWDogRm9jdXMgdGhlIG9yaWdpbmFsIHRhYiBhZnRlciB0aGUgc2NyZWVuc2hvdCBpcyB0YWtlbi5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgc2NyZWVuc2hvdCBnZXRzIGJsb2NrZWQgdW50aWwgdGhlIGFjdGl2ZSB0YWIgZ2V0cyBmb2N1cy5cbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5icmluZ1RvRnJvbnQnKTtcbiAgICAgICAgbGV0IGNhcHR1cmVCZXlvbmRWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2NyaXB0O1xuICAgICAgICBwYXJhbXMub3JpZ2luID8/PSAndmlld3BvcnQnO1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5vcmlnaW4pIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IFN0cmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQmV5b25kVmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndmlld3BvcnQnOiB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gU3RyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB2aWV3cG9ydC5wYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnBhZ2VUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFsbSA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG9yaWdpblJlc3VsdCA9IGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihzY3JpcHQsIGZhbHNlKTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkob3JpZ2luUmVzdWx0LnR5cGUgPT09ICdzdWNjZXNzJyk7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IGRlc2VyaWFsaXplRE9NUmVjdChvcmlnaW5SZXN1bHQucmVzdWx0KTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkob3JpZ2luKTtcbiAgICAgICAgbGV0IHJlY3QgPSBvcmlnaW47XG4gICAgICAgIGlmIChwYXJhbXMuY2xpcCkge1xuICAgICAgICAgICAgY29uc3QgY2xpcCA9IHBhcmFtcy5jbGlwO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5vcmlnaW4gPT09ICd2aWV3cG9ydCcgJiYgY2xpcC50eXBlID09PSAnYm94Jykge1xuICAgICAgICAgICAgICAgIC8vIEZvciB2aWV3cG9ydCBvcmlnaW4sIHRoZSBjbGlwIGlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgd2hpbGUgdGhlIENEUFxuICAgICAgICAgICAgICAgIC8vIHNjcmVlbnNob3QgaXMgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LiBTbyBjb3JyZWN0aW9uIGZvciB0aGUgdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICBjbGlwLnggKz0gb3JpZ2luLng7XG4gICAgICAgICAgICAgICAgY2xpcC55ICs9IG9yaWdpbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdCA9IGdldEludGVyc2VjdGlvblJlY3QoYXdhaXQgdGhpcy4jcGFyc2VSZWN0KGNsaXApLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0LndpZHRoID09PSAwIHx8IHJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb0NhcHR1cmVTY3JlZW5FeGNlcHRpb24oYFVuYWJsZSB0byBjYXB0dXJlIHNjcmVlbnNob3Qgd2l0aCB6ZXJvIGRpbWVuc2lvbnM6IHdpZHRoPSR7cmVjdC53aWR0aH0sIGhlaWdodD0ke3JlY3QuaGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmNhcHR1cmVTY3JlZW5zaG90Jywge1xuICAgICAgICAgICAgY2xpcDogeyAuLi5yZWN0LCBzY2FsZTogMS4wIH0sXG4gICAgICAgICAgICAuLi5mb3JtYXRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY2FwdHVyZUJleW9uZFZpZXdwb3J0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHJpbnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNkcFBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAocGFyYW1zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnByaW50QmFja2dyb3VuZCA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWFyZ2luPy5ib3R0b20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLm1hcmdpbkJvdHRvbSA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4uYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1hcmdpbj8ubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjZHBQYXJhbXMubWFyZ2luTGVmdCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4ubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tYXJnaW4/LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5tYXJnaW5SaWdodCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4ucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWFyZ2luPy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLm1hcmdpblRvcCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4udG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5sYW5kc2NhcGUgPSBwYXJhbXMub3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMucGFnZT8uaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5wYXBlckhlaWdodCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5wYWdlLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5wYWdlPy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjZHBQYXJhbXMucGFwZXJXaWR0aCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5wYWdlLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnBhZ2VSYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiBwYXJhbXMucGFnZVJhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZVBhcnRzID0gcmFuZ2Uuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0cy5sZW5ndGggPCAxIHx8IHJhbmdlUGFydHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgcGFnZSByYW5nZTogJHtyYW5nZX0gaXMgbm90IGEgdmFsaWQgaW50ZWdlciByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgcGFyc2VJbnRlZ2VyKHJhbmdlUGFydHNbMF0gPz8gJycpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyQm91bmQ7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JhbmdlTG93ZXJQYXJ0ID0gJycsIHJhbmdlVXBwZXJQYXJ0ID0gJyddID0gcmFuZ2VQYXJ0cztcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VMb3dlclBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZCA9IHBhcnNlSW50ZWdlcihyYW5nZUxvd2VyUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVVwcGVyUGFydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IHBhcnNlSW50ZWdlcihyYW5nZVVwcGVyUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb3dlckJvdW5kID4gdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgcGFnZSByYW5nZTogJHtyYW5nZUxvd2VyUGFydH0gPiAke3JhbmdlVXBwZXJQYXJ0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNkcFBhcmFtcy5wYWdlUmFuZ2VzID0gcGFyYW1zLnBhZ2VSYW5nZXMuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuc2hyaW5rVG9GaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnByZWZlckNTU1BhZ2VTaXplID0gIXBhcmFtcy5zaHJpbmtUb0ZpdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5wcmludFRvUERGJywgY2RwUGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRWZmZWN0aXZlbHkgemVybyBkaW1lbnNpb25zLlxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09XG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbnQgcGFyYW1ldGVyczogY29udGVudCBhcmVhIGlzIGVtcHR5Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyM6fjp0ZXh0PUlmJTIwY29tbWFuZCUyMHBhcmFtZXRlcnMlMjBjb250YWlucyUyMCUyMmNsaXAlMjIlM0FcbiAgICAgKi9cbiAgICBhc3luYyAjcGFyc2VSZWN0KGNsaXApIHtcbiAgICAgICAgc3dpdGNoIChjbGlwLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogY2xpcC54LCB5OiBjbGlwLnksIHdpZHRoOiBjbGlwLndpZHRoLCBoZWlnaHQ6IGNsaXAuaGVpZ2h0IH07XG4gICAgICAgICAgICBjYXNlICdlbGVtZW50Jzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86ICMxMjEzOiBVc2UgY3VzdG9tIHNhbmRib3ggc3BlY2lmaWNhbGx5IGZvciBDaHJvbWl1bSBCaURpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuZGJveCA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FuZGJveC5jYWxsRnVuY3Rpb24oU3RyaW5nKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KSwgZmFsc2UsIHsgdHlwZTogJ3VuZGVmaW5lZCcgfSwgW2NsaXAuZWxlbWVudF0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2V4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbihgRWxlbWVudCAnJHtjbGlwLmVsZW1lbnQuc2hhcmVkSWR9JyB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC5yZXN1bHQudHlwZSA9PT0gJ2Jvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5yZXN1bHQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbihgTm9kZSAnJHtjbGlwLmVsZW1lbnQuc2hhcmVkSWR9JyBpcyBub3QgYW4gRWxlbWVudGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhbmRib3guY2FsbEZ1bmN0aW9uKFN0cmluZygoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiByZWN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLCBmYWxzZSwgeyB0eXBlOiAndW5kZWZpbmVkJyB9LCBbY2xpcC5lbGVtZW50XSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC50eXBlID09PSAnc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZGVzZXJpYWxpemVET01SZWN0KHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuYWJsZVRvQ2FwdHVyZVNjcmVlbkV4Y2VwdGlvbihgQ291bGQgbm90IGdldCBib3VuZGluZyBib3ggZm9yIEVsZW1lbnQgJyR7Y2xpcC5lbGVtZW50LnNoYXJlZElkfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UuY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgdHJhdmVyc2VIaXN0b3J5KGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmdldE5hdmlnYXRpb25IaXN0b3J5Jyk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuY3VycmVudEluZGV4ICsgZGVsdGFdO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hIaXN0b3J5RW50cnlFeGNlcHRpb24oYE5vIGhpc3RvcnkgZW50cnkgYXQgZGVsdGEgJHtkZWx0YX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLm5hdmlnYXRlVG9IaXN0b3J5RW50cnknLCB7XG4gICAgICAgICAgICBlbnRyeUlkOiBlbnRyeS5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHRvZ2dsZU1vZHVsZXNJZk5lZWRlZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LnRvZ2dsZU5ldHdvcmtJZk5lZWRlZCgpO1xuICAgIH1cbiAgICBhc3luYyBsb2NhdGVOb2RlcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIGEgZGVkaWNhdGVkIHNhbmRib3ggaW5zdGVhZCBvZiBgI2RlZmF1bHRSZWFsbWAuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNsb2NhdGVOb2Rlc0J5TG9jYXRvcihhd2FpdCB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZCwgcGFyYW1zLmxvY2F0b3IsIHBhcmFtcy5zdGFydE5vZGVzID8/IFtdLCBwYXJhbXMubWF4Tm9kZUNvdW50LCBwYXJhbXMuc2VyaWFsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0TG9jYXRvckRlbGVnYXRlKHJlYWxtLCBsb2NhdG9yLCBtYXhOb2RlQ291bnQsIHN0YXJ0Tm9kZXMpIHtcbiAgICAgICAgc3dpdGNoIChsb2NhdG9yLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nzcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChjc3NTZWxlY3RvciwgbWF4Tm9kZUNvdW50LCAuLi5zdGFydE5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGVOb2Rlc1VzaW5nQ3NzID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0Tm9kZXMgaW4gY3NzIHNlbGVjdG9yIHNob3VsZCBiZSBIVE1MRWxlbWVudCwgRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChjc3NTZWxlY3RvcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXMgPSBzdGFydE5vZGVzLmxlbmd0aCA+IDAgPyBzdGFydE5vZGVzIDogW2RvY3VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBzdGFydE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RhcnROb2RlKSA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN0b3Agc2VhcmNoIGVhcmx5IGlmIGBtYXhOb2RlQ291bnRgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGVOb2Rlc1VzaW5nQ3NzKHN0YXJ0Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZsYXQoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4Tm9kZUNvdW50ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXR1cm5lZE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXR1cm5lZE5vZGVzLnNsaWNlKDAsIG1heE5vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNMb2NhbFZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGNzc1NlbGVjdG9yYFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc3RyaW5nJywgdmFsdWU6IGxvY2F0b3IudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBtYXhOb2RlQ291bnRgIHdpdGggYDBgIG1lYW5zIG5vIGxpbWl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IG1heE5vZGVDb3VudCA/PyAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgc3RhcnROb2Rlc2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXJ0Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3hwYXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKHhQYXRoU2VsZWN0b3IsIG1heE5vZGVDb3VudCwgLi4uc3RhcnROb2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNsb2NhdGUtbm9kZXMtdXNpbmcteHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBYUGF0aEV2YWx1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV2YWx1YXRvci5jcmVhdGVFeHByZXNzaW9uKHhQYXRoU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRlTm9kZXNVc2luZ1hwYXRoID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4UGF0aFJlc3VsdCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoZWxlbWVudCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhQYXRoUmVzdWx0LnNuYXBzaG90TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWROb2Rlcy5wdXNoKHhQYXRoUmVzdWx0LnNuYXBzaG90SXRlbShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXMgPSBzdGFydE5vZGVzLmxlbmd0aCA+IDAgPyBzdGFydE5vZGVzIDogW2RvY3VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBzdGFydE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RhcnROb2RlKSA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN0b3Agc2VhcmNoIGVhcmx5IGlmIGBtYXhOb2RlQ291bnRgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGVOb2Rlc1VzaW5nWHBhdGgoc3RhcnROb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXhOb2RlQ291bnQgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJldHVybmVkTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybmVkTm9kZXMuc2xpY2UoMCwgbWF4Tm9kZUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xvY2FsVmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgeFBhdGhTZWxlY3RvcmBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBsb2NhdG9yLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgbWF4Tm9kZUNvdW50YCB3aXRoIGAwYCBtZWFucyBubyBsaW1pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ251bWJlcicsIHZhbHVlOiBtYXhOb2RlQ291bnQgPz8gMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHN0YXJ0Tm9kZXNgXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGFydE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdpbm5lclRleHQnOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jbG9jYXRlLW5vZGVzLXVzaW5nLWlubmVyLXRleHRcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRvci52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZFNlbGVjdG9yRXhjZXB0aW9uKCdpbm5lclRleHQgbG9jYXRvciBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChpbm5lclRleHRTZWxlY3RvciwgZnVsbE1hdGNoLCBpZ25vcmVDYXNlLCBtYXhOb2RlQ291bnQsIG1heERlcHRoLCAuLi5zdGFydE5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hUZXh0ID0gaWdub3JlQ2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaW5uZXJUZXh0U2VsZWN0b3IudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXJUZXh0U2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGVOb2Rlc1VzaW5nSW5uZXJUZXh0ID0gKG5vZGUsIGN1cnJlbnRNYXhEZXB0aCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gWy4uLm5vZGUuY2hpbGRyZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBjdXJyZW50TWF4RGVwdGhgIGlzIG5vdCBkZWNyZW1lbnRlZCBpbnRlbnRpb25hbGx5IGFjY29yZGluZyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmRyaXZlci1iaWRpL3B1bGwvNzEzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLnB1c2goLi4ubG9jYXRlTm9kZXNVc2luZ0lubmVyVGV4dChjaGlsZCwgY3VycmVudE1heERlcHRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuZWROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJbm5lclRleHQgPSBpZ25vcmVDYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZWxlbWVudC5pbm5lclRleHQ/LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlbGVtZW50LmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJbm5lclRleHQuaW5jbHVkZXMoc2VhcmNoVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbE1hdGNoICYmIG5vZGVJbm5lclRleHQgPT09IHNlYXJjaFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogYG5vZGVJbm5lclRleHQuaW5jbHVkZXMoc2VhcmNoVGV4dClgIGlzIGFscmVhZHkgY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlTWF0Y2hlcyA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzZWFyY2ggZGVlcGVyIGlmIGBtYXhEZXB0aGAgaXMgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1heERlcHRoIDw9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGNoaWxkKSA9PiBsb2NhdGVOb2Rlc1VzaW5nSW5uZXJUZXh0KGNoaWxkLCBjdXJyZW50TWF4RGVwdGggLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZU1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBgbm9kZUlubmVyVGV4dC5pbmNsdWRlcyhzZWFyY2hUZXh0KWAgaXMgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bGxNYXRjaCB8fCBub2RlSW5uZXJUZXh0ID09PSBzZWFyY2hUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWROb2Rlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWROb2Rlcy5wdXNoKC4uLmNoaWxkTm9kZU1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN0b3Agc2VhcmNoIGVhcmx5IGlmIGBtYXhOb2RlQ291bnRgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc3RvcCBzZWFyY2ggZWFybHkgaWYgYG1heE5vZGVDb3VudGAgaXMgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXMgPSBzdGFydE5vZGVzLmxlbmd0aCA+IDAgPyBzdGFydE5vZGVzIDogW2RvY3VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBzdGFydE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RhcnROb2RlKSA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN0b3Agc2VhcmNoIGVhcmx5IGlmIGBtYXhOb2RlQ291bnRgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGVOb2Rlc1VzaW5nSW5uZXJUZXh0KHN0YXJ0Tm9kZSwgbWF4RGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mbGF0KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heE5vZGVDb3VudCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmV0dXJuZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmV0dXJuZWROb2Rlcy5zbGljZSgwLCBtYXhOb2RlQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzTG9jYWxWYWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBpbm5lclRleHRTZWxlY3RvcmBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBsb2NhdG9yLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZnVsbE1hdGNoYCB3aXRoIGRlZmF1bHQgYHRydWVgLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnYm9vbGVhbicsIHZhbHVlOiBsb2NhdG9yLm1hdGNoVHlwZSAhPT0gJ3BhcnRpYWwnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgaWdub3JlQ2FzZWAgd2l0aCBkZWZhdWx0IGBmYWxzZWAuXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdib29sZWFuJywgdmFsdWU6IGxvY2F0b3IuaWdub3JlQ2FzZSA9PT0gdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYG1heE5vZGVDb3VudGAgd2l0aCBgMGAgbWVhbnMgbm8gbGltaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdudW1iZXInLCB2YWx1ZTogbWF4Tm9kZUNvdW50ID8/IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBtYXhEZXB0aGAgd2l0aCBkZWZhdWx0IGAxMDAwYCAoc2FtZSBhcyBkZWZhdWx0IGZ1bGwgc2VyaWFsaXphdGlvbiBkZXB0aCkuXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdudW1iZXInLCB2YWx1ZTogbG9jYXRvci5tYXhEZXB0aCA/PyAxMDAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgc3RhcnROb2Rlc2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXJ0Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2FjY2Vzc2liaWxpdHknOiB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNsb2NhdGUtbm9kZXMtdXNpbmctYWNjZXNzaWJpbGl0eS1hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhdG9yLnZhbHVlLm5hbWUgJiYgIWxvY2F0b3IudmFsdWUucm9sZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24oJ0VpdGhlciBuYW1lIG9yIHJvbGUgaGFzIHRvIGJlIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV4dCB0d28gY29tbWFuZHMgY2F1c2UgYTExeSBjYWNoZXMgZm9yIHRoZSB0YXJnZXQgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQuIFdlIHByb2JhYmx5IGRvIG5vdCBuZWVkIHRvIGRpc2FibGUgdGhlbSBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQgaXMgdXNpbmcgYTExeSBmZWF0dXJlcywgYnV0IHdlIGNvdWxkIGJ5IGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpYmlsaXR5LmRpc2FibGUuXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdBY2Nlc3NpYmlsaXR5LmVuYWJsZScpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdBY2Nlc3NpYmlsaXR5LmdldFJvb3RBWE5vZGUnKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IGF3YWl0IHJlYWxtLmV2YWx1YXRlKFxuICAgICAgICAgICAgICAgIC8qIGV4cHJlc3Npb249Ki8gJyh7Z2V0QWNjZXNzaWJsZU5hbWUsIGdldEFjY2Vzc2libGVSb2xlfSknLCBcbiAgICAgICAgICAgICAgICAvKiBhd2FpdFByb21pc2U9Ki8gZmFsc2UsIFwicm9vdFwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuUm9vdCAqLywgXG4gICAgICAgICAgICAgICAgLyogc2VyaWFsaXphdGlvbk9wdGlvbnM9ICovIHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAgICAgLyogdXNlckFjdGl2YXRpb249Ki8gZmFsc2UsIFxuICAgICAgICAgICAgICAgIC8qIGluY2x1ZGVDb21tYW5kTGluZUFwaT0qLyB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3MudHlwZSAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBiaW5kaW5ncycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3MucmVzdWx0LnR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBiaW5kaW5ncycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKG5hbWUsIHJvbGUsIGJpbmRpbmdzLCBtYXhOb2RlQ291bnQsIC4uLnN0YXJ0Tm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybmVkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb2xsZWN0KGNvbnRleHROb2Rlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGV4dE5vZGUgb2YgY29udGV4dE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5yb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb2xlID0gYmluZGluZ3MuZ2V0QWNjZXNzaWJsZVJvbGUoY29udGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLnJvbGUgIT09IHJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYmluZGluZ3MuZ2V0QWNjZXNzaWJsZU5hbWUoY29udGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heE5vZGVDb3VudCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMubGVuZ3RoID09PSBtYXhOb2RlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMucHVzaChjb250ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNvbnRleHROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdChjaGlsZE5vZGVzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2Rlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhcnROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoKGMpID0+IGMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0KHN0YXJ0Tm9kZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzTG9jYWxWYWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBuYW1lYFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc3RyaW5nJywgdmFsdWU6IGxvY2F0b3IudmFsdWUubmFtZSB8fCAnJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHJvbGVgXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbG9jYXRvci52YWx1ZS5yb2xlIHx8ICcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgYmluZGluZ3NgLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBoYW5kbGU6IGJpbmRpbmdzLnJlc3VsdC5oYW5kbGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBtYXhOb2RlQ291bnRgIHdpdGggYDBgIG1lYW5zIG5vIGxpbWl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IG1heE5vZGVDb3VudCA/PyAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgc3RhcnROb2Rlc2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXJ0Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjbG9jYXRlTm9kZXNCeUxvY2F0b3IocmVhbG0sIGxvY2F0b3IsIHN0YXJ0Tm9kZXMsIG1heE5vZGVDb3VudCwgc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbG9jYXRvckRlbGVnYXRlID0gYXdhaXQgdGhpcy4jZ2V0TG9jYXRvckRlbGVnYXRlKHJlYWxtLCBsb2NhdG9yLCBtYXhOb2RlQ291bnQsIHN0YXJ0Tm9kZXMpO1xuICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnNlcmlhbGl6YXRpb25PcHRpb25zLFxuICAgICAgICAgICAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBpcyBhbiBhcnJheSBvZiBub2Rlcywgc28gbm8gbmVlZCBpbiBkZWVwZXIgSlMgc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIG1heE9iamVjdERlcHRoOiAxLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2NhdG9yUmVzdWx0ID0gYXdhaXQgcmVhbG0uY2FsbEZ1bmN0aW9uKGxvY2F0b3JEZWxlZ2F0ZS5mdW5jdGlvbkRlY2xhcmF0aW9uLCBmYWxzZSwgeyB0eXBlOiAndW5kZWZpbmVkJyB9LCBsb2NhdG9yRGVsZWdhdGUuYXJndW1lbnRzTG9jYWxWYWx1ZXMsIFwibm9uZVwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqLywgc2VyaWFsaXphdGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAobG9jYXRvclJlc3VsdC50eXBlICE9PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKEJyb3dzaW5nQ29udGV4dEltcGwuTE9HR0VSX1BSRUZJWCwgJ0ZhaWxlZCBsb2NhdGVOb2Rlc0J5TG9jYXRvcicsIGxvY2F0b3JSZXN1bHQpO1xuICAgICAgICAgICAgLy8gSGV1cmlzdGljIHRvIGRldGVjdCBpbnZhbGlkIHNlbGVjdG9yIGZvciBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VsZWN0b3JzLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gQ1NTIHNlbGVjdG9yLlxuICAgICAgICAgICAgbG9jYXRvclJlc3VsdC5leGNlcHRpb25EZXRhaWxzLnRleHQ/LmVuZHNXaXRoKCdpcyBub3QgYSB2YWxpZCBzZWxlY3Rvci4nKSB8fFxuICAgICAgICAgICAgICAgIC8vIFhQYXRoIHNlbGVjdG9yLlxuICAgICAgICAgICAgICAgIGxvY2F0b3JSZXN1bHQuZXhjZXB0aW9uRGV0YWlscy50ZXh0Py5lbmRzV2l0aCgnaXMgbm90IGEgdmFsaWQgWFBhdGggZXhwcmVzc2lvbi4nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRTZWxlY3RvckV4Y2VwdGlvbihgTm90IHZhbGlkIHNlbGVjdG9yICR7dHlwZW9mIGxvY2F0b3IudmFsdWUgPT09ICdzdHJpbmcnID8gbG9jYXRvci52YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGxvY2F0b3IudmFsdWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGV1cmlzdGljIHRvIGRldGVjdCBpZiB0aGUgYHN0YXJ0Tm9kZWAgaXMgbm90IGFuIGBIVE1MRWxlbWVudGAgaW4gY3NzIHNlbGVjdG9yLlxuICAgICAgICAgICAgaWYgKGxvY2F0b3JSZXN1bHQuZXhjZXB0aW9uRGV0YWlscy50ZXh0ID09PVxuICAgICAgICAgICAgICAgICdFcnJvcjogc3RhcnROb2RlcyBpbiBjc3Mgc2VsZWN0b3Igc2hvdWxkIGJlIEhUTUxFbGVtZW50LCBEb2N1bWVudCBvciBEb2N1bWVudEZyYWdtZW50Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignc3RhcnROb2RlcyBpbiBjc3Mgc2VsZWN0b3Igc2hvdWxkIGJlIEhUTUxFbGVtZW50LCBEb2N1bWVudCBvciBEb2N1bWVudEZyYWdtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oYFVuZXhwZWN0ZWQgZXJyb3IgaW4gc2VsZWN0b3Igc2NyaXB0OiAke2xvY2F0b3JSZXN1bHQuZXhjZXB0aW9uRGV0YWlscy50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdG9yUmVzdWx0LnJlc3VsdC50eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VsZWN0b3Igc2NyaXB0IHJlc3VsdCB0eXBlOiAke2xvY2F0b3JSZXN1bHQucmVzdWx0LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlcmUgYXJlIG5vIG5vbi1ub2RlIGVsZW1lbnRzIGluIHRoZSByZXN1bHQuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbG9jYXRvclJlc3VsdC5yZXN1bHQudmFsdWUubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdub2RlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZWxlY3RvciBzY3JpcHQgcmVzdWx0IGVsZW1lbnQ6ICR7dmFsdWUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5vZGVzIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHRJbXBsID0gQnJvd3NpbmdDb250ZXh0SW1wbDtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU9yaWdpbihvcmlnaW4pIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNhc2NpaS1zZXJpYWxpc2F0aW9uLW9mLWFuLW9yaWdpblxuICAgIGlmIChbJzovLycsICcnXS5pbmNsdWRlcyhvcmlnaW4pKSB7XG4gICAgICAgIG9yaWdpbiA9ICdudWxsJztcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbjtcbn1cbmZ1bmN0aW9uIGdldEltYWdlRm9ybWF0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IHF1YWxpdHksIHR5cGUgfSA9IHBhcmFtcy5mb3JtYXQgPz8ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UvcG5nJyxcbiAgICB9O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpbWFnZS9wbmcnOiB7XG4gICAgICAgICAgICByZXR1cm4geyBmb3JtYXQ6ICdwbmcnIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW1hZ2UvanBlZyc6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanBlZycsXG4gICAgICAgICAgICAgICAgLi4uKHF1YWxpdHkgPT09IHVuZGVmaW5lZCA/IHt9IDogeyBxdWFsaXR5OiBNYXRoLnJvdW5kKHF1YWxpdHkgKiAxMDApIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZS93ZWJwJzoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd3ZWJwJyxcbiAgICAgICAgICAgICAgICAuLi4ocXVhbGl0eSA9PT0gdW5kZWZpbmVkID8ge30gOiB7IHF1YWxpdHk6IE1hdGgucm91bmQocXVhbGl0eSAqIDEwMCkgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgSW1hZ2UgZm9ybWF0ICcke3R5cGV9JyBpcyBub3QgYSBzdXBwb3J0ZWQgZm9ybWF0YCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZURPTVJlY3QocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC50eXBlICE9PSAnb2JqZWN0JyB8fCByZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHggPSByZXN1bHQudmFsdWUuZmluZCgoW2tleV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ3gnO1xuICAgIH0pPy5bMV07XG4gICAgY29uc3QgeSA9IHJlc3VsdC52YWx1ZS5maW5kKChba2V5XSkgPT4ge1xuICAgICAgICByZXR1cm4ga2V5ID09PSAneSc7XG4gICAgfSk/LlsxXTtcbiAgICBjb25zdCBoZWlnaHQgPSByZXN1bHQudmFsdWUuZmluZCgoW2tleV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2hlaWdodCc7XG4gICAgfSk/LlsxXTtcbiAgICBjb25zdCB3aWR0aCA9IHJlc3VsdC52YWx1ZS5maW5kKChba2V5XSkgPT4ge1xuICAgICAgICByZXR1cm4ga2V5ID09PSAnd2lkdGgnO1xuICAgIH0pPy5bMV07XG4gICAgaWYgKHg/LnR5cGUgIT09ICdudW1iZXInIHx8XG4gICAgICAgIHk/LnR5cGUgIT09ICdudW1iZXInIHx8XG4gICAgICAgIGhlaWdodD8udHlwZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgd2lkdGg/LnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeC52YWx1ZSxcbiAgICAgICAgeTogeS52YWx1ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLnZhbHVlLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZSxcbiAgICB9O1xufVxuLyoqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNub3JtYWxpemUtcmVjdCAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVjdChib3gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4oYm94LndpZHRoIDwgMFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgeDogYm94LnggKyBib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IC1ib3gud2lkdGgsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICB4OiBib3gueCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYm94LndpZHRoLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIC4uLihib3guaGVpZ2h0IDwgMFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgeTogYm94LnkgKyBib3guaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogLWJveC5oZWlnaHQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICB5OiBib3gueSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KSxcbiAgICB9O1xufVxuLyoqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNyZWN0YW5nbGUtaW50ZXJzZWN0aW9uICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25SZWN0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBmaXJzdCA9IG5vcm1hbGl6ZVJlY3QoZmlyc3QpO1xuICAgIHNlY29uZCA9IG5vcm1hbGl6ZVJlY3Qoc2Vjb25kKTtcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgoZmlyc3QueCwgc2Vjb25kLngpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1heChmaXJzdC55LCBzZWNvbmQueSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KE1hdGgubWluKGZpcnN0LnggKyBmaXJzdC53aWR0aCwgc2Vjb25kLnggKyBzZWNvbmQud2lkdGgpIC0geCwgMCksXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgoTWF0aC5taW4oZmlyc3QueSArIGZpcnN0LmhlaWdodCwgc2Vjb25kLnkgKyBzZWNvbmQuaGVpZ2h0KSAtIHksIDApLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUludGVnZXIodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBJbnZhbGlkIGludGVnZXI6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2luZ0NvbnRleHRJbXBsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY2xhc3MgQnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzZXJDZHBDbGllbnQsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIGV2ZW50TWFuYWdlcikge1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLmFkZFN1YnNjcmliZUhvb2socHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuQ29udGV4dENyZWF0ZWQsIHRoaXMuI29uQ29udGV4dENyZWF0ZWRTdWJzY3JpYmVIb29rLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBnZXRUcmVlKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHRDb250ZXh0cyA9IHBhcmFtcy5yb290ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRUb3BMZXZlbENvbnRleHRzKClcbiAgICAgICAgICAgIDogW3RoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMucm9vdCldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dHM6IHJlc3VsdENvbnRleHRzLm1hcCgoYykgPT4gYy5zZXJpYWxpemVUb0JpZGlWYWx1ZShwYXJhbXMubWF4RGVwdGggPz8gTnVtYmVyLk1BWF9WQUxVRSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIGxldCByZWZlcmVuY2VDb250ZXh0O1xuICAgICAgICBsZXQgdXNlckNvbnRleHQgPSAnZGVmYXVsdCc7XG4gICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VDb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5yZWZlcmVuY2VDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghcmVmZXJlbmNlQ29udGV4dC5pc1RvcExldmVsQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGByZWZlcmVuY2VDb250ZXh0IHNob3VsZCBiZSBhIHRvcC1sZXZlbCBjb250ZXh0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VyQ29udGV4dCA9IHJlZmVyZW5jZUNvbnRleHQudXNlckNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy51c2VyQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1c2VyQ29udGV4dCA9IHBhcmFtcy51c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ0NvbnRleHRzID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZVxuICAgICAgICAgICAgLmdldEFsbENvbnRleHRzKClcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbnRleHQpID0+IGNvbnRleHQudXNlckNvbnRleHQgPT09IHVzZXJDb250ZXh0KTtcbiAgICAgICAgbGV0IG5ld1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGFiXCIgLyogQnJvd3NpbmdDb250ZXh0LkNyZWF0ZVR5cGUuVGFiICovOlxuICAgICAgICAgICAgICAgIG5ld1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiIC8qIEJyb3dzaW5nQ29udGV4dC5DcmVhdGVUeXBlLldpbmRvdyAqLzpcbiAgICAgICAgICAgICAgICBuZXdXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhpc3RpbmdDb250ZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjb250ZXh0cyBpbiB0aGUgZ2l2ZW4gdXNlciBjb250ZXh0LCB3ZSBuZWVkIHRvIHNldFxuICAgICAgICAgICAgLy8gbmV3V2luZG93IHRvIHRydWUgYXMgbmV3V2luZG93PWZhbHNlIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICAgICAgICBuZXdXaW5kb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuY3JlYXRlVGFyZ2V0Jywge1xuICAgICAgICAgICAgICAgIHVybDogJ2Fib3V0OmJsYW5rJyxcbiAgICAgICAgICAgICAgICBuZXdXaW5kb3csXG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdXNlckNvbnRleHQgPT09ICdkZWZhdWx0JyA/IHVuZGVmaW5lZCA6IHVzZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHBhcmFtcy5iYWNrZ3JvdW5kID09PSB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOmNocm9tZS9icm93c2VyL2RldnRvb2xzL3Byb3RvY29sL3RhcmdldF9oYW5kbGVyLmNjO2w9OTA7ZHJjPWU4MDM5MmFjMTFlNDhhNjkxZjQzMDk5NjRjYWI4M2EzYTU5ZTAxYzhcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ0ZhaWxlZCB0byBmaW5kIGJyb3dzZXIgY29udGV4dCB3aXRoIGlkJykgfHxcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46aGVhZGxlc3MvbGliL2Jyb3dzZXIvcHJvdG9jb2wvdGFyZ2V0X2hhbmRsZXIuY2M7bD00OTtkcmM9ZTgwMzkyYWMxMWU0OGE2OTFmNDMwOTk2NGNhYjgzYTNhNTllMDFjOFxuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnYnJvd3NlckNvbnRleHRJZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hVc2VyQ29udGV4dEV4Y2VwdGlvbihgVGhlIGNvbnRleHQgJHt1c2VyQ29udGV4dH0gd2FzIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXcgdGFiIHRvIGJlIGxvYWRlZCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgaW4gdGhlXG4gICAgICAgIC8vIGBicm93c2luZ0NvbnRleHRgIGV2ZW50cywgd2hlbiB0aGUgYGJyb3dzaW5nQ29udGV4dC5kb21Db250ZW50TG9hZGVkYCBhbmRcbiAgICAgICAgLy8gYGJyb3dzaW5nQ29udGV4dC5sb2FkYCBldmVudHMgZnJvbSB0aGUgaW5pdGlhbCBgYWJvdXQ6YmxhbmtgIG5hdmlnYXRpb25cbiAgICAgICAgLy8gYXJlIGVtaXR0ZWQgYWZ0ZXIgdGhlIG5leHQgbmF2aWdhdGlvbiBpcyBzdGFydGVkLlxuICAgICAgICAvLyBEZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9pc3N1ZXMvMzU4NDZcbiAgICAgICAgY29uc3QgY29udGV4dElkID0gcmVzdWx0LnRhcmdldElkO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KGNvbnRleHRJZCk7XG4gICAgICAgIGF3YWl0IGNvbnRleHQubGlmZWN5Y2xlTG9hZGVkKCk7XG4gICAgICAgIHJldHVybiB7IGNvbnRleHQ6IGNvbnRleHQuaWQgfTtcbiAgICB9XG4gICAgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5uYXZpZ2F0ZShwYXJhbXMudXJsLCBwYXJhbXMud2FpdCA/PyBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLyk7XG4gICAgfVxuICAgIHJlbG9hZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlbG9hZChwYXJhbXMuaWdub3JlQ2FjaGUgPz8gZmFsc2UsIHBhcmFtcy53YWl0ID8/IFwibm9uZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5Ob25lICovKTtcbiAgICB9XG4gICAgYXN5bmMgYWN0aXZhdGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdBY3RpdmF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRoZSB0b3AtbGV2ZWwgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbnRleHQuYWN0aXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBjYXB0dXJlU2NyZWVuc2hvdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjb250ZXh0LmNhcHR1cmVTY3JlZW5zaG90KHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIHByaW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnRleHQucHJpbnQocGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0Vmlld3BvcnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdFbXVsYXRpbmcgdmlld3BvcnQgaXMgb25seSBzdXBwb3J0ZWQgb24gdGhlIHRvcC1sZXZlbCBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29udGV4dC5zZXRWaWV3cG9ydChwYXJhbXMudmlld3BvcnQsIHBhcmFtcy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyB0cmF2ZXJzZUhpc3RvcnkocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgTm8gYnJvd3NpbmcgY29udGV4dCB3aXRoIGlkICR7cGFyYW1zLmNvbnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29udGV4dC50cmF2ZXJzZUhpc3RvcnkocGFyYW1zLmRlbHRhKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVVc2VyUHJvbXB0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbnRleHQuaGFuZGxlVXNlclByb21wdChwYXJhbXMuYWNjZXB0LCBwYXJhbXMudXNlclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSGV1cmlzdGljYWxseSBkZXRlcm1pbmUgdGhlIGVycm9yXG4gICAgICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjpjb250ZW50L2Jyb3dzZXIvZGV2dG9vbHMvcHJvdG9jb2wvcGFnZV9oYW5kbGVyLmNjO2w9MTA4NT9xPSUyMk5vJTIwZGlhbG9nJTIwaXMlMjBzaG93aW5nJTIyJnNzPWNocm9taXVtXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05vIGRpYWxvZyBpcyBzaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hBbGVydEV4Y2VwdGlvbignTm8gZGlhbG9nIGlzIHNob3dpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2UocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBOb24gdG9wLWxldmVsIGJyb3dzaW5nIGNvbnRleHQgJHtjb250ZXh0LmlkfSBjYW5ub3QgYmUgY2xvc2VkLmApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkZXRhY2hlZEZyb21UYXJnZXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNvbnRleHREZXN0cm95ZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldElkID09PSBwYXJhbXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudC5vZmYoJ1RhcmdldC5kZXRhY2hlZEZyb21UYXJnZXQnLCBvbkNvbnRleHREZXN0cm95ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50Lm9uKCdUYXJnZXQuZGV0YWNoZWRGcm9tVGFyZ2V0Jywgb25Db250ZXh0RGVzdHJveWVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5wcm9tcHRVbmxvYWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb250ZXh0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuY2xvc2VUYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiBwYXJhbXMuY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBDRFAgY29tbWFuZCBmaW5pc2hlcyBiZWZvcmUgYGRldGFjaGVkRnJvbVRhcmdldGAgZXZlbnQsXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgYWZ0ZXIuIFdhaXQgZm9yIHRoZSBDRFAgY29tbWFuZCB0byBiZSBmaW5pc2hlZCwgYW5kIHRoZW4gd2FpdFxuICAgICAgICAgICAgLy8gZm9yIGBkZXRhY2hlZEZyb21UYXJnZXRgIGlmIGl0IGhhc24ndCBlbWl0dGVkLlxuICAgICAgICAgICAgYXdhaXQgZGV0YWNoZWRGcm9tVGFyZ2V0UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgZXJyb3IgdGhhdCBhcmlzZSBmcm9tIHRoZSBwYWdlIGJlaW5nIGRlc3Ryb3llZFxuICAgICAgICAgICAgLy8gRXhhbXBsZSBpcyBuYXZpZ2F0aW5nIHRvIGZhdWx0eSBTU0wgY2VydGlmaWNhdGVcbiAgICAgICAgICAgIGlmICghKGVycm9yLmNvZGUgPT09IC0zMjAwMCAvKiBDZHBFcnJvckNvbnN0YW50cy5HRU5FUklDX0VSUk9SICovICYmXG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ05vdCBhdHRhY2hlZCB0byBhbiBhY3RpdmUgcGFnZScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBsb2NhdGVOb2RlcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjb250ZXh0LmxvY2F0ZU5vZGVzKHBhcmFtcyk7XG4gICAgfVxuICAgICNvbkNvbnRleHRDcmVhdGVkU3Vic2NyaWJlSG9vayhjb250ZXh0SWQpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xuICAgICAgICBjb25zdCBjb250ZXh0c1RvUmVwb3J0ID0gW1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIC4uLnRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpLmFsbENoaWxkcmVuLFxuICAgICAgICBdO1xuICAgICAgICBjb250ZXh0c1RvUmVwb3J0LmZvckVhY2goKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuQ29udGV4dENyZWF0ZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBjb250ZXh0LnNlcmlhbGl6ZVRvQmlkaVZhbHVlKCksXG4gICAgICAgICAgICB9LCBjb250ZXh0LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzaW5nQ29udGV4dFByb2Nlc3NvciA9IEJyb3dzaW5nQ29udGV4dFByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHRTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbi8qKiBDb250YWluZXIgY2xhc3MgZm9yIGJyb3dzaW5nIGNvbnRleHRzLiAqL1xuY2xhc3MgQnJvd3NpbmdDb250ZXh0U3RvcmFnZSB7XG4gICAgLyoqIE1hcCBmcm9tIGNvbnRleHQgSUQgdG8gY29udGV4dCBpbXBsZW1lbnRhdGlvbi4gKi9cbiAgICAjY29udGV4dHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqIEdldHMgYWxsIHRvcC1sZXZlbCBjb250ZXh0cywgaS5lLiB0aG9zZSB3aXRoIG5vIHBhcmVudC4gKi9cbiAgICBnZXRUb3BMZXZlbENvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxDb250ZXh0cygpLmZpbHRlcigoY29udGV4dCkgPT4gY29udGV4dC5pc1RvcExldmVsQ29udGV4dCgpKTtcbiAgICB9XG4gICAgLyoqIEdldHMgYWxsIGNvbnRleHRzLiAqL1xuICAgIGdldEFsbENvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNjb250ZXh0cy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIHRoZSBjb250ZXh0IHdpdGggdGhlIGdpdmVuIElELiAqL1xuICAgIGRlbGV0ZUNvbnRleHRCeUlkKGlkKSB7XG4gICAgICAgIHRoaXMuI2NvbnRleHRzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIHRoZSBnaXZlbiBjb250ZXh0LiAqL1xuICAgIGRlbGV0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLiNjb250ZXh0cy5kZWxldGUoY29udGV4dC5pZCk7XG4gICAgfVxuICAgIC8qKiBUcmFja3MgdGhlIGdpdmVuIGNvbnRleHQuICovXG4gICAgYWRkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuI2NvbnRleHRzLnNldChjb250ZXh0LmlkLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSB3aGV0aGVyIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gSUQuICovXG4gICAgaGFzQ29udGV4dChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dHMuaGFzKGlkKTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gSUQsIGlmIGFueS4gKi9cbiAgICBmaW5kQ29udGV4dChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dHMuZ2V0KGlkKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHRvcC1sZXZlbCBjb250ZXh0IElEIG9mIHRoZSBnaXZlbiBjb250ZXh0LCBpZiBhbnkuICovXG4gICAgZmluZFRvcExldmVsQ29udGV4dElkKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF5YmVDb250ZXh0ID0gdGhpcy5maW5kQ29udGV4dChpZCk7XG4gICAgICAgIGNvbnN0IHBhcmVudElkID0gbWF5YmVDb250ZXh0Py5wYXJlbnRJZCA/PyBudWxsO1xuICAgICAgICBpZiAocGFyZW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5kVG9wTGV2ZWxDb250ZXh0SWQocGFyZW50SWQpO1xuICAgIH1cbiAgICBmaW5kQ29udGV4dEJ5U2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIHRoaXMuI2NvbnRleHRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5jZHBUYXJnZXQuY2RwU2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKiBHZXRzIHRoZSBjb250ZXh0IHdpdGggdGhlIGdpdmVuIElELCBpZiBhbnksIG90aGVyd2lzZSB0aHJvd3MuICovXG4gICAgZ2V0Q29udGV4dChpZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZpbmRDb250ZXh0KGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hGcmFtZUV4Y2VwdGlvbihgQ29udGV4dCAke2lkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2ZXJpZnlUb3BMZXZlbENvbnRleHRzTGlzdChjb250ZXh0cykge1xuICAgICAgICBjb25zdCBmb3VuZENvbnRleHRzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoIWNvbnRleHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRDb250ZXh0cztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRleHRJZCBvZiBjb250ZXh0cykge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kQ29udGV4dHMuYWRkKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBOb24gdG9wLWxldmVsIGNvbnRleHQgJyR7Y29udGV4dElkfScgZ2l2ZW4uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kQ29udGV4dHM7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHRTdG9yYWdlID0gQnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzaW5nQ29udGV4dFN0b3JhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWN0aW9uRGlzcGF0Y2hlciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBHcmFwaGVtZVRvb2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvR3JhcGhlbWVUb29sc1wiKTtcbmNvbnN0IElucHV0U291cmNlX2pzXzEgPSByZXF1aXJlKFwiLi9JbnB1dFNvdXJjZS5qc1wiKTtcbmNvbnN0IGtleVV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9rZXlVdGlscy5qc1wiKTtcbmNvbnN0IFVTS2V5Ym9hcmRMYXlvdXRfanNfMSA9IHJlcXVpcmUoXCIuL1VTS2V5Ym9hcmRMYXlvdXQuanNcIik7XG4vKiogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci8jZGZuLWNlbnRlci1wb2ludCAqL1xuY29uc3QgQ0FMQ1VMQVRFX0lOX1ZJRVdfQ0VOVEVSX1BUX0RFQ0wgPSAoKGkpID0+IHtcbiAgICBjb25zdCB0ID0gaS5nZXRDbGllbnRSZWN0cygpWzBdLCBlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odC54LCB0LnggKyB0LndpZHRoKSksIG4gPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgTWF0aC5tYXgodC54LCB0LnggKyB0LndpZHRoKSksIGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0LnksIHQueSArIHQuaGVpZ2h0KSksIG0gPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIE1hdGgubWF4KHQueSwgdC55ICsgdC5oZWlnaHQpKTtcbiAgICByZXR1cm4gW2UgKyAoKG4gLSBlKSA+PiAxKSwgaCArICgobSAtIGgpID4+IDEpXTtcbn0pLnRvU3RyaW5nKCk7XG5jb25zdCBJU19NQUNfREVDTCA9ICgoKSA9PiB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtYWMnKTtcbn0pLnRvU3RyaW5nKCk7XG5hc3luYyBmdW5jdGlvbiBnZXRFbGVtZW50Q2VudGVyKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBzYW5kYm94ID0gYXdhaXQgY29udGV4dC5nZXRPckNyZWF0ZVNhbmRib3godW5kZWZpbmVkKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYW5kYm94LmNhbGxGdW5jdGlvbihDQUxDVUxBVEVfSU5fVklFV19DRU5URVJfUFRfREVDTCwgZmFsc2UsIHsgdHlwZTogJ3VuZGVmaW5lZCcgfSwgW2VsZW1lbnRdKTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdleGNlcHRpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaEVsZW1lbnRFeGNlcHRpb24oYE9yaWdpbiBlbGVtZW50ICR7ZWxlbWVudC5zaGFyZWRJZH0gd2FzIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQucmVzdWx0LnR5cGUgPT09ICdhcnJheScpO1xuICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC5yZXN1bHQudmFsdWU/LlswXT8udHlwZSA9PT0gJ251bWJlcicpO1xuICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC5yZXN1bHQudmFsdWU/LlsxXT8udHlwZSA9PT0gJ251bWJlcicpO1xuICAgIGNvbnN0IHsgcmVzdWx0OiB7IHZhbHVlOiBbeyB2YWx1ZTogeCB9LCB7IHZhbHVlOiB5IH1dLCB9LCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cbmNsYXNzIEFjdGlvbkRpc3BhdGNoZXIge1xuICAgIHN0YXRpYyBpc01hY09TID0gYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGF3YWl0IGNvbnRleHQuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCkpLmNhbGxGdW5jdGlvbihJU19NQUNfREVDTCwgZmFsc2UpO1xuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQudHlwZSAhPT0gJ2V4Y2VwdGlvbicpO1xuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQucmVzdWx0LnR5cGUgPT09ICdib29sZWFuJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0LnZhbHVlO1xuICAgIH07XG4gICAgI3RpY2tTdGFydCA9IDA7XG4gICAgI3RpY2tEdXJhdGlvbiA9IDA7XG4gICAgI2lucHV0U3RhdGU7XG4gICAgI2NvbnRleHQ7XG4gICAgI2lzTWFjT1M7XG4gICAgY29uc3RydWN0b3IoaW5wdXRTdGF0ZSwgY29udGV4dCwgaXNNYWNPUykge1xuICAgICAgICB0aGlzLiNpbnB1dFN0YXRlID0gaW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy4jY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuI2lzTWFjT1MgPSBpc01hY09TO1xuICAgIH1cbiAgICBhc3luYyBkaXNwYXRjaEFjdGlvbnMob3B0aW9uc0J5VGljaykge1xuICAgICAgICBhd2FpdCB0aGlzLiNpbnB1dFN0YXRlLnF1ZXVlLnJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2Ygb3B0aW9uc0J5VGljaykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGF0Y2hUaWNrQWN0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRpc3BhdGNoVGlja0FjdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLiN0aWNrU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy4jdGlja0R1cmF0aW9uID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGFjdGlvbiB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICgnZHVyYXRpb24nIGluIGFjdGlvbiAmJiBhY3Rpb24uZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3RpY2tEdXJhdGlvbiA9IE1hdGgubWF4KHRoaXMuI3RpY2tEdXJhdGlvbiwgYWN0aW9uLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuI3RpY2tEdXJhdGlvbikpLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGVvcnkgd2UgaGF2ZSB0byB3YWl0IGZvciBlYWNoIGFjdGlvbiB0byBoYXBwZW4sIGJ1dCBDRFAgaXMgc2VyaWFsLFxuICAgICAgICAgICAgLy8gc28gYXMgYW4gb3B0aW1pemF0aW9uLCB3ZSBxdWV1ZSBhbGwgQ0RQIGNvbW1hbmRzIGF0IG9uY2UgYW5kIGF3YWl0IGFsbFxuICAgICAgICAgICAgLy8gb2YgdGhlbS5cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy4jZGlzcGF0Y2hBY3Rpb24ob3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBhc3luYyAjZGlzcGF0Y2hBY3Rpb24oeyBpZCwgYWN0aW9uIH0pIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy4jaW5wdXRTdGF0ZS5nZXQoaWQpO1xuICAgICAgICBjb25zdCBrZXlTdGF0ZSA9IHRoaXMuI2lucHV0U3RhdGUuZ2V0R2xvYmFsS2V5U3RhdGUoKTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna2V5RG93bic6IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IFRoZSBzb3VyY2UgaXMgdmFsaWRhdGVkIGJlZm9yZS5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaXNwYXRjaEtleURvd25BY3Rpb24oc291cmNlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuI2lucHV0U3RhdGUuY2FuY2VsTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2tleVVwJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2tleVVwJzoge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlIHNvdXJjZSBpcyB2YWxpZGF0ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Rpc3BhdGNoS2V5VXBBY3Rpb24oc291cmNlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncGF1c2UnOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHdhaXRpbmcgb24gdGhlIGlucHV0IHNvdXJjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BvaW50ZXJEb3duJzoge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlIHNvdXJjZSBpcyB2YWxpZGF0ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Rpc3BhdGNoUG9pbnRlckRvd25BY3Rpb24oc291cmNlLCBrZXlTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNpbnB1dFN0YXRlLmNhbmNlbExpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludGVyVXAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncG9pbnRlck1vdmUnOiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBUaGUgc291cmNlIGlzIHZhbGlkYXRlZCBiZWZvcmUuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGlzcGF0Y2hQb2ludGVyTW92ZUFjdGlvbihzb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncG9pbnRlclVwJzoge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlIHNvdXJjZSBpcyB2YWxpZGF0ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Rpc3BhdGNoUG9pbnRlclVwQWN0aW9uKHNvdXJjZSwga2V5U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzY3JvbGwnOiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBUaGUgc291cmNlIGlzIHZhbGlkYXRlZCBiZWZvcmUuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGlzcGF0Y2hTY3JvbGxBY3Rpb24oc291cmNlLCBrZXlTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjZGlzcGF0Y2hQb2ludGVyRG93bkFjdGlvbihzb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBidXR0b24gfSA9IGFjdGlvbjtcbiAgICAgICAgaWYgKHNvdXJjZS5wcmVzc2VkLmhhcyhidXR0b24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLnByZXNzZWQuYWRkKGJ1dHRvbik7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgc3VidHlwZTogcG9pbnRlclR5cGUgfSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBwcmVzc3VyZSwgdHdpc3QsIHRhbmdlbnRpYWxQcmVzc3VyZSB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCB7IHRpbHRYLCB0aWx0WSB9ID0gZ2V0VGlsdChhY3Rpb24pO1xuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGtleVN0YXRlO1xuICAgICAgICBjb25zdCB7IHJhZGl1c1gsIHJhZGl1c1kgfSA9IGdldFJhZGlpKHdpZHRoID8/IDEsIGhlaWdodCA/PyAxKTtcbiAgICAgICAgc3dpdGNoIChwb2ludGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1vdXNlXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuTW91c2UgKi86XG4gICAgICAgICAgICBjYXNlIFwicGVuXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuUGVuICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hNb3VzZUV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2VQcmVzc2VkJyxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgICAgICBidXR0b246IGdldENkcEJ1dHRvbihidXR0b24pLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBzb3VyY2UuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tDb3VudDogc291cmNlLnNldENsaWNrQ291bnQoYnV0dG9uLCBuZXcgSW5wdXRTb3VyY2VfanNfMS5Qb2ludGVyU291cmNlLkNsaWNrQ29udGV4dCh4LCB5LCBwZXJmb3JtYW5jZS5ub3coKSkpLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudGlhbFByZXNzdXJlLFxuICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgdGlsdFksXG4gICAgICAgICAgICAgICAgICAgIHR3aXN0LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG91Y2hcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Ub3VjaCAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmRpc3BhdGNoVG91Y2hFdmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoU3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaFBvaW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFuZ2VudGlhbFByZXNzdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbHRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbHRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3aXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlOiBwcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc291cmNlLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UucmFkaXVzWCA9IHJhZGl1c1g7XG4gICAgICAgIHNvdXJjZS5yYWRpdXNZID0gcmFkaXVzWTtcbiAgICAgICAgc291cmNlLmZvcmNlID0gcHJlc3N1cmU7XG4gICAgICAgIC8vIC0tLSBQbGF0Zm9ybS1zcGVjaWZpYyBjb2RlIGVuZHMgaGVyZSAtLS1cbiAgICB9XG4gICAgI2Rpc3BhdGNoUG9pbnRlclVwQWN0aW9uKHNvdXJjZSwga2V5U3RhdGUsIGFjdGlvbikge1xuICAgICAgICBjb25zdCB7IGJ1dHRvbiB9ID0gYWN0aW9uO1xuICAgICAgICBpZiAoIXNvdXJjZS5wcmVzc2VkLmhhcyhidXR0b24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLnByZXNzZWQuZGVsZXRlKGJ1dHRvbik7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgZm9yY2UsIHJhZGl1c1gsIHJhZGl1c1ksIHN1YnR5cGU6IHBvaW50ZXJUeXBlIH0gPSBzb3VyY2U7XG4gICAgICAgIC8vIC0tLSBQbGF0Zm9ybS1zcGVjaWZpYyBjb2RlIGJlZ2lucyBoZXJlIC0tLVxuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0ga2V5U3RhdGU7XG4gICAgICAgIHN3aXRjaCAocG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiIC8qIElucHV0LlBvaW50ZXJUeXBlLk1vdXNlICovOlxuICAgICAgICAgICAgY2FzZSBcInBlblwiIC8qIElucHV0LlBvaW50ZXJUeXBlLlBlbiAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgd2lkdGggYW5kIGhlaWdodCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZVJlbGVhc2VkJyxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgICAgICBidXR0b246IGdldENkcEJ1dHRvbihidXR0b24pLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBzb3VyY2UuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tDb3VudDogc291cmNlLmdldENsaWNrQ291bnQoYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwidG91Y2hcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Ub3VjaCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaFRvdWNoRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaEVuZCcsXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoUG9pbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzb3VyY2UucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBlbmRzIGhlcmUgLS0tXG4gICAgfVxuICAgIGFzeW5jICNkaXNwYXRjaFBvaW50ZXJNb3ZlQWN0aW9uKHNvdXJjZSwga2V5U3RhdGUsIGFjdGlvbikge1xuICAgICAgICBjb25zdCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZLCBzdWJ0eXBlOiBwb2ludGVyVHlwZSB9ID0gc291cmNlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHByZXNzdXJlLCB0d2lzdCwgdGFuZ2VudGlhbFByZXNzdXJlLCB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZLCBvcmlnaW4gPSAndmlld3BvcnQnLCBkdXJhdGlvbiA9IHRoaXMuI3RpY2tEdXJhdGlvbiwgfSA9IGFjdGlvbjtcbiAgICAgICAgY29uc3QgeyB0aWx0WCwgdGlsdFkgfSA9IGdldFRpbHQoYWN0aW9uKTtcbiAgICAgICAgY29uc3QgeyByYWRpdXNYLCByYWRpdXNZIH0gPSBnZXRSYWRpaSh3aWR0aCA/PyAxLCBoZWlnaHQgPz8gMSk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0WCwgdGFyZ2V0WSB9ID0gYXdhaXQgdGhpcy4jZ2V0Q29vcmRpbmF0ZUZyb21PcmlnaW4ob3JpZ2luLCBvZmZzZXRYLCBvZmZzZXRZLCBzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgIGlmICh0YXJnZXRYIDwgMCB8fCB0YXJnZXRZIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTW92ZVRhcmdldE91dE9mQm91bmRzRXhjZXB0aW9uKGBDYW5ub3QgbW92ZSBiZXlvbmQgdmlld3BvcnQgKHg6ICR7dGFyZ2V0WH0sIHk6ICR7dGFyZ2V0WX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gZHVyYXRpb24gPiAwID8gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy4jdGlja1N0YXJ0KSAvIGR1cmF0aW9uIDogMTtcbiAgICAgICAgICAgIGxhc3QgPSByYXRpbyA+PSAxO1xuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgeCA9IHRhcmdldFg7XG4gICAgICAgICAgICAgICAgeSA9IHRhcmdldFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChyYXRpbyAqICh0YXJnZXRYIC0gc3RhcnRYKSArIHN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgucm91bmQocmF0aW8gKiAodGFyZ2V0WSAtIHN0YXJ0WSkgKyBzdGFydFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZS54ICE9PSB4IHx8IHNvdXJjZS55ICE9PSB5KSB7XG4gICAgICAgICAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgYmVnaW5zIGhlcmUgLS0tXG4gICAgICAgICAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGtleVN0YXRlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuTW91c2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgd2lkdGggYW5kIGhlaWdodCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hNb3VzZUV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZU1vdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBnZXRDZHBCdXR0b24oc291cmNlLnByZXNzZWQudmFsdWVzKCkubmV4dCgpLnZhbHVlID8/IDUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHNvdXJjZS5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2lzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGVuXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuUGVuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5wcmVzc2VkLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBgc291cmNlLnByZXNzZWQuc2l6ZWAgbWVhbnMgdGhlIHBlbiBpcyBub3QgZGV0ZWN0ZWQgYnkgZGlnaXRpemVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3BhdGNoIGEgbW91c2UgZXZlbnQgZm9yIHRoZSBwZW4gb25seSBpZiBlaXRoZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gdGhlIHBlbiBpcyBob3ZlcmluZyBvdmVyIHRoZSBkaWdpdGl6ZXIgKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIHRoZSBwZW4gaXMgaW4gY29udGFjdCB3aXRoIHRoZSBkaWdpdGl6ZXIgKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIHRoZSBwZW4gaGFzIGF0IGxlYXN0IG9uZSBidXR0b24gcHJlc3NlZCAoMiwgNCwgZXRjKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jdGhlLWJ1dHRvbnMtcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgd2lkdGggYW5kIGhlaWdodCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlTW92ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogZ2V0Q2RwQnV0dG9uKHNvdXJjZS5wcmVzc2VkLnZhbHVlcygpLm5leHQoKS52YWx1ZSA/PyA1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogc291cmNlLmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YW5nZW50aWFsUHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbHRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlOiBwcmVzc3VyZSA/PyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnByZXNzZWQuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hUb3VjaEV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hQb2ludHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2lzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5wb2ludGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgZW5kcyBoZXJlIC0tLVxuICAgICAgICAgICAgICAgIHNvdXJjZS54ID0geDtcbiAgICAgICAgICAgICAgICBzb3VyY2UueSA9IHk7XG4gICAgICAgICAgICAgICAgc291cmNlLnJhZGl1c1ggPSByYWRpdXNYO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5yYWRpdXNZID0gcmFkaXVzWTtcbiAgICAgICAgICAgICAgICBzb3VyY2UuZm9yY2UgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoIWxhc3QpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0Q29vcmRpbmF0ZUZyb21PcmlnaW4ob3JpZ2luLCBvZmZzZXRYLCBvZmZzZXRZLCBzdGFydFgsIHN0YXJ0WSkge1xuICAgICAgICBsZXQgdGFyZ2V0WDtcbiAgICAgICAgbGV0IHRhcmdldFk7XG4gICAgICAgIHN3aXRjaCAob3JpZ2luKSB7XG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgICAgICAgdGFyZ2V0WCA9IG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb2ludGVyJzpcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gc3RhcnRYICsgb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0YXJnZXRZID0gc3RhcnRZICsgb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IHBvc1gsIHk6IHBvc1kgfSA9IGF3YWl0IGdldEVsZW1lbnRDZW50ZXIodGhpcy4jY29udGV4dCwgb3JpZ2luLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlc2UgY2FuIG5ldmVyIGJlIHNwZWNpYWwgbnVtYmVycy5cbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gcG9zWCArIG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IHBvc1kgKyBvZmZzZXRZO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRhcmdldFgsIHRhcmdldFkgfTtcbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoU2Nyb2xsQWN0aW9uKF9zb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBkZWx0YVg6IHRhcmdldERlbHRhWCwgZGVsdGFZOiB0YXJnZXREZWx0YVksIHg6IG9mZnNldFgsIHk6IG9mZnNldFksIG9yaWdpbiA9ICd2aWV3cG9ydCcsIGR1cmF0aW9uID0gdGhpcy4jdGlja0R1cmF0aW9uLCB9ID0gYWN0aW9uO1xuICAgICAgICBpZiAob3JpZ2luID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignXCJwb2ludGVyXCIgb3JpZ2luIGlzIGludmFsaWQgZm9yIHNjcm9sbGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhcmdldFgsIHRhcmdldFkgfSA9IGF3YWl0IHRoaXMuI2dldENvb3JkaW5hdGVGcm9tT3JpZ2luKG9yaWdpbiwgb2Zmc2V0WCwgb2Zmc2V0WSwgMCwgMCk7XG4gICAgICAgIGlmICh0YXJnZXRYIDwgMCB8fCB0YXJnZXRZIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTW92ZVRhcmdldE91dE9mQm91bmRzRXhjZXB0aW9uKGBDYW5ub3QgbW92ZSBiZXlvbmQgdmlld3BvcnQgKHg6ICR7dGFyZ2V0WH0sIHk6ICR7dGFyZ2V0WX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnREZWx0YVggPSAwO1xuICAgICAgICBsZXQgY3VycmVudERlbHRhWSA9IDA7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGR1cmF0aW9uID4gMCA/IChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuI3RpY2tTdGFydCkgLyBkdXJhdGlvbiA6IDE7XG4gICAgICAgICAgICBsYXN0ID0gcmF0aW8gPj0gMTtcbiAgICAgICAgICAgIGxldCBkZWx0YVg7XG4gICAgICAgICAgICBsZXQgZGVsdGFZO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSB0YXJnZXREZWx0YVggLSBjdXJyZW50RGVsdGFYO1xuICAgICAgICAgICAgICAgIGRlbHRhWSA9IHRhcmdldERlbHRhWSAtIGN1cnJlbnREZWx0YVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSBNYXRoLnJvdW5kKHJhdGlvICogdGFyZ2V0RGVsdGFYIC0gY3VycmVudERlbHRhWCk7XG4gICAgICAgICAgICAgICAgZGVsdGFZID0gTWF0aC5yb3VuZChyYXRpbyAqIHRhcmdldERlbHRhWSAtIGN1cnJlbnREZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhWCAhPT0gMCB8fCBkZWx0YVkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0ga2V5U3RhdGU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZVdoZWVsJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVksXG4gICAgICAgICAgICAgICAgICAgIHg6IHRhcmdldFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRhcmdldFksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBlbmRzIGhlcmUgLS0tXG4gICAgICAgICAgICAgICAgY3VycmVudERlbHRhWCArPSBkZWx0YVg7XG4gICAgICAgICAgICAgICAgY3VycmVudERlbHRhWSArPSBkZWx0YVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCFsYXN0KTtcbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoS2V5RG93bkFjdGlvbihzb3VyY2UsIGFjdGlvbikge1xuICAgICAgICBjb25zdCByYXdLZXkgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGlmICghKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUdyYXBoZW1lKShyYXdLZXkpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4tcHJvY2Vzcy1hLWtleS1hY3Rpb25cbiAgICAgICAgICAgIC8vIFdlYkRyaXZlciBzcGVjIGFsbG93cyBhIGdyYXBoZW1lIHRvIGJlIHVzZWQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQga2V5IHZhbHVlOiAke3Jhd0tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0dyYXBoZW1lID0gKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUNvbXBsZXhHcmFwaGVtZSkocmF3S2V5KTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGtleVV0aWxzX2pzXzEuZ2V0Tm9ybWFsaXplZEtleSkocmF3S2V5KTtcbiAgICAgICAgY29uc3QgcmVwZWF0ID0gc291cmNlLnByZXNzZWQuaGFzKGtleSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoMCwga2V5VXRpbHNfanNfMS5nZXRLZXlDb2RlKShyYXdLZXkpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9ICgwLCBrZXlVdGlsc19qc18xLmdldEtleUxvY2F0aW9uKShyYXdLZXkpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnQWx0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NoaWZ0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ29udHJvbCc6XG4gICAgICAgICAgICAgICAgc291cmNlLmN0cmwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWV0YSc6XG4gICAgICAgICAgICAgICAgc291cmNlLm1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5wcmVzc2VkLmFkZChrZXkpO1xuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gc291cmNlO1xuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgLy8gVGhlIHNwcmVhZCBpcyBhIGxpdHRsZSBoYWNrIHNvIEpTIGdpdmVzIHVzIGFuIGFycmF5IG9mIHVuaWNvZGUgY2hhcmFjdGVyc1xuICAgICAgICAvLyB0byBtZWFzdXJlLlxuICAgICAgICBjb25zdCB1bm1vZGlmaWVkVGV4dCA9IGdldEtleUV2ZW50VW5tb2RpZmllZFRleHQoa2V5LCBzb3VyY2UsIGlzR3JhcGhlbWUpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZ2V0S2V5RXZlbnRUZXh0KGNvZGUgPz8gJycsIHNvdXJjZSkgPz8gdW5tb2RpZmllZFRleHQ7XG4gICAgICAgIGxldCBjb21tYW5kO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbW1hbmRzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYmVjYXVzZSBDaHJvbWl1bSBkb2Vzbid0XG4gICAgICAgIC8vIGhhbmRsZSB0aGVtLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL3JlZnMvaGVhZHMvbWFpbjp0aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2VkaXRpbmcvZWRpdGluZ19iZWhhdmlvci5jYztsPTE2OTtkcmM9YjgxNDNjZjFkZmQyNDg0Mjg5MGZjZDgzMWM0ZjVkOTA5YmVmNGZjNDticHY9MDticHQ9MS5cbiAgICAgICAgaWYgKHRoaXMuI2lzTWFjT1MgJiYgc291cmNlLm1ldGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0tleUEnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gJ1NlbGVjdEFsbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0tleUMnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gJ0NvcHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdLZXlWJzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHNvdXJjZS5zaGlmdCA/ICdQYXN0ZUFuZE1hdGNoU3R5bGUnIDogJ1Bhc3RlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnS2V5WCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSAnQ3V0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnS2V5Wic6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzb3VyY2Uuc2hpZnQgPyAnUmVkbycgOiAnVW5kbyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hLZXlFdmVudCcsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0ZXh0ID8gJ2tleURvd24nIDogJ3Jhd0tleURvd24nLFxuICAgICAgICAgICAgICAgIHdpbmRvd3NWaXJ0dWFsS2V5Q29kZTogVVNLZXlib2FyZExheW91dF9qc18xLktleVRvS2V5Q29kZVtrZXldLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdW5tb2RpZmllZFRleHQsXG4gICAgICAgICAgICAgICAgYXV0b1JlcGVhdDogcmVwZWF0LFxuICAgICAgICAgICAgICAgIGlzU3lzdGVtS2V5OiBzb3VyY2UuYWx0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gPCAzID8gbG9jYXRpb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaXNLZXlwYWQ6IGxvY2F0aW9uID09PSAzLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICBjb21tYW5kczogY29tbWFuZCA/IFtjb21tYW5kXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgICAgICAvLyBEcmFnIGNhbmNlbGxpbmcgaGFwcGVucyBvbiBlc2NhcGUuXG4gICAgICAgIGlmIChrZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5hbHQgJiZcbiAgICAgICAgICAgICAgICAoKHRoaXMuI2lzTWFjT1MgJiYgIXNvdXJjZS5jdHJsICYmICFzb3VyY2UubWV0YSkgfHwgIXRoaXMuI2lzTWFjT1MpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmNhbmNlbERyYWdnaW5nJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgZW5kcyBoZXJlIC0tLVxuICAgIH1cbiAgICAjZGlzcGF0Y2hLZXlVcEFjdGlvbihzb3VyY2UsIGFjdGlvbikge1xuICAgICAgICBjb25zdCByYXdLZXkgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGlmICghKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUdyYXBoZW1lKShyYXdLZXkpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4tcHJvY2Vzcy1hLWtleS1hY3Rpb25cbiAgICAgICAgICAgIC8vIFdlYkRyaXZlciBzcGVjIGFsbG93cyBhIGdyYXBoZW1lIHRvIGJlIHVzZWQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQga2V5IHZhbHVlOiAke3Jhd0tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0dyYXBoZW1lID0gKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUNvbXBsZXhHcmFwaGVtZSkocmF3S2V5KTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGtleVV0aWxzX2pzXzEuZ2V0Tm9ybWFsaXplZEtleSkocmF3S2V5KTtcbiAgICAgICAgaWYgKCFzb3VyY2UucHJlc3NlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoMCwga2V5VXRpbHNfanNfMS5nZXRLZXlDb2RlKShyYXdLZXkpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9ICgwLCBrZXlVdGlsc19qc18xLmdldEtleUxvY2F0aW9uKShyYXdLZXkpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnQWx0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTaGlmdCc6XG4gICAgICAgICAgICAgICAgc291cmNlLnNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDb250cm9sJzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3RybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWV0YSc6XG4gICAgICAgICAgICAgICAgc291cmNlLm1ldGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UucHJlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IHNvdXJjZTtcbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgYmVnaW5zIGhlcmUgLS0tXG4gICAgICAgIC8vIFRoZSBzcHJlYWQgaXMgYSBsaXR0bGUgaGFjayBzbyBKUyBnaXZlcyB1cyBhbiBhcnJheSBvZiB1bmljb2RlIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gdG8gbWVhc3VyZS5cbiAgICAgICAgY29uc3QgdW5tb2RpZmllZFRleHQgPSBnZXRLZXlFdmVudFVubW9kaWZpZWRUZXh0KGtleSwgc291cmNlLCBpc0dyYXBoZW1lKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldEtleUV2ZW50VGV4dChjb2RlID8/ICcnLCBzb3VyY2UpID8/IHVubW9kaWZpZWRUZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaEtleUV2ZW50Jywge1xuICAgICAgICAgICAgdHlwZTogJ2tleVVwJyxcbiAgICAgICAgICAgIHdpbmRvd3NWaXJ0dWFsS2V5Q29kZTogVVNLZXlib2FyZExheW91dF9qc18xLktleVRvS2V5Q29kZVtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB1bm1vZGlmaWVkVGV4dCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbiA8IDMgPyBsb2NhdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzU3lzdGVtS2V5OiBzb3VyY2UuYWx0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzS2V5cGFkOiBsb2NhdGlvbiA9PT0gMyxcbiAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSBQbGF0Zm9ybS1zcGVjaWZpYyBjb2RlIGVuZHMgaGVyZSAtLS1cbiAgICB9XG59XG5leHBvcnRzLkFjdGlvbkRpc3BhdGNoZXIgPSBBY3Rpb25EaXNwYXRjaGVyO1xuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbm9uLWdyYXBoZW1lIGtleSB0byBlaXRoZXIgYW4gYHVuZGVmaW5lZGAgZm9yIGEgc3BlY2lhbCBrZXlzLCBvciBhIHNpbmdsZVxuICogY2hhcmFjdGVyIG1vZGlmaWVkIGJ5IHNoaWZ0IGlmIG5lZWRlZC5cbiAqL1xuY29uc3QgZ2V0S2V5RXZlbnRVbm1vZGlmaWVkVGV4dCA9IChrZXksIHNvdXJjZSwgaXNHcmFwaGVtZSkgPT4ge1xuICAgIGlmIChpc0dyYXBoZW1lKSB7XG4gICAgICAgIC8vIEdyYXBoZW1lcyBzaG91bGQgYmUgcHJlc2VudGVkIGFzIHRleHQgaW4gdGhlIENEUCBjb21tYW5kLlxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIHJldHVybiAnXFxyJztcbiAgICB9XG4gICAgLy8gSWYga2V5IGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGl0IGlzIGEgbm9ybWFsaXplZCBrZXkgdmFsdWUsIGFuZCBzaG91bGQgYmVcbiAgICAvLyBwcmVzZW50ZWQgYXMga2V5LCBub3QgdGV4dCBpbiB0aGUgQ0RQIGNvbW1hbmQuXG4gICAgcmV0dXJuIFsuLi5rZXldLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHNvdXJjZS5zaGlmdFxuICAgICAgICAgICAgPyBrZXkudG9Mb2NhbGVVcHBlckNhc2UoJ2VuLVVTJylcbiAgICAgICAgICAgIDoga2V5XG4gICAgICAgIDogdW5kZWZpbmVkO1xufTtcbmNvbnN0IGdldEtleUV2ZW50VGV4dCA9IChjb2RlLCBzb3VyY2UpID0+IHtcbiAgICBpZiAoc291cmNlLmN0cmwpIHtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdEaWdpdDInOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwMCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnS2V5QSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwMSc7XG4gICAgICAgICAgICBjYXNlICdLZXlCJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDAyJztcbiAgICAgICAgICAgIGNhc2UgJ0tleUMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDMnO1xuICAgICAgICAgICAgY2FzZSAnS2V5RCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwNCc7XG4gICAgICAgICAgICBjYXNlICdLZXlFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDA1JztcbiAgICAgICAgICAgIGNhc2UgJ0tleUYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDYnO1xuICAgICAgICAgICAgY2FzZSAnS2V5Ryc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwNyc7XG4gICAgICAgICAgICBjYXNlICdLZXlIJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDA4JztcbiAgICAgICAgICAgIGNhc2UgJ0tleUknOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDknO1xuICAgICAgICAgICAgY2FzZSAnS2V5Sic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwQSc7XG4gICAgICAgICAgICBjYXNlICdLZXlLJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDBCJztcbiAgICAgICAgICAgIGNhc2UgJ0tleUwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MEMnO1xuICAgICAgICAgICAgY2FzZSAnS2V5TSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwRCc7XG4gICAgICAgICAgICBjYXNlICdLZXlOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDBFJztcbiAgICAgICAgICAgIGNhc2UgJ0tleU8nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MEYnO1xuICAgICAgICAgICAgY2FzZSAnS2V5UCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxMCc7XG4gICAgICAgICAgICBjYXNlICdLZXlRJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDExJztcbiAgICAgICAgICAgIGNhc2UgJ0tleVInOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTInO1xuICAgICAgICAgICAgY2FzZSAnS2V5Uyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxMyc7XG4gICAgICAgICAgICBjYXNlICdLZXlUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDE0JztcbiAgICAgICAgICAgIGNhc2UgJ0tleVUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTUnO1xuICAgICAgICAgICAgY2FzZSAnS2V5Vic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxNic7XG4gICAgICAgICAgICBjYXNlICdLZXlXJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDE3JztcbiAgICAgICAgICAgIGNhc2UgJ0tleVgnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTgnO1xuICAgICAgICAgICAgY2FzZSAnS2V5WSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxOSc7XG4gICAgICAgICAgICBjYXNlICdLZXlaJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFBJztcbiAgICAgICAgICAgIGNhc2UgJ0JyYWNrZXRMZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFCJztcbiAgICAgICAgICAgIGNhc2UgJ0JhY2tzbGFzaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxQyc7XG4gICAgICAgICAgICBjYXNlICdCcmFja2V0UmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MUQnO1xuICAgICAgICAgICAgY2FzZSAnRGlnaXQ2JzpcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MUUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01pbnVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFGJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuYWx0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbmZ1bmN0aW9uIGdldENkcEJ1dHRvbihidXR0b24pIHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jdGhlLWJ1dHRvbi1wcm9wZXJ0eVxuICAgIHN3aXRjaCAoYnV0dG9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAnbWlkZGxlJztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAnYmFjayc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAnZm9yd2FyZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRpbHQoYWN0aW9uKSB7XG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3BvaW50ZXJldmVudHMvI2NvbnZlcnRpbmctYmV0d2Vlbi10aWx0eC10aWx0eS1hbmQtYWx0aXR1ZGVhbmdsZS1hemltdXRoYW5nbGVcbiAgICBjb25zdCBhbHRpdHVkZUFuZ2xlID0gYWN0aW9uLmFsdGl0dWRlQW5nbGUgPz8gTWF0aC5QSSAvIDI7XG4gICAgY29uc3QgYXppbXV0aEFuZ2xlID0gYWN0aW9uLmF6aW11dGhBbmdsZSA/PyAwO1xuICAgIGxldCB0aWx0WFJhZGlhbnMgPSAwO1xuICAgIGxldCB0aWx0WVJhZGlhbnMgPSAwO1xuICAgIGlmIChhbHRpdHVkZUFuZ2xlID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSBwZW4gaXMgaW4gdGhlIFgtWSBwbGFuZVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID09PSAwIHx8IGF6aW11dGhBbmdsZSA9PT0gMiAqIE1hdGguUEkpIHtcbiAgICAgICAgICAgIC8vIHBlbiBpcyBvbiBwb3NpdGl2ZSBYIGF4aXNcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IE1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhemltdXRoQW5nbGUgPT09IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICAvLyBwZW4gaXMgb24gcG9zaXRpdmUgWSBheGlzXG4gICAgICAgICAgICB0aWx0WVJhZGlhbnMgPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID09PSBNYXRoLlBJKSB7XG4gICAgICAgICAgICAvLyBwZW4gaXMgb24gbmVnYXRpdmUgWCBheGlzXG4gICAgICAgICAgICB0aWx0WFJhZGlhbnMgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6aW11dGhBbmdsZSA9PT0gKDMgKiBNYXRoLlBJKSAvIDIpIHtcbiAgICAgICAgICAgIC8vIHBlbiBpcyBvbiBuZWdhdGl2ZSBZIGF4aXNcbiAgICAgICAgICAgIHRpbHRZUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gMCAmJiBhemltdXRoQW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgdGlsdFhSYWRpYW5zID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICB0aWx0WVJhZGlhbnMgPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYXppbXV0aEFuZ2xlIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgdGlsdFhSYWRpYW5zID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgICAgdGlsdFlSYWRpYW5zID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6aW11dGhBbmdsZSA+IE1hdGguUEkgJiYgYXppbXV0aEFuZ2xlIDwgKDMgKiBNYXRoLlBJKSAvIDIpIHtcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIHRpbHRZUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gKDMgKiBNYXRoLlBJKSAvIDIgJiYgYXppbXV0aEFuZ2xlIDwgMiAqIE1hdGguUEkpIHtcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgdGlsdFlSYWRpYW5zID0gLU1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRpdHVkZUFuZ2xlICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IHRhbkFsdCA9IE1hdGgudGFuKGFsdGl0dWRlQW5nbGUpO1xuICAgICAgICB0aWx0WFJhZGlhbnMgPSBNYXRoLmF0YW4oTWF0aC5jb3MoYXppbXV0aEFuZ2xlKSAvIHRhbkFsdCk7XG4gICAgICAgIHRpbHRZUmFkaWFucyA9IE1hdGguYXRhbihNYXRoLnNpbihhemltdXRoQW5nbGUpIC8gdGFuQWx0KTtcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aWx0WDogTWF0aC5yb3VuZCh0aWx0WFJhZGlhbnMgKiBmYWN0b3IpLFxuICAgICAgICB0aWx0WTogTWF0aC5yb3VuZCh0aWx0WVJhZGlhbnMgKiBmYWN0b3IpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSYWRpaSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFkaXVzWDogd2lkdGggPyB3aWR0aCAvIDIgOiAwLjUsXG4gICAgICAgIHJhZGl1c1k6IGhlaWdodCA/IGhlaWdodCAvIDIgOiAwLjUsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbkRpc3BhdGNoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0UHJvY2Vzc29yID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBBY3Rpb25EaXNwYXRjaGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvQWN0aW9uRGlzcGF0Y2hlci5qc1wiKTtcbmNvbnN0IElucHV0U3RhdGVNYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvSW5wdXRTdGF0ZU1hbmFnZXIuanNcIik7XG5jbGFzcyBJbnB1dFByb2Nlc3NvciB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI2lucHV0U3RhdGVNYW5hZ2VyID0gbmV3IElucHV0U3RhdGVNYW5hZ2VyX2pzXzEuSW5wdXRTdGF0ZU1hbmFnZXIoKTtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHRTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgIH1cbiAgICBhc3luYyBwZXJmb3JtQWN0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGlucHV0U3RhdGUgPSB0aGlzLiNpbnB1dFN0YXRlTWFuYWdlci5nZXQoY29udGV4dC50b3ApO1xuICAgICAgICBjb25zdCBhY3Rpb25zQnlUaWNrID0gdGhpcy4jZ2V0QWN0aW9uc0J5VGljayhwYXJhbXMsIGlucHV0U3RhdGUpO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gbmV3IEFjdGlvbkRpc3BhdGNoZXJfanNfMS5BY3Rpb25EaXNwYXRjaGVyKGlucHV0U3RhdGUsIGNvbnRleHQsIGF3YWl0IEFjdGlvbkRpc3BhdGNoZXJfanNfMS5BY3Rpb25EaXNwYXRjaGVyLmlzTWFjT1MoY29udGV4dCkuY2F0Y2goKCkgPT4gZmFsc2UpKTtcbiAgICAgICAgYXdhaXQgZGlzcGF0Y2hlci5kaXNwYXRjaEFjdGlvbnMoYWN0aW9uc0J5VGljayk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgcmVsZWFzZUFjdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBjb25zdCB0b3BDb250ZXh0ID0gY29udGV4dC50b3A7XG4gICAgICAgIGNvbnN0IGlucHV0U3RhdGUgPSB0aGlzLiNpbnB1dFN0YXRlTWFuYWdlci5nZXQodG9wQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBuZXcgQWN0aW9uRGlzcGF0Y2hlcl9qc18xLkFjdGlvbkRpc3BhdGNoZXIoaW5wdXRTdGF0ZSwgY29udGV4dCwgYXdhaXQgQWN0aW9uRGlzcGF0Y2hlcl9qc18xLkFjdGlvbkRpc3BhdGNoZXIuaXNNYWNPUyhjb250ZXh0KS5jYXRjaCgoKSA9PiBmYWxzZSkpO1xuICAgICAgICBhd2FpdCBkaXNwYXRjaGVyLmRpc3BhdGNoVGlja0FjdGlvbnMoaW5wdXRTdGF0ZS5jYW5jZWxMaXN0LnJldmVyc2UoKSk7XG4gICAgICAgIHRoaXMuI2lucHV0U3RhdGVNYW5hZ2VyLmRlbGV0ZSh0b3BDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBzZXRGaWxlcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gYXdhaXQgY29udGV4dC5nZXRPckNyZWF0ZVNhbmRib3godW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihTdHJpbmcoZnVuY3Rpb24gZ2V0RmlsZXMoZmlsZUxpc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBFcnJvckNvZGUuRWxlbWVudCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBFcnJvckNvZGUuTm9kZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEVycm9yQ29kZS5UeXBlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBFcnJvckNvZGUuRGlzYWJsZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWxlTGlzdExlbmd0aCA+IDEgJiYgIXRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogRXJyb3JDb2RlLk11bHRpcGxlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSwgZmFsc2UsIHBhcmFtcy5lbGVtZW50LCBbeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IHBhcmFtcy5maWxlcy5sZW5ndGggfV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaE5vZGVFeGNlcHRpb24oYENvdWxkIG5vdCBmaW5kIGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQudHlwZSA9PT0gJ3N1Y2Nlc3MnKTtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBFcnJvckNvZGUuTm9kZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uKGBDb3VsZCBub3QgZmluZCBlbGVtZW50ICR7cGFyYW1zLmVsZW1lbnQuc2hhcmVkSWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBFcnJvckNvZGUuRWxlbWVudCAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbihgRWxlbWVudCAke3BhcmFtcy5lbGVtZW50LnNoYXJlZElkfSBpcyBub3QgYSBpbnB1dGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogRXJyb3JDb2RlLlR5cGUgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5hYmxlVG9TZXRGaWxlSW5wdXRFeGNlcHRpb24oYElucHV0IGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH0gaXMgbm90IGEgZmlsZSB0eXBlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBFcnJvckNvZGUuRGlzYWJsZWQgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5hYmxlVG9TZXRGaWxlSW5wdXRFeGNlcHRpb24oYElucHV0IGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH0gaXMgZGlzYWJsZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIEVycm9yQ29kZS5NdWx0aXBsZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbihgQ2Fubm90IHNldCBtdWx0aXBsZSBmaWxlcyBvbiBhIG5vbi1tdWx0aXBsZSBpbnB1dCBlbGVtZW50YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgemVyby1sZW5ndGggYXJyYXkgaXMgYSBzcGVjaWFsIGNhc2UsIGl0IHNlZW1zIHRoYXRcbiAgICAgICAgICogRE9NLnNldEZpbGVJbnB1dEZpbGVzIGRvZXMgbm90IGFjdHVhbGx5IHVwZGF0ZSB0aGUgZmlsZXMgaW4gdGhhdCBjYXNlLCBzb1xuICAgICAgICAgKiB0aGUgc29sdXRpb24gaXMgdG8gZXZhbCB0aGUgZWxlbWVudCB2YWx1ZSB0byBhIG5ldyBGaWxlTGlzdCBkaXJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwYXJhbXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBYWFg6IFRoZXNlIGV2ZW50cyBzaG91bGQgY29udmVydGVkIHRvIHRydXN0ZWQgZXZlbnRzLiBQZXJoYXBzIGRvIHRoaXNcbiAgICAgICAgICAgIC8vIGluIGBET00uc2V0RmlsZUlucHV0RmlsZXNgP1xuICAgICAgICAgICAgYXdhaXQgcmVhbG0uY2FsbEZ1bmN0aW9uKFN0cmluZyhmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2FuY2VsJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRGF0YVRyYW5zZmVyKCkuZmlsZXM7XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGZvciB0aGlzIGNhc2UgYmVjYXVzZSBpdCBzaG91bGQgYmVoYXZlIGFraW4gdG8gYSB1c2VyIGFjdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9KSwgZmFsc2UsIHBhcmFtcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXIgZ29hbCBoZXJlIGlzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgaW5wdXQgZWxlbWVudCBmaWxlcyBhbmQgZ2V0IHRoZWlyXG4gICAgICAgIC8vIGZpbGUgcGF0aHMuXG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFsbS5jYWxsRnVuY3Rpb24oU3RyaW5nKGZ1bmN0aW9uIGdldEZpbGVzKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXM/Lml0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgfSksIGZhbHNlLCBwYXJhbXMuZWxlbWVudCwgW3sgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH1dLCBcInJvb3RcIiAvKiBTY3JpcHQuUmVzdWx0T3duZXJzaGlwLlJvb3QgKi8pO1xuICAgICAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocmVzdWx0LnR5cGUgPT09ICdzdWNjZXNzJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBoYW5kbGUgfSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShoYW5kbGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IGF3YWl0IHJlYWxtLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRE9NLmdldEZpbGVJbmZvJywge1xuICAgICAgICAgICAgICAgIG9iamVjdElkOiBoYW5kbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBoYW5kbGUuXG4gICAgICAgICAgICB2b2lkIHJlYWxtLmRpc293bihoYW5kbGUpLmNhdGNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aHMuc29ydCgpO1xuICAgICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgYXJyYXkgc28gd2UgcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBmaWxlcy5cbiAgICAgICAgY29uc3Qgc29ydGVkRmlsZXMgPSBbLi4ucGFyYW1zLmZpbGVzXS5zb3J0KCk7XG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggIT09IHBhcmFtcy5maWxlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHNvcnRlZEZpbGVzLnNvbWUoKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhzW2luZGV4XSAhPT0gcGF0aDtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9iamVjdElkIH0gPSBhd2FpdCByZWFsbS5kZXNlcmlhbGl6ZUZvckNkcChwYXJhbXMuZWxlbWVudCk7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCB0aHJvdyBzaW5jZSB0aGlzIHdhcyBqdXN0IHVzZWQgaW4gYGNhbGxGdW5jdGlvbmAgYWJvdmUuXG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShvYmplY3RJZCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWxtLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRE9NLnNldEZpbGVJbnB1dEZpbGVzJywge1xuICAgICAgICAgICAgICAgIGZpbGVzOiBwYXJhbXMuZmlsZXMsXG4gICAgICAgICAgICAgICAgb2JqZWN0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFhYWDogV2Ugc2hvdWxkIGRpc3BhdGNoIGEgdHJ1c3RlZCBldmVudC5cbiAgICAgICAgICAgIGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihTdHJpbmcoZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjYW5jZWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSksIGZhbHNlLCBwYXJhbXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAjZ2V0QWN0aW9uc0J5VGljayhwYXJhbXMsIGlucHV0U3RhdGUpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uc0J5VGljayA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwYXJhbXMuYWN0aW9ucykge1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyXCIgLyogU291cmNlVHlwZS5Qb2ludGVyICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5wYXJhbWV0ZXJzID8/PSB7IHBvaW50ZXJUeXBlOiBcIm1vdXNlXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuTW91c2UgKi8gfTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnBhcmFtZXRlcnMucG9pbnRlclR5cGUgPz89IFwibW91c2VcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Nb3VzZSAqLztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gaW5wdXRTdGF0ZS5nZXRPckNyZWF0ZShhY3Rpb24uaWQsIFwicG9pbnRlclwiIC8qIFNvdXJjZVR5cGUuUG9pbnRlciAqLywgYWN0aW9uLnBhcmFtZXRlcnMucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnN1YnR5cGUgIT09IGFjdGlvbi5wYXJhbWV0ZXJzLnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEV4cGVjdGVkIGlucHV0IHNvdXJjZSAke2FjdGlvbi5pZH0gdG8gYmUgJHtzb3VyY2Uuc3VidHlwZX07IGdvdCAke2FjdGlvbi5wYXJhbWV0ZXJzLnBvaW50ZXJUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRTdGF0ZS5nZXRPckNyZWF0ZShhY3Rpb24uaWQsIGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhY3Rpb24uYWN0aW9ucy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGl0ZW0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uc0J5VGljay5sZW5ndGggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5VGljay5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aW9uc0J5VGlja1tpXS5wdXNoKGFjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zQnlUaWNrO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRQcm9jZXNzb3IgPSBJbnB1dFByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0UHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldoZWVsU291cmNlID0gZXhwb3J0cy5Qb2ludGVyU291cmNlID0gZXhwb3J0cy5LZXlTb3VyY2UgPSBleHBvcnRzLk5vbmVTb3VyY2UgPSB2b2lkIDA7XG5jbGFzcyBOb25lU291cmNlIHtcbiAgICB0eXBlID0gXCJub25lXCIgLyogU291cmNlVHlwZS5Ob25lICovO1xufVxuZXhwb3J0cy5Ob25lU291cmNlID0gTm9uZVNvdXJjZTtcbmNsYXNzIEtleVNvdXJjZSB7XG4gICAgdHlwZSA9IFwia2V5XCIgLyogU291cmNlVHlwZS5LZXkgKi87XG4gICAgcHJlc3NlZCA9IG5ldyBTZXQoKTtcbiAgICAvLyBUaGlzIGlzIGEgYml0ZmllbGQgdGhhdCBtYXRjaGVzIHRoZSBtb2RpZmllcnMgcGFyYW1ldGVyIG9mXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0lucHV0LyNtZXRob2QtZGlzcGF0Y2hLZXlFdmVudFxuICAgICNtb2RpZmllcnMgPSAwO1xuICAgIGdldCBtb2RpZmllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtb2RpZmllcnM7XG4gICAgfVxuICAgIGdldCBhbHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jbW9kaWZpZXJzICYgMSkgPT09IDE7XG4gICAgfVxuICAgIHNldCBhbHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDEpO1xuICAgIH1cbiAgICBnZXQgY3RybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNtb2RpZmllcnMgJiAyKSA9PT0gMjtcbiAgICB9XG4gICAgc2V0IGN0cmwodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDIpO1xuICAgIH1cbiAgICBnZXQgbWV0YSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNtb2RpZmllcnMgJiA0KSA9PT0gNDtcbiAgICB9XG4gICAgc2V0IG1ldGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDQpO1xuICAgIH1cbiAgICBnZXQgc2hpZnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jbW9kaWZpZXJzICYgOCkgPT09IDg7XG4gICAgfVxuICAgIHNldCBzaGlmdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNzZXRNb2RpZmllcih2YWx1ZSwgOCk7XG4gICAgfVxuICAgICNzZXRNb2RpZmllcih2YWx1ZSwgYml0KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4jbW9kaWZpZXJzIHw9IGJpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21vZGlmaWVycyAmPSB+Yml0O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXlTb3VyY2UgPSBLZXlTb3VyY2U7XG5jbGFzcyBQb2ludGVyU291cmNlIHtcbiAgICB0eXBlID0gXCJwb2ludGVyXCIgLyogU291cmNlVHlwZS5Qb2ludGVyICovO1xuICAgIHN1YnR5cGU7XG4gICAgcG9pbnRlcklkO1xuICAgIHByZXNzZWQgPSBuZXcgU2V0KCk7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gICAgcmFkaXVzWDtcbiAgICByYWRpdXNZO1xuICAgIGZvcmNlO1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzdWJ0eXBlKSB7XG4gICAgICAgIHRoaXMucG9pbnRlcklkID0gaWQ7XG4gICAgICAgIHRoaXMuc3VidHlwZSA9IHN1YnR5cGU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBiaXRmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIGJ1dHRvbnMgcGFyYW1ldGVyIG9mXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0lucHV0LyNtZXRob2QtZGlzcGF0Y2hNb3VzZUV2ZW50XG4gICAgZ2V0IGJ1dHRvbnMoKSB7XG4gICAgICAgIGxldCBidXR0b25zID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyB8PSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgfD0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBidXR0b25zIHw9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyB8PSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgfD0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidXR0b25zO1xuICAgIH1cbiAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBzdGFydHMgaGVyZSAtLS1cbiAgICAvLyBJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQgZG9lc24ndCBrbm93IHRoZSBjb25jZXB0IG9mIGRvdWJsZSBjbGljaywgc28gd2VcbiAgICAvLyBuZWVkIHRvIGNyZWF0ZSB0aGUgbG9naWMsIHNpbWlsYXIgdG8gaG93IGl0J3MgZG9uZSBmb3IgT1NlczpcbiAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvcmVmcy9oZWFkcy9tYWluOnVpL2V2ZW50cy9ldmVudC5jYztsPTQ3OVxuICAgIHN0YXRpYyBDbGlja0NvbnRleHQgPSBjbGFzcyBDbGlja0NvbnRleHQge1xuICAgICAgICBzdGF0aWMgI0RPVUJMRV9DTElDS19USU1FX01TID0gNTAwO1xuICAgICAgICBzdGF0aWMgI01BWF9ET1VCTEVfQ0xJQ0tfUkFESVVTID0gMjtcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAjeDtcbiAgICAgICAgI3k7XG4gICAgICAgICN0aW1lO1xuICAgICAgICBjb25zdHJ1Y3Rvcih4LCB5LCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLiN4ID0geDtcbiAgICAgICAgICAgIHRoaXMuI3kgPSB5O1xuICAgICAgICAgICAgdGhpcy4jdGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGFyZShjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVGhlIGNsaWNrIG5lZWRzIHRvIGJlIHdpdGhpbiBhIGNlcnRhaW4gYW1vdW50IG9mIG1zLlxuICAgICAgICAgICAgY29udGV4dC4jdGltZSAtIHRoaXMuI3RpbWUgPiBDbGlja0NvbnRleHQuI0RPVUJMRV9DTElDS19USU1FX01TIHx8XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWNrIG5lZWRzIHRvIGJlIHdpdGhpbiBhIGNlcnRhaW4gc3F1YXJlIHJhZGl1cy5cbiAgICAgICAgICAgICAgICBNYXRoLmFicyhjb250ZXh0LiN4IC0gdGhpcy4jeCkgPlxuICAgICAgICAgICAgICAgICAgICBDbGlja0NvbnRleHQuI01BWF9ET1VCTEVfQ0xJQ0tfUkFESVVTIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoY29udGV4dC4jeSAtIHRoaXMuI3kpID4gQ2xpY2tDb250ZXh0LiNNQVhfRE9VQkxFX0NMSUNLX1JBRElVUyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgICNjbGlja0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgIHNldENsaWNrQ291bnQoYnV0dG9uLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdG9yZWRDb250ZXh0ID0gdGhpcy4jY2xpY2tDb250ZXh0cy5nZXQoYnV0dG9uKTtcbiAgICAgICAgaWYgKCFzdG9yZWRDb250ZXh0IHx8IHN0b3JlZENvbnRleHQuY29tcGFyZShjb250ZXh0KSkge1xuICAgICAgICAgICAgc3RvcmVkQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgKytzdG9yZWRDb250ZXh0LmNvdW50O1xuICAgICAgICB0aGlzLiNjbGlja0NvbnRleHRzLnNldChidXR0b24sIHN0b3JlZENvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RvcmVkQ29udGV4dC5jb3VudDtcbiAgICB9XG4gICAgZ2V0Q2xpY2tDb3VudChidXR0b24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NsaWNrQ29udGV4dHMuZ2V0KGJ1dHRvbik/LmNvdW50ID8/IDA7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2ludGVyU291cmNlID0gUG9pbnRlclNvdXJjZTtcbmNsYXNzIFdoZWVsU291cmNlIHtcbiAgICB0eXBlID0gXCJ3aGVlbFwiIC8qIFNvdXJjZVR5cGUuV2hlZWwgKi87XG59XG5leHBvcnRzLldoZWVsU291cmNlID0gV2hlZWxTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFNvdXJjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnB1dFN0YXRlID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IE11dGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvTXV0ZXguanNcIik7XG5jb25zdCBJbnB1dFNvdXJjZV9qc18xID0gcmVxdWlyZShcIi4vSW5wdXRTb3VyY2UuanNcIik7XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjYW5jZWxMaXN0ID0gW107XG4gICAgI3NvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgI211dGV4ID0gbmV3IE11dGV4X2pzXzEuTXV0ZXgoKTtcbiAgICBnZXRPckNyZWF0ZShpZCwgdHlwZSwgc3VidHlwZSkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy4jc291cmNlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBTb3VyY2VUeXBlLk5vbmUgKi86XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBJbnB1dFNvdXJjZV9qc18xLk5vbmVTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImtleVwiIC8qIFNvdXJjZVR5cGUuS2V5ICovOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgSW5wdXRTb3VyY2VfanNfMS5LZXlTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJcIiAvKiBTb3VyY2VUeXBlLlBvaW50ZXIgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJJZCA9IHN1YnR5cGUgPT09IFwibW91c2VcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Nb3VzZSAqLyA/IDAgOiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVySWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFssIHNvdXJjZV0gb2YgdGhpcy4jc291cmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSBcInBvaW50ZXJcIiAvKiBTb3VyY2VUeXBlLlBvaW50ZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWRzLmFkZChzb3VyY2UucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9pbnRlcklkcy5oYXMocG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbmV3IElucHV0U291cmNlX2pzXzEuUG9pbnRlclNvdXJjZShwb2ludGVySWQsIHN1YnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIndoZWVsXCIgLyogU291cmNlVHlwZS5XaGVlbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbmV3IElucHV0U291cmNlX2pzXzEuV2hlZWxTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBFeHBlY3RlZCBcIiR7XCJub25lXCIgLyogU291cmNlVHlwZS5Ob25lICovfVwiLCBcIiR7XCJrZXlcIiAvKiBTb3VyY2VUeXBlLktleSAqL31cIiwgXCIke1wicG9pbnRlclwiIC8qIFNvdXJjZVR5cGUuUG9pbnRlciAqL31cIiwgb3IgXCIke1wid2hlZWxcIiAvKiBTb3VyY2VUeXBlLldoZWVsICovfVwiLiBGb3VuZCB1bmtub3duIHNvdXJjZSB0eXBlICR7dHlwZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzb3VyY2VzLnNldChpZCwgc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYElucHV0IHNvdXJjZSB0eXBlIG9mICR7aWR9IGlzICR7c291cmNlLnR5cGV9LCBidXQgcmVjZWl2ZWQgJHt0eXBlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy4jc291cmNlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGBJbnRlcm5hbCBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBnZXRHbG9iYWxLZXlTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgSW5wdXRTb3VyY2VfanNfMS5LZXlTb3VyY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBzb3VyY2VdIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudHlwZSAhPT0gXCJrZXlcIiAvKiBTb3VyY2VUeXBlLktleSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVzc2VkIG9mIHNvdXJjZS5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJlc3NlZC5hZGQocHJlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hbHQgfHw9IHNvdXJjZS5hbHQ7XG4gICAgICAgICAgICBzdGF0ZS5jdHJsIHx8PSBzb3VyY2UuY3RybDtcbiAgICAgICAgICAgIHN0YXRlLm1ldGEgfHw9IHNvdXJjZS5tZXRhO1xuICAgICAgICAgICAgc3RhdGUuc2hpZnQgfHw9IHNvdXJjZS5zaGlmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGdldCBxdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI211dGV4O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRTdGF0ZSA9IElucHV0U3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0U3RhdGVNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvYXNzZXJ0LmpzXCIpO1xuY29uc3QgSW5wdXRTdGF0ZV9qc18xID0gcmVxdWlyZShcIi4vSW5wdXRTdGF0ZS5qc1wiKTtcbi8vIFdlIHVzZSBhIHdlYWsgbWFwIGhlcmUgYXMgc3BlY2lmaWVkIGhlcmU6XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tYnJvd3NpbmctY29udGV4dC1pbnB1dC1zdGF0ZS1tYXBcbmNsYXNzIElucHV0U3RhdGVNYW5hZ2VyIGV4dGVuZHMgV2Vha01hcCB7XG4gICAgZ2V0KGNvbnRleHQpIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkoY29udGV4dC5pc1RvcExldmVsQ29udGV4dCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29udGV4dCwgbmV3IElucHV0U3RhdGVfanNfMS5JbnB1dFN0YXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoY29udGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnB1dFN0YXRlTWFuYWdlciA9IElucHV0U3RhdGVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5wdXRTdGF0ZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5VG9LZXlDb2RlID0gdm9pZCAwO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgb25jZSBodHRwczovL2NycmV2LmNvbS9jLzQ1NDgyOTAgaXMgc3RhYmx5IGluIENocm9taXVtLlxuLy8gYElucHV0LmRpc3BhdGNoS2V5Ym9hcmRFdmVudGAgd2lsbCBhdXRvbWF0aWNhbGx5IGhhbmRsZSB0aGVzZSBjb252ZXJzaW9ucy5cbmV4cG9ydHMuS2V5VG9LZXlDb2RlID0ge1xuICAgICcwJzogNDgsXG4gICAgJzEnOiA0OSxcbiAgICAnMic6IDUwLFxuICAgICczJzogNTEsXG4gICAgJzQnOiA1MixcbiAgICAnNSc6IDUzLFxuICAgICc2JzogNTQsXG4gICAgJzcnOiA1NSxcbiAgICAnOCc6IDU2LFxuICAgICc5JzogNTcsXG4gICAgQWJvcnQ6IDMsXG4gICAgSGVscDogNixcbiAgICBCYWNrc3BhY2U6IDgsXG4gICAgVGFiOiA5LFxuICAgIE51bXBhZDU6IDEyLFxuICAgIE51bXBhZEVudGVyOiAxMyxcbiAgICBFbnRlcjogMTMsXG4gICAgJ1xcXFxyJzogMTMsXG4gICAgJ1xcXFxuJzogMTMsXG4gICAgU2hpZnRMZWZ0OiAxNixcbiAgICBTaGlmdFJpZ2h0OiAxNixcbiAgICBDb250cm9sTGVmdDogMTcsXG4gICAgQ29udHJvbFJpZ2h0OiAxNyxcbiAgICBBbHRMZWZ0OiAxOCxcbiAgICBBbHRSaWdodDogMTgsXG4gICAgUGF1c2U6IDE5LFxuICAgIENhcHNMb2NrOiAyMCxcbiAgICBFc2NhcGU6IDI3LFxuICAgIENvbnZlcnQ6IDI4LFxuICAgIE5vbkNvbnZlcnQ6IDI5LFxuICAgIFNwYWNlOiAzMixcbiAgICBOdW1wYWQ5OiAzMyxcbiAgICBQYWdlVXA6IDMzLFxuICAgIE51bXBhZDM6IDM0LFxuICAgIFBhZ2VEb3duOiAzNCxcbiAgICBFbmQ6IDM1LFxuICAgIE51bXBhZDE6IDM1LFxuICAgIEhvbWU6IDM2LFxuICAgIE51bXBhZDc6IDM2LFxuICAgIEFycm93TGVmdDogMzcsXG4gICAgTnVtcGFkNDogMzcsXG4gICAgTnVtcGFkODogMzgsXG4gICAgQXJyb3dVcDogMzgsXG4gICAgQXJyb3dSaWdodDogMzksXG4gICAgTnVtcGFkNjogMzksXG4gICAgTnVtcGFkMjogNDAsXG4gICAgQXJyb3dEb3duOiA0MCxcbiAgICBTZWxlY3Q6IDQxLFxuICAgIE9wZW46IDQzLFxuICAgIFByaW50U2NyZWVuOiA0NCxcbiAgICBJbnNlcnQ6IDQ1LFxuICAgIE51bXBhZDA6IDQ1LFxuICAgIERlbGV0ZTogNDYsXG4gICAgTnVtcGFkRGVjaW1hbDogNDYsXG4gICAgRGlnaXQwOiA0OCxcbiAgICBEaWdpdDE6IDQ5LFxuICAgIERpZ2l0MjogNTAsXG4gICAgRGlnaXQzOiA1MSxcbiAgICBEaWdpdDQ6IDUyLFxuICAgIERpZ2l0NTogNTMsXG4gICAgRGlnaXQ2OiA1NCxcbiAgICBEaWdpdDc6IDU1LFxuICAgIERpZ2l0ODogNTYsXG4gICAgRGlnaXQ5OiA1NyxcbiAgICBLZXlBOiA2NSxcbiAgICBLZXlCOiA2NixcbiAgICBLZXlDOiA2NyxcbiAgICBLZXlEOiA2OCxcbiAgICBLZXlFOiA2OSxcbiAgICBLZXlGOiA3MCxcbiAgICBLZXlHOiA3MSxcbiAgICBLZXlIOiA3MixcbiAgICBLZXlJOiA3MyxcbiAgICBLZXlKOiA3NCxcbiAgICBLZXlLOiA3NSxcbiAgICBLZXlMOiA3NixcbiAgICBLZXlNOiA3NyxcbiAgICBLZXlOOiA3OCxcbiAgICBLZXlPOiA3OSxcbiAgICBLZXlQOiA4MCxcbiAgICBLZXlROiA4MSxcbiAgICBLZXlSOiA4MixcbiAgICBLZXlTOiA4MyxcbiAgICBLZXlUOiA4NCxcbiAgICBLZXlVOiA4NSxcbiAgICBLZXlWOiA4NixcbiAgICBLZXlXOiA4NyxcbiAgICBLZXlYOiA4OCxcbiAgICBLZXlZOiA4OSxcbiAgICBLZXlaOiA5MCxcbiAgICBNZXRhTGVmdDogOTEsXG4gICAgTWV0YVJpZ2h0OiA5MixcbiAgICBDb250ZXh0TWVudTogOTMsXG4gICAgTnVtcGFkTXVsdGlwbHk6IDEwNixcbiAgICBOdW1wYWRBZGQ6IDEwNyxcbiAgICBOdW1wYWRTdWJ0cmFjdDogMTA5LFxuICAgIE51bXBhZERpdmlkZTogMTExLFxuICAgIEYxOiAxMTIsXG4gICAgRjI6IDExMyxcbiAgICBGMzogMTE0LFxuICAgIEY0OiAxMTUsXG4gICAgRjU6IDExNixcbiAgICBGNjogMTE3LFxuICAgIEY3OiAxMTgsXG4gICAgRjg6IDExOSxcbiAgICBGOTogMTIwLFxuICAgIEYxMDogMTIxLFxuICAgIEYxMTogMTIyLFxuICAgIEYxMjogMTIzLFxuICAgIEYxMzogMTI0LFxuICAgIEYxNDogMTI1LFxuICAgIEYxNTogMTI2LFxuICAgIEYxNjogMTI3LFxuICAgIEYxNzogMTI4LFxuICAgIEYxODogMTI5LFxuICAgIEYxOTogMTMwLFxuICAgIEYyMDogMTMxLFxuICAgIEYyMTogMTMyLFxuICAgIEYyMjogMTMzLFxuICAgIEYyMzogMTM0LFxuICAgIEYyNDogMTM1LFxuICAgIE51bUxvY2s6IDE0NCxcbiAgICBTY3JvbGxMb2NrOiAxNDUsXG4gICAgQXVkaW9Wb2x1bWVNdXRlOiAxNzMsXG4gICAgQXVkaW9Wb2x1bWVEb3duOiAxNzQsXG4gICAgQXVkaW9Wb2x1bWVVcDogMTc1LFxuICAgIE1lZGlhVHJhY2tOZXh0OiAxNzYsXG4gICAgTWVkaWFUcmFja1ByZXZpb3VzOiAxNzcsXG4gICAgTWVkaWFTdG9wOiAxNzgsXG4gICAgTWVkaWFQbGF5UGF1c2U6IDE3OSxcbiAgICBTZW1pY29sb246IDE4NixcbiAgICBFcXVhbDogMTg3LFxuICAgIE51bXBhZEVxdWFsOiAxODcsXG4gICAgQ29tbWE6IDE4OCxcbiAgICBNaW51czogMTg5LFxuICAgIFBlcmlvZDogMTkwLFxuICAgIFNsYXNoOiAxOTEsXG4gICAgQmFja3F1b3RlOiAxOTIsXG4gICAgQnJhY2tldExlZnQ6IDIxOSxcbiAgICBCYWNrc2xhc2g6IDIyMCxcbiAgICBCcmFja2V0UmlnaHQ6IDIyMSxcbiAgICBRdW90ZTogMjIyLFxuICAgIEFsdEdyYXBoOiAyMjUsXG4gICAgUHJvcHM6IDI0NyxcbiAgICBDYW5jZWw6IDMsXG4gICAgQ2xlYXI6IDEyLFxuICAgIFNoaWZ0OiAxNixcbiAgICBDb250cm9sOiAxNyxcbiAgICBBbHQ6IDE4LFxuICAgIEFjY2VwdDogMzAsXG4gICAgTW9kZUNoYW5nZTogMzEsXG4gICAgJyAnOiAzMixcbiAgICBQcmludDogNDIsXG4gICAgRXhlY3V0ZTogNDMsXG4gICAgJ1xcXFx1MDAwMCc6IDQ2LFxuICAgIGE6IDY1LFxuICAgIGI6IDY2LFxuICAgIGM6IDY3LFxuICAgIGQ6IDY4LFxuICAgIGU6IDY5LFxuICAgIGY6IDcwLFxuICAgIGc6IDcxLFxuICAgIGg6IDcyLFxuICAgIGk6IDczLFxuICAgIGo6IDc0LFxuICAgIGs6IDc1LFxuICAgIGw6IDc2LFxuICAgIG06IDc3LFxuICAgIG46IDc4LFxuICAgIG86IDc5LFxuICAgIHA6IDgwLFxuICAgIHE6IDgxLFxuICAgIHI6IDgyLFxuICAgIHM6IDgzLFxuICAgIHQ6IDg0LFxuICAgIHU6IDg1LFxuICAgIHY6IDg2LFxuICAgIHc6IDg3LFxuICAgIHg6IDg4LFxuICAgIHk6IDg5LFxuICAgIHo6IDkwLFxuICAgIE1ldGE6IDkxLFxuICAgICcqJzogMTA2LFxuICAgICcrJzogMTA3LFxuICAgICctJzogMTA5LFxuICAgICcvJzogMTExLFxuICAgICc7JzogMTg2LFxuICAgICc9JzogMTg3LFxuICAgICcsJzogMTg4LFxuICAgICcuJzogMTkwLFxuICAgICdgJzogMTkyLFxuICAgICdbJzogMjE5LFxuICAgICdcXFxcXFxcXCc6IDIyMCxcbiAgICAnXSc6IDIyMSxcbiAgICBcIidcIjogMjIyLFxuICAgIEF0dG46IDI0NixcbiAgICBDclNlbDogMjQ3LFxuICAgIEV4U2VsOiAyNDgsXG4gICAgRXJhc2VFb2Y6IDI0OSxcbiAgICBQbGF5OiAyNTAsXG4gICAgWm9vbU91dDogMjUxLFxuICAgICcpJzogNDgsXG4gICAgJyEnOiA0OSxcbiAgICAnQCc6IDUwLFxuICAgICcjJzogNTEsXG4gICAgJDogNTIsXG4gICAgJyUnOiA1MyxcbiAgICAnXic6IDU0LFxuICAgICcmJzogNTUsXG4gICAgJygnOiA1NyxcbiAgICBBOiA2NSxcbiAgICBCOiA2NixcbiAgICBDOiA2NyxcbiAgICBEOiA2OCxcbiAgICBFOiA2OSxcbiAgICBGOiA3MCxcbiAgICBHOiA3MSxcbiAgICBIOiA3MixcbiAgICBJOiA3MyxcbiAgICBKOiA3NCxcbiAgICBLOiA3NSxcbiAgICBMOiA3NixcbiAgICBNOiA3NyxcbiAgICBOOiA3OCxcbiAgICBPOiA3OSxcbiAgICBQOiA4MCxcbiAgICBROiA4MSxcbiAgICBSOiA4MixcbiAgICBTOiA4MyxcbiAgICBUOiA4NCxcbiAgICBVOiA4NSxcbiAgICBWOiA4NixcbiAgICBXOiA4NyxcbiAgICBYOiA4OCxcbiAgICBZOiA4OSxcbiAgICBaOiA5MCxcbiAgICAnOic6IDE4NixcbiAgICAnPCc6IDE4OCxcbiAgICBfOiAxODksXG4gICAgJz4nOiAxOTAsXG4gICAgJz8nOiAxOTEsXG4gICAgJ34nOiAxOTIsXG4gICAgJ3snOiAyMTksXG4gICAgJ3wnOiAyMjAsXG4gICAgJ30nOiAyMjEsXG4gICAgJ1wiJzogMjIyLFxuICAgIENhbWVyYTogNDQsXG4gICAgRW5kQ2FsbDogOTUsXG4gICAgVm9sdW1lRG93bjogMTgyLFxuICAgIFZvbHVtZVVwOiAxODMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VVNLZXlib2FyZExheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROb3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZEtleTtcbmV4cG9ydHMuZ2V0S2V5Q29kZSA9IGdldEtleUNvZGU7XG5leHBvcnRzLmdldEtleUxvY2F0aW9uID0gZ2V0S2V5TG9jYXRpb247XG4vKipcbiAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQga2V5IHZhbHVlIGZvciBhIGdpdmVuIGtleSBhY2NvcmRpbmcgdG8gdGhlIHRhYmxlOlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci8jZGZuLW5vcm1hbGl6ZWQta2V5LXZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRLZXkodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDAnOlxuICAgICAgICAgICAgcmV0dXJuICdVbmlkZW50aWZpZWQnO1xuICAgICAgICBjYXNlICdcXHVFMDAxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ2FuY2VsJztcbiAgICAgICAgY2FzZSAnXFx1RTAwMic6XG4gICAgICAgICAgICByZXR1cm4gJ0hlbHAnO1xuICAgICAgICBjYXNlICdcXHVFMDAzJzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3NwYWNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAwNCc6XG4gICAgICAgICAgICByZXR1cm4gJ1RhYic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDUnOlxuICAgICAgICAgICAgcmV0dXJuICdDbGVhcic7XG4gICAgICAgIC8vIFNwZWNpZmljYXRpb24gZGVjbGFyZXMgdGhlICdcXHVFMDA2JyB0byBiZSBgUmV0dXJuYCwgYnV0IGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAgICAgICAgLy8gQ2hyb21lLCBzbyBmYWxsIGJhY2sgdG8gYEVudGVyYCwgd2hpY2ggYWxpZ25zIHdpdGggV1BULlxuICAgICAgICBjYXNlICdcXHVFMDA2JzpcbiAgICAgICAgY2FzZSAnXFx1RTAwNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0VudGVyJztcbiAgICAgICAgY2FzZSAnXFx1RTAwOCc6XG4gICAgICAgICAgICByZXR1cm4gJ1NoaWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0NvbnRyb2wnO1xuICAgICAgICBjYXNlICdcXHVFMDBBJzpcbiAgICAgICAgICAgIHJldHVybiAnQWx0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwQic6XG4gICAgICAgICAgICByZXR1cm4gJ1BhdXNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQyc6XG4gICAgICAgICAgICByZXR1cm4gJ0VzY2FwZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEQnOlxuICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgY2FzZSAnXFx1RTAwRSc6XG4gICAgICAgICAgICByZXR1cm4gJ1BhZ2VVcCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEYnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlRG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTAnOlxuICAgICAgICAgICAgcmV0dXJuICdFbmQnO1xuICAgICAgICBjYXNlICdcXHVFMDExJzpcbiAgICAgICAgICAgIHJldHVybiAnSG9tZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTInOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd0xlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDEzJzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dVcCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTQnOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd1JpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93RG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTYnOlxuICAgICAgICAgICAgcmV0dXJuICdJbnNlcnQnO1xuICAgICAgICBjYXNlICdcXHVFMDE3JzpcbiAgICAgICAgICAgIHJldHVybiAnRGVsZXRlJztcbiAgICAgICAgY2FzZSAnXFx1RTAxOCc6XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICBjYXNlICdcXHVFMDE5JzpcbiAgICAgICAgICAgIHJldHVybiAnPSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMUEnOlxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQic6XG4gICAgICAgICAgICByZXR1cm4gJzEnO1xuICAgICAgICBjYXNlICdcXHVFMDFDJzpcbiAgICAgICAgICAgIHJldHVybiAnMic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMUQnOlxuICAgICAgICAgICAgcmV0dXJuICczJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRSc6XG4gICAgICAgICAgICByZXR1cm4gJzQnO1xuICAgICAgICBjYXNlICdcXHVFMDFGJzpcbiAgICAgICAgICAgIHJldHVybiAnNSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjAnOlxuICAgICAgICAgICAgcmV0dXJuICc2JztcbiAgICAgICAgY2FzZSAnXFx1RTAyMSc6XG4gICAgICAgICAgICByZXR1cm4gJzcnO1xuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgICAgIHJldHVybiAnOCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjMnOlxuICAgICAgICAgICAgcmV0dXJuICc5JztcbiAgICAgICAgY2FzZSAnXFx1RTAyNCc6XG4gICAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgICAgIHJldHVybiAnKyc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjYnOlxuICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgY2FzZSAnXFx1RTAyNyc6XG4gICAgICAgICAgICByZXR1cm4gJy0nO1xuICAgICAgICBjYXNlICdcXHVFMDI4JzpcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjknOlxuICAgICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMic6XG4gICAgICAgICAgICByZXR1cm4gJ0YyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0YzJztcbiAgICAgICAgY2FzZSAnXFx1RTAzNCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y0JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y1JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNic6XG4gICAgICAgICAgICByZXR1cm4gJ0Y2JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y3JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y4JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y5JztcbiAgICAgICAgY2FzZSAnXFx1RTAzQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxMCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwM0InOlxuICAgICAgICAgICAgcmV0dXJuICdGMTEnO1xuICAgICAgICBjYXNlICdcXHVFMDNDJzpcbiAgICAgICAgICAgIHJldHVybiAnRjEyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzRCc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGEnO1xuICAgICAgICBjYXNlICdcXHVFMDQwJzpcbiAgICAgICAgICAgIHJldHVybiAnWmVua2FrdUhhbmtha3UnO1xuICAgICAgICBjYXNlICdcXHVFMDUwJzpcbiAgICAgICAgICAgIHJldHVybiAnU2hpZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTInOlxuICAgICAgICAgICAgcmV0dXJuICdBbHQnO1xuICAgICAgICBjYXNlICdcXHVFMDUzJzpcbiAgICAgICAgICAgIHJldHVybiAnTWV0YSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTQnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlVXAnO1xuICAgICAgICBjYXNlICdcXHVFMDU1JzpcbiAgICAgICAgICAgIHJldHVybiAnUGFnZURvd24nO1xuICAgICAgICBjYXNlICdcXHVFMDU2JzpcbiAgICAgICAgICAgIHJldHVybiAnRW5kJztcbiAgICAgICAgY2FzZSAnXFx1RTA1Nyc6XG4gICAgICAgICAgICByZXR1cm4gJ0hvbWUnO1xuICAgICAgICBjYXNlICdcXHVFMDU4JzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dMZWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93VXAnO1xuICAgICAgICBjYXNlICdcXHVFMDVBJzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dSaWdodCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNUInOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd0Rvd24nO1xuICAgICAgICBjYXNlICdcXHVFMDVDJzpcbiAgICAgICAgICAgIHJldHVybiAnSW5zZXJ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1RCc6XG4gICAgICAgICAgICByZXR1cm4gJ0RlbGV0ZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXkgY29kZSBmb3IgYSBnaXZlbiBrZXkgYWNjb3JkaW5nIHRvIHRoZSB0YWJsZTpcbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvI2Rmbi1zaGlmdGVkLWNoYXJhY3RlclxuICovXG5mdW5jdGlvbiBnZXRLZXlDb2RlKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3F1b3RlJztcbiAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgcmV0dXJuICdCYWNrc2xhc2gnO1xuICAgICAgICBjYXNlICdcXHVFMDAzJzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3NwYWNlJztcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgcmV0dXJuICdCcmFja2V0TGVmdCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiAnQnJhY2tldFJpZ2h0JztcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICdDb21tYSc7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQwJztcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDEnO1xuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0Mic7XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQzJztcbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDQnO1xuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0NSc7XG4gICAgICAgIGNhc2UgJzYnOlxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQ2JztcbiAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDcnO1xuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0OCc7XG4gICAgICAgIGNhc2UgJzknOlxuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQ5JztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgcmV0dXJuICdFcXVhbCc7XG4gICAgICAgIC8vIFRoZSBzcGVjIGRlY2xhcmVzIHRoZSAnPCcgdG8gYmUgYEludGxCYWNrc2xhc2hgIGFzIHdlbGwsIGJ1dCBpdCBpcyBhbHJlYWR5IGNvdmVyZWRcbiAgICAgICAgLy8gaW4gdGhlIGBDb21tYWAgYWJvdmUuXG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdJbnRsQmFja3NsYXNoJztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlBJztcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlCJztcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlDJztcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlEJztcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlFJztcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlGJztcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlHJztcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlIJztcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlJJztcbiAgICAgICAgY2FzZSAnaic6XG4gICAgICAgIGNhc2UgJ0onOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlKJztcbiAgICAgICAgY2FzZSAnayc6XG4gICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlLJztcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlMJztcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlNJztcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlOJztcbiAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgIGNhc2UgJ08nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlPJztcbiAgICAgICAgY2FzZSAncCc6XG4gICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlQJztcbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlRJztcbiAgICAgICAgY2FzZSAncic6XG4gICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlSJztcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlTJztcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlUJztcbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlVJztcbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlWJztcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlXJztcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlYJztcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlZJztcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlaJztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgcmV0dXJuICdNaW51cyc7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgcmV0dXJuICdQZXJpb2QnO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ1F1b3RlJztcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdTZW1pY29sb24nO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICByZXR1cm4gJ1NsYXNoJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0FsdExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUyJzpcbiAgICAgICAgICAgIHJldHVybiAnQWx0UmlnaHQnO1xuICAgICAgICBjYXNlICdcXHVFMDA5JzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbFJpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwNic6XG4gICAgICAgICAgICByZXR1cm4gJ0VudGVyJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQic6XG4gICAgICAgICAgICByZXR1cm4gJ1BhdXNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAzRCc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGFMZWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1Myc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGFSaWdodCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDgnOlxuICAgICAgICAgICAgcmV0dXJuICdTaGlmdExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUwJzpcbiAgICAgICAgICAgIHJldHVybiAnU2hpZnRSaWdodCc7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXHVFMDBEJzpcbiAgICAgICAgICAgIHJldHVybiAnU3BhY2UnO1xuICAgICAgICBjYXNlICdcXHVFMDA0JzpcbiAgICAgICAgICAgIHJldHVybiAnVGFiJztcbiAgICAgICAgY2FzZSAnXFx1RTAxNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0RlbGV0ZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTAnOlxuICAgICAgICAgICAgcmV0dXJuICdFbmQnO1xuICAgICAgICBjYXNlICdcXHVFMDAyJzpcbiAgICAgICAgICAgIHJldHVybiAnSGVscCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTEnOlxuICAgICAgICAgICAgcmV0dXJuICdIb21lJztcbiAgICAgICAgY2FzZSAnXFx1RTAxNic6XG4gICAgICAgICAgICByZXR1cm4gJ0luc2VydCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEYnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlRG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEUnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlVXAnO1xuICAgICAgICBjYXNlICdcXHVFMDE1JzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dEb3duJztcbiAgICAgICAgY2FzZSAnXFx1RTAxMic6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93TGVmdCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTQnOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd1JpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93VXAnO1xuICAgICAgICBjYXNlICdcXHVFMDBDJzpcbiAgICAgICAgICAgIHJldHVybiAnRXNjYXBlJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMic6XG4gICAgICAgICAgICByZXR1cm4gJ0YyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0YzJztcbiAgICAgICAgY2FzZSAnXFx1RTAzNCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y0JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y1JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNic6XG4gICAgICAgICAgICByZXR1cm4gJ0Y2JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y3JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y4JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y5JztcbiAgICAgICAgY2FzZSAnXFx1RTAzQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxMCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwM0InOlxuICAgICAgICAgICAgcmV0dXJuICdGMTEnO1xuICAgICAgICBjYXNlICdcXHVFMDNDJzpcbiAgICAgICAgICAgIHJldHVybiAnRjEyJztcbiAgICAgICAgY2FzZSAnXFx1RTAxOSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZEVxdWFsJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUMnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQwJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQxJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUInOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQyJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTUnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQzJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTgnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQ0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxRic6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDUnO1xuICAgICAgICBjYXNlICdcXHVFMDIwJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1QSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDYnO1xuICAgICAgICBjYXNlICdcXHVFMDIxJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Nyc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDcnO1xuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDgnO1xuICAgICAgICBjYXNlICdcXHVFMDIzJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1NCc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDknO1xuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgICAgIHJldHVybiAnTnVtcGFkQWRkJztcbiAgICAgICAgY2FzZSAnXFx1RTAyNic6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZENvbW1hJztcbiAgICAgICAgY2FzZSAnXFx1RTAyOCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUQnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWREZWNpbWFsJztcbiAgICAgICAgY2FzZSAnXFx1RTAyOSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZERpdmlkZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDcnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRFbnRlcic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjQnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRNdWx0aXBseSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjcnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRTdWJ0cmFjdCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUga2V5IGFjY29yZGluZyB0byB0aGUgdGFibGU6XG4gKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4ta2V5LWxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEtleUxvY2F0aW9uKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDcnOlxuICAgICAgICBjYXNlICdcXHVFMDA4JzpcbiAgICAgICAgY2FzZSAnXFx1RTAwOSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMEEnOlxuICAgICAgICBjYXNlICdcXHVFMDNEJzpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlICdcXHVFMDE5JzpcbiAgICAgICAgY2FzZSAnXFx1RTAxQSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMUInOlxuICAgICAgICBjYXNlICdcXHVFMDFDJzpcbiAgICAgICAgY2FzZSAnXFx1RTAxRCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMUUnOlxuICAgICAgICBjYXNlICdcXHVFMDFGJzpcbiAgICAgICAgY2FzZSAnXFx1RTAyMCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjEnOlxuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgY2FzZSAnXFx1RTAyMyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjQnOlxuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgY2FzZSAnXFx1RTAyNic6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjcnOlxuICAgICAgICBjYXNlICdcXHVFMDI4JzpcbiAgICAgICAgY2FzZSAnXFx1RTAyOSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTQnOlxuICAgICAgICBjYXNlICdcXHVFMDU1JzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Nic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTcnOlxuICAgICAgICBjYXNlICdcXHVFMDU4JzpcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUEnOlxuICAgICAgICBjYXNlICdcXHVFMDVCJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Qyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUQnOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTAnOlxuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Mic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTMnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlVdGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCBsb2dIZWxwZXJfanNfMSA9IHJlcXVpcmUoXCIuL2xvZ0hlbHBlci5qc1wiKTtcbi8qKiBDb252ZXJ0cyBDRFAgU3RhY2tUcmFjZSBvYmplY3QgdG8gQmlEaSBTdGFja1RyYWNlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGdldEJpZGlTdGFja1RyYWNlKGNkcFN0YWNrVHJhY2UpIHtcbiAgICBjb25zdCBzdGFja0ZyYW1lcyA9IGNkcFN0YWNrVHJhY2U/LmNhbGxGcmFtZXMubWFwKChjYWxsRnJhbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY2FsbEZyYW1lLmNvbHVtbk51bWJlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY2FsbEZyYW1lLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGNhbGxGcmFtZS5saW5lTnVtYmVyLFxuICAgICAgICAgICAgdXJsOiBjYWxsRnJhbWUudXJsLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBzdGFja0ZyYW1lcyA/IHsgY2FsbEZyYW1lczogc3RhY2tGcmFtZXMgfSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldExvZ0xldmVsKGNvbnNvbGVBcGlUeXBlKSB7XG4gICAgaWYgKFtcImVycm9yXCIgLyogTG9nLkxldmVsLkVycm9yICovLCAnYXNzZXJ0J10uaW5jbHVkZXMoY29uc29sZUFwaVR5cGUpKSB7XG4gICAgICAgIHJldHVybiBcImVycm9yXCIgLyogTG9nLkxldmVsLkVycm9yICovO1xuICAgIH1cbiAgICBpZiAoW1wiZGVidWdcIiAvKiBMb2cuTGV2ZWwuRGVidWcgKi8sICd0cmFjZSddLmluY2x1ZGVzKGNvbnNvbGVBcGlUeXBlKSkge1xuICAgICAgICByZXR1cm4gXCJkZWJ1Z1wiIC8qIExvZy5MZXZlbC5EZWJ1ZyAqLztcbiAgICB9XG4gICAgaWYgKFtcIndhcm5cIiAvKiBMb2cuTGV2ZWwuV2FybiAqLywgJ3dhcm5pbmcnXS5pbmNsdWRlcyhjb25zb2xlQXBpVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwid2FyblwiIC8qIExvZy5MZXZlbC5XYXJuICovO1xuICAgIH1cbiAgICByZXR1cm4gXCJpbmZvXCIgLyogTG9nLkxldmVsLkluZm8gKi87XG59XG5jbGFzcyBMb2dNYW5hZ2VyIHtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNyZWFsbVN0b3JhZ2U7XG4gICAgI2NkcFRhcmdldDtcbiAgICAjbG9nZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGNkcFRhcmdldCwgcmVhbG1TdG9yYWdlLCBldmVudE1hbmFnZXIsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQgPSBjZHBUYXJnZXQ7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZSA9IHJlYWxtU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY2RwVGFyZ2V0LCByZWFsbVN0b3JhZ2UsIGV2ZW50TWFuYWdlciwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGxvZ01hbmFnZXIgPSBuZXcgTG9nTWFuYWdlcihjZHBUYXJnZXQsIHJlYWxtU3RvcmFnZSwgZXZlbnRNYW5hZ2VyLCBsb2dnZXIpO1xuICAgICAgICBsb2dNYW5hZ2VyLiNpbml0aWFsaXplRW50cnlBZGRlZEV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgcmV0dXJuIGxvZ01hbmFnZXI7XG4gICAgfVxuICAgICNpbml0aWFsaXplRW50cnlBZGRlZEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1J1bnRpbWUuY29uc29sZUFQSUNhbGxlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHJlYWxtIGJ5IGBjZHBTZXNzaW9uSWRgIGFuZCBgZXhlY3V0aW9uQ29udGV4dElkYCxcbiAgICAgICAgICAgIC8vIGlmIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3QgcmVhbG0gPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtKHtcbiAgICAgICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IHRoaXMuI2NkcFRhcmdldC5jZHBTZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiBwYXJhbXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIG5vdCBhdHRhY2hlZCB0byBhbnkgcmVhbG0uXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5jZHAsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJnc1Byb21pc2UgPSByZWFsbSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUocGFyYW1zLmFyZ3MpXG4gICAgICAgICAgICAgICAgOiAvLyBQcm9wZXJseSBzZXJpYWxpemUgYXJndW1lbnRzIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwYXJhbXMuYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxtLnNlcmlhbGl6ZUNkcE9iamVjdChhcmcsIFwibm9uZVwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnJvd3NpbmdDb250ZXh0IG9mIHJlYWxtLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyUHJvbWlzZUV2ZW50KGFyZ3NQcm9taXNlLnRoZW4oKGFyZ3MpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzLkxvZ0VudHJ5QWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogZ2V0TG9nTGV2ZWwocGFyYW1zLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcmVhbG0uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICgwLCBsb2dIZWxwZXJfanNfMS5nZXRSZW1vdGVWYWx1ZXNUZXh0KShhcmdzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQocGFyYW1zLnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZTogZ2V0QmlkaVN0YWNrVHJhY2UocGFyYW1zLnN0YWNrVHJhY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb25zb2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zb2xlIG1ldGhvZCBpcyBgd2FybmAsIG5vdCBgd2FybmluZ2AuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJhbXMudHlwZSA9PT0gJ3dhcm5pbmcnID8gJ3dhcm4nIDogcGFyYW1zLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksIChlcnJvcikgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSkpLCBicm93c2luZ0NvbnRleHQuaWQsIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzLkxvZ0VudHJ5QWRkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGNlcHRpb25UaHJvd24nLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZmluZCByZWFsbSBieSBgY2RwU2Vzc2lvbklkYCBhbmQgYGV4ZWN1dGlvbkNvbnRleHRJZGAsXG4gICAgICAgICAgICAvLyBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jcmVhbG1TdG9yYWdlLmZpbmRSZWFsbSh7XG4gICAgICAgICAgICAgICAgY2RwU2Vzc2lvbklkOiB0aGlzLiNjZHBUYXJnZXQuY2RwU2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogcGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIG5vdCBhdHRhY2hlZCB0byBhbnkgcmVhbG0uXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5jZHAsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2luZ0NvbnRleHQgb2YgcmVhbG0uYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJQcm9taXNlRXZlbnQoTG9nTWFuYWdlci4jZ2V0RXhjZXB0aW9uVGV4dChwYXJhbXMsIHJlYWxtKS50aGVuKCh0ZXh0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Mb2cuRXZlbnROYW1lcy5Mb2dFbnRyeUFkZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIiAvKiBMb2cuTGV2ZWwuRXJyb3IgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZWFsbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQocGFyYW1zLnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZTogZ2V0QmlkaVN0YWNrVHJhY2UocGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuc3RhY2tUcmFjZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KSksIGJyb3dzaW5nQ29udGV4dC5pZCwgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTG9nLkV2ZW50TmFtZXMuTG9nRW50cnlBZGRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdGhlIGJlc3QgdG8gZ2V0IHRoZSBleGNlcHRpb24gdGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgI2dldEV4Y2VwdGlvblRleHQocGFyYW1zLCByZWFsbSkge1xuICAgICAgICBpZiAoIXBhcmFtcy5leGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5leGNlcHRpb25EZXRhaWxzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWxtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMuZXhjZXB0aW9uRGV0YWlscy5leGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFsbS5zdHJpbmdpZnlPYmplY3QocGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuZXhjZXB0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ01hbmFnZXIgPSBMb2dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2dNZXNzYWdlRm9ybWF0dGVyID0gbG9nTWVzc2FnZUZvcm1hdHRlcjtcbmV4cG9ydHMuZ2V0UmVtb3RlVmFsdWVzVGV4dCA9IGdldFJlbW90ZVZhbHVlc1RleHQ7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBzcGVjaWZpZXJzID0gWyclcycsICclZCcsICclaScsICclZicsICclbycsICclTycsICclYyddO1xuZnVuY3Rpb24gaXNGb3JtYXRTcGVjaWZpZXIoc3RyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllcnMuc29tZSgoc3BlYykgPT4gc3RyLmluY2x1ZGVzKHNwZWMpKTtcbn1cbi8qKlxuICogQHBhcmFtIGFyZ3MgaW5wdXQgcmVtb3RlIHZhbHVlcyB0byBiZSBmb3JtYXQgcHJpbnRlZFxuICogQHJldHVybiBwYXJzZWQgdGV4dCBvZiB0aGUgcmVtb3RlIHZhbHVlcyBpbiBzcGVjaWZpYyBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbG9nTWVzc2FnZUZvcm1hdHRlcihhcmdzKSB7XG4gICAgbGV0IG91dHB1dCA9ICcnO1xuICAgIGNvbnN0IGFyZ0Zvcm1hdCA9IGFyZ3NbMF0udmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBhcmdWYWx1ZXMgPSBhcmdzLnNsaWNlKDEsIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdG9rZW5zID0gYXJnRm9ybWF0LnNwbGl0KG5ldyBSZWdFeHAoc3BlY2lmaWVycy5tYXAoKHNwZWMpID0+IGAoJHtzcGVjfSlgKS5qb2luKCd8JyksICdnJykpO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSAnJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9ybWF0U3BlY2lmaWVyKHRva2VuKSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnVmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAvLyByYWlzZSBhbiBleGNlcHRpb24gd2hlbiBsZXNzIHZhbHVlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShhcmcsIGBMZXNzIHZhbHVlIGlzIHByb3ZpZGVkOiBcIiR7Z2V0UmVtb3RlVmFsdWVzVGV4dChhcmdzLCBmYWxzZSl9XCJgKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJyVzJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJyVkJyB8fCB0b2tlbiA9PT0gJyVpJykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyZy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gcGFyc2VJbnQoYXJnLnZhbHVlLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnTmFOJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJyVmJykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyZy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gcGFyc2VGbG9hdChhcmcudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ05hTic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gJW8sICVPLCAlY1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b0pzb24oYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByYWlzZSBhbiBleGNlcHRpb24gd2hlbiBtb3JlIHZhbHVlIGlzIHByb3ZpZGVkXG4gICAgaWYgKGFyZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9yZSB2YWx1ZSBpcyBwcm92aWRlZDogXCIke2dldFJlbW90ZVZhbHVlc1RleHQoYXJncywgZmFsc2UpfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIEBwYXJhbSBhcmcgaW5wdXQgcmVtb3RlIHZhbHVlIHRvIGJlIHBhcnNlZFxuICogQHJldHVybiBwYXJzZWQgdGV4dCBvZiB0aGUgcmVtb3RlIHZhbHVlXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJudW1iZXJcIiwgXCJ2YWx1ZVwiOiAxfVxuICogb3V0cHV0OiAxXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcImFiY1wifVxuICogb3V0cHV0OiBcImFiY1wiXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgIFwidmFsdWVcIjogW1tcImlkXCIsIHtcInR5cGVcIjogXCJudW1iZXJcIiwgXCJ2YWx1ZVwiOiAxfV1dfVxuICogb3V0cHV0OiAne1wiaWRcIjogMX0nXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJ2YWx1ZVwiOiBbW1wiZm9udC1zaXplXCIsIHtcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcIjIwcHhcIn1dXX1cbiAqIG91dHB1dDogJ3tcImZvbnQtc2l6ZVwiOiBcIjIwcHhcIn0nXG4gKi9cbmZ1bmN0aW9uIHRvSnNvbihhcmcpIHtcbiAgICAvLyBhcmcgdHlwZSB2YWxpZGF0aW9uXG4gICAgaWYgKGFyZy50eXBlICE9PSAnYXJyYXknICYmXG4gICAgICAgIGFyZy50eXBlICE9PSAnYmlnaW50JyAmJlxuICAgICAgICBhcmcudHlwZSAhPT0gJ2RhdGUnICYmXG4gICAgICAgIGFyZy50eXBlICE9PSAnbnVtYmVyJyAmJlxuICAgICAgICBhcmcudHlwZSAhPT0gJ29iamVjdCcgJiZcbiAgICAgICAgYXJnLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGAke2FyZy52YWx1ZS50b1N0cmluZygpfW5gO1xuICAgIH1cbiAgICBpZiAoYXJnLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhcmcudmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKFsnZGF0ZScsICdzdHJpbmcnXS5pbmNsdWRlcyhhcmcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZy52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGB7JHthcmcudmFsdWVcbiAgICAgICAgICAgIC5tYXAoKHBhaXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeShwYWlyWzBdKX06JHt0b0pzb24ocGFpclsxXSl9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyl9fWA7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gYFske2FyZy52YWx1ZT8ubWFwKCh2YWwpID0+IHRvSnNvbih2YWwpKS5qb2luKCcsJykgPz8gJyd9XWA7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICB0aHJvdyBFcnJvcihgSW52YWxpZCB2YWx1ZSB0eXBlOiAke2FyZ31gKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0Zyb21BcmcoYXJnKSB7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKGFyZywgJ3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGFyZy50eXBlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcudmFsdWUpO1xuICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgICAgcmV0dXJuIGAvJHthcmcudmFsdWUucGF0dGVybn0vJHthcmcudmFsdWUuZmxhZ3MgPz8gJyd9YDtcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYXJnLnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgcmV0dXJuIGBPYmplY3QoJHthcmcudmFsdWU/Lmxlbmd0aCA/PyAnJ30pYDtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIGBBcnJheSgke2FyZy52YWx1ZT8ubGVuZ3RoID8/ICcnfSlgO1xuICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgcmV0dXJuIGBNYXAoJHthcmcudmFsdWU/Lmxlbmd0aH0pYDtcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIHJldHVybiBgU2V0KCR7YXJnLnZhbHVlPy5sZW5ndGh9KWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYXJnLnR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmVtb3RlVmFsdWVzVGV4dChhcmdzLCBmb3JtYXRUZXh0KSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1swXTtcbiAgICBpZiAoIWFyZykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIGlmIGFyZ3NbMF0gaXMgYSBmb3JtYXQgc3BlY2lmaWVyLCBmb3JtYXQgdGhlIGFyZ3MgYXMgb3V0cHV0XG4gICAgaWYgKGFyZy50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBpc0Zvcm1hdFNwZWNpZmllcihhcmcudmFsdWUudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgZm9ybWF0VGV4dCkge1xuICAgICAgICByZXR1cm4gbG9nTWVzc2FnZUZvcm1hdHRlcihhcmdzKTtcbiAgICB9XG4gICAgLy8gaWYgYXJnc1swXSBpcyBub3QgYSBmb3JtYXQgc3BlY2lmaWVyLCBqdXN0IGpvaW4gdGhlIGFyZ3Mgd2l0aCBcXHUwMDIwICh1bmljb2RlICdTUEFDRScpXG4gICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgLm1hcCgoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcdTAwMjAnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ0hlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IFVybFBhdHRlcm5fanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9VcmxQYXR0ZXJuLmpzXCIpO1xuLyoqIERpc3BhdGNoZXMgTmV0d29yayBkb21haW4gY29tbWFuZHMuICovXG5jbGFzcyBOZXR3b3JrUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjbmV0d29ya1N0b3JhZ2U7XG4gICAgY29uc3RydWN0b3IoYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbmV0d29ya1N0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI25ldHdvcmtTdG9yYWdlID0gbmV0d29ya1N0b3JhZ2U7XG4gICAgfVxuICAgIGFzeW5jIGFkZEludGVyY2VwdChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS52ZXJpZnlUb3BMZXZlbENvbnRleHRzTGlzdChwYXJhbXMuY29udGV4dHMpO1xuICAgICAgICBjb25zdCB1cmxQYXR0ZXJucyA9IHBhcmFtcy51cmxQYXR0ZXJucyA/PyBbXTtcbiAgICAgICAgY29uc3QgcGFyc2VkVXJsUGF0dGVybnMgPSBOZXR3b3JrUHJvY2Vzc29yLnBhcnNlVXJsUGF0dGVybnModXJsUGF0dGVybnMpO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHQgPSB0aGlzLiNuZXR3b3JrU3RvcmFnZS5hZGRJbnRlcmNlcHQoe1xuICAgICAgICAgICAgdXJsUGF0dGVybnM6IHBhcnNlZFVybFBhdHRlcm5zLFxuICAgICAgICAgICAgcGhhc2VzOiBwYXJhbXMucGhhc2VzLFxuICAgICAgICAgICAgY29udGV4dHM6IHBhcmFtcy5jb250ZXh0cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0QWxsQ29udGV4dHMoKS5tYXAoKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNkcFRhcmdldC50b2dnbGVGZXRjaElmTmVlZGVkKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyY2VwdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY29udGludWVSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnBhcnNlVXJsU3RyaW5nKHBhcmFtcy51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghTmV0d29ya1Byb2Nlc3Nvci5pc01ldGhvZFZhbGlkKHBhcmFtcy5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBNZXRob2QgJyR7cGFyYW1zLm1ldGhvZH0nIGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnZhbGlkYXRlSGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuI2dldEJsb2NrZWRSZXF1ZXN0T3JGYWlsKHBhcmFtcy5yZXF1ZXN0LCBbXG4gICAgICAgICAgICBcImJlZm9yZVJlcXVlc3RTZW50XCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5CZWZvcmVSZXF1ZXN0U2VudCAqLyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LmNvbnRpbnVlUmVxdWVzdChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgTmV0d29ya1Byb2Nlc3Nvci53cmFwSW50ZXJjZXB0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgY29udGludWVSZXNwb25zZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnZhbGlkYXRlSGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuI2dldEJsb2NrZWRSZXF1ZXN0T3JGYWlsKHBhcmFtcy5yZXF1ZXN0LCBbXG4gICAgICAgICAgICBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovLFxuICAgICAgICAgICAgXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LmNvbnRpbnVlUmVzcG9uc2UocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE5ldHdvcmtQcm9jZXNzb3Iud3JhcEludGVyY2VwdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIGNvbnRpbnVlV2l0aEF1dGgocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IHBhcmFtcy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jZ2V0QmxvY2tlZFJlcXVlc3RPckZhaWwobmV0d29ya0lkLCBbXG4gICAgICAgICAgICBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovLFxuICAgICAgICBdKTtcbiAgICAgICAgYXdhaXQgcmVxdWVzdC5jb250aW51ZVdpdGhBdXRoKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgZmFpbFJlcXVlc3QoeyByZXF1ZXN0OiBuZXR3b3JrSWQsIH0pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuI2dldFJlcXVlc3RPckZhaWwobmV0d29ya0lkKTtcbiAgICAgICAgaWYgKHJlcXVlc3QuaW50ZXJjZXB0UGhhc2UgPT09IFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgUmVxdWVzdCAnJHtuZXR3b3JrSWR9JyBpbiAnYXV0aFJlcXVpcmVkJyBwaGFzZSBjYW5ub3QgYmUgZmFpbGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXF1ZXN0LmludGVyY2VwdFBoYXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hSZXF1ZXN0RXhjZXB0aW9uKGBObyBibG9ja2VkIHJlcXVlc3QgZm91bmQgZm9yIG5ldHdvcmsgaWQgJyR7bmV0d29ya0lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXF1ZXN0LmZhaWxSZXF1ZXN0KCdGYWlsZWQnKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBwcm92aWRlUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICAgICAgTmV0d29ya1Byb2Nlc3Nvci52YWxpZGF0ZUhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLiNnZXRCbG9ja2VkUmVxdWVzdE9yRmFpbChwYXJhbXMucmVxdWVzdCwgW1xuICAgICAgICAgICAgXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi8sXG4gICAgICAgICAgICBcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovLFxuICAgICAgICAgICAgXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LnByb3ZpZGVSZXNwb25zZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgTmV0d29ya1Byb2Nlc3Nvci53cmFwSW50ZXJjZXB0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlSW50ZXJjZXB0KHBhcmFtcykge1xuICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZS5yZW1vdmVJbnRlcmNlcHQocGFyYW1zLmludGVyY2VwdCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0QWxsQ29udGV4dHMoKS5tYXAoKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNkcFRhcmdldC50b2dnbGVGZXRjaElmTmVlZGVkKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAjZ2V0UmVxdWVzdE9yRmFpbChpZCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jbmV0d29ya1N0b3JhZ2UuZ2V0UmVxdWVzdEJ5SWQoaWQpO1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFJlcXVlc3RFeGNlcHRpb24oYE5ldHdvcmsgcmVxdWVzdCB3aXRoIElEICcke2lkfScgZG9lc24ndCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAjZ2V0QmxvY2tlZFJlcXVlc3RPckZhaWwoaWQsIHBoYXNlcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jZ2V0UmVxdWVzdE9yRmFpbChpZCk7XG4gICAgICAgIGlmICghcmVxdWVzdC5pbnRlcmNlcHRQaGFzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoUmVxdWVzdEV4Y2VwdGlvbihgTm8gYmxvY2tlZCByZXF1ZXN0IGZvdW5kIGZvciBuZXR3b3JrIGlkICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5pbnRlcmNlcHRQaGFzZSAmJiAhcGhhc2VzLmluY2x1ZGVzKHJlcXVlc3QuaW50ZXJjZXB0UGhhc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEJsb2NrZWQgcmVxdWVzdCBmb3IgbmV0d29yayBpZCAnJHtpZH0nIGlzIGluICcke3JlcXVlc3QuaW50ZXJjZXB0UGhhc2V9JyBwaGFzZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLXZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIudmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZSA9IGhlYWRlci52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlclZhbHVlID0gYXRvYihoZWFkZXIudmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlclZhbHVlICE9PSBoZWFkZXJWYWx1ZS50cmltKCkgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZS5pbmNsdWRlcygnXFxuJykgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZS5pbmNsdWRlcygnXFwwJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEhlYWRlciB2YWx1ZSAnJHtoZWFkZXJWYWx1ZX0nIGlzIG5vdCBhY2NlcHRhYmxlIHZhbHVlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzTWV0aG9kVmFsaWQobWV0aG9kKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjbWV0aG9kLm92ZXJ2aWV3XG4gICAgICAgIHJldHVybiAvXlshIyQlJicqK1xcLS5eX2B8fmEtekEtWlxcZF0rJC8udGVzdChtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSB0aGUgZ2l2ZW4gdXJsLlxuICAgICAqIFRocm93cyBhbiBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gaWYgdGhlIHVybCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVVybFN0cmluZyh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgVVJMICcke3VybH0nOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVVybFBhdHRlcm5zKHVybFBhdHRlcm5zKSB7XG4gICAgICAgIHJldHVybiB1cmxQYXR0ZXJucy5tYXAoKHVybFBhdHRlcm4pID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodXJsUGF0dGVybi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnBhcnNlVXJsU3RyaW5nKHVybFBhdHRlcm4ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdwYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcGFyYW1zIHNpZ25pZmllcyBpbnRlcmNlcHQgYWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxQYXR0ZXJuLnByb3RvY29sID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wb3J0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5zZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybFBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucHJvdG9jb2wgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5wcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybFBhdHRlcm4ucHJvdG9jb2wubWF0Y2goL15bYS16QS1aKy0uXSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0ZvcmJpZGRlbiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4uaG9zdG5hbWUgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5ob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wb3J0ID0gdW5lc2NhcGVVUkxQYXR0ZXJuKHVybFBhdHRlcm4ucG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucGF0aG5hbWUgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wYXRobmFtZVswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wYXRobmFtZSA9IGAvJHt1cmxQYXR0ZXJuLnBhdGhuYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wYXRobmFtZS5pbmNsdWRlcygnIycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wYXRobmFtZS5pbmNsdWRlcygnPycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdGb3JiaWRkZW4gY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFBhdHRlcm4ucGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxQYXR0ZXJuLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5zZWFyY2ggPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5zZWFyY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uc2VhcmNoWzBdICE9PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLnNlYXJjaCA9IGA/JHt1cmxQYXR0ZXJuLnNlYXJjaH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uc2VhcmNoLmluY2x1ZGVzKCcjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0ZvcmJpZGRlbiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucHJvdG9jb2wgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYFVSTCBwYXR0ZXJuIG11c3Qgc3BlY2lmeSBhIHByb3RvY29sYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uaG9zdG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYFVSTCBwYXR0ZXJuIG11c3Qgc3BlY2lmeSBhIGhvc3RuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1cmxQYXR0ZXJuLmhvc3RuYW1lPy5sZW5ndGggPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wcm90b2NvbD8ubWF0Y2goL15maWxlL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBVUkwgcGF0dGVybiBwcm90b2NvbCBjYW5ub3QgYmUgJ2ZpbGUnYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5ob3N0bmFtZT8uaW5jbHVkZXMoJzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVVJMIHBhdHRlcm4gaG9zdG5hbWUgbXVzdCBub3QgY29udGFpbiBhIGNvbG9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucG9ydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVVJMIHBhdHRlcm4gbXVzdCBzcGVjaWZ5IGEgcG9ydGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVXJsUGF0dGVybl9qc18xLlVSTFBhdHRlcm4odXJsUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYCR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybFBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgd3JhcEludGVyY2VwdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOmNvbnRlbnQvYnJvd3Nlci9kZXZ0b29scy9wcm90b2NvbC9mZXRjaF9oYW5kbGVyLmNjO2w9MTY5XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCBoZWFkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBoZWFkZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrUHJvY2Vzc29yID0gTmV0d29ya1Byb2Nlc3Nvcjtcbi8qKlxuICogU2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jdW5lc2NhcGUtdXJsLXBhdHRlcm5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGVVUkxQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICBjb25zdCBmb3JiaWRkZW4gPSBuZXcgU2V0KFsnKCcsICcpJywgJyonLCAneycsICd9J10pO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjIG9mIHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCFpc0VzY2FwZWQpIHtcbiAgICAgICAgICAgIGlmIChmb3JiaWRkZW4uaGFzKGMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdGb3JiaWRkZW4gY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlzRXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgIGlzRXNjYXBlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya1Byb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBEZWZlcnJlZF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL0RlZmVycmVkLmpzXCIpO1xuY29uc3QgbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvbG9nLmpzXCIpO1xuY29uc3QgTmV0d29ya1V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrVXRpbHMuanNcIik7XG5jb25zdCBSRUFMTV9SRUdFWCA9IC8oPzw9cmVhbG09XCIpLiooPz1cIikvO1xuLyoqIEFic3RyYWN0cyBvbmUgaW5kaXZpZHVhbCBuZXR3b3JrIHJlcXVlc3QuICovXG5jbGFzcyBOZXR3b3JrUmVxdWVzdCB7XG4gICAgc3RhdGljIHVua25vd25QYXJhbWV0ZXIgPSAnVU5LTk9XTic7XG4gICAgLyoqXG4gICAgICogRWFjaCBuZXR3b3JrIHJlcXVlc3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVxdWVzdCBpZCwgd2hpY2ggaXMgYSBzdHJpbmdcbiAgICAgKiB1bmlxdWVseSBpZGVudGlmeWluZyB0aGF0IHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBUaGUgaWRlbnRpZmllciBmb3IgYSByZXF1ZXN0IHJlc3VsdGluZyBmcm9tIGEgcmVkaXJlY3QgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICAgICAqIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgaXQuXG4gICAgICovXG4gICAgI2lkO1xuICAgICNmZXRjaElkO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbmV0d29yayBpbnRlcmNlcHQgcGhhc2UsIGlmIHRoZSByZXF1ZXN0IGlzIGN1cnJlbnRseSBibG9ja2VkLlxuICAgICAqIFVuZGVmaW5lZCBuZWNlc3NhcmlseSBpbXBsaWVzIHRoYXQgdGhlIHJlcXVlc3QgaXMgbm90IGJsb2NrZWQuXG4gICAgICovXG4gICAgI2ludGVyY2VwdFBoYXNlO1xuICAgICNzZXJ2ZWRGcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAjcmVkaXJlY3RDb3VudDtcbiAgICAjcmVxdWVzdCA9IHt9O1xuICAgICNyZXF1ZXN0T3ZlcnJpZGVzO1xuICAgICNyZXNwb25zZSA9IHt9O1xuICAgICNldmVudE1hbmFnZXI7XG4gICAgI25ldHdvcmtTdG9yYWdlO1xuICAgICNjZHBUYXJnZXQ7XG4gICAgI2xvZ2dlcjtcbiAgICAjZW1pdHRlZEV2ZW50cyA9IHtcbiAgICAgICAgW3Byb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5BdXRoUmVxdWlyZWRdOiBmYWxzZSxcbiAgICAgICAgW3Byb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5CZWZvcmVSZXF1ZXN0U2VudF06IGZhbHNlLFxuICAgICAgICBbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLkZldGNoRXJyb3JdOiBmYWxzZSxcbiAgICAgICAgW3Byb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5SZXNwb25zZUNvbXBsZXRlZF06IGZhbHNlLFxuICAgICAgICBbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLlJlc3BvbnNlU3RhcnRlZF06IGZhbHNlLFxuICAgIH07XG4gICAgd2FpdE5leHRQaGFzZSA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgY29uc3RydWN0b3IoaWQsIGV2ZW50TWFuYWdlciwgbmV0d29ya1N0b3JhZ2UsIGNkcFRhcmdldCwgcmVkaXJlY3RDb3VudCA9IDAsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNpZCA9IGlkO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI25ldHdvcmtTdG9yYWdlID0gbmV0d29ya1N0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldCA9IGNkcFRhcmdldDtcbiAgICAgICAgdGhpcy4jcmVkaXJlY3RDb3VudCA9IHJlZGlyZWN0Q291bnQ7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaWQ7XG4gICAgfVxuICAgIGdldCBmZXRjaElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmV0Y2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBibG9ja2VkIHJldHVybnMgdGhlIHBoYXNlIGZvciBpdFxuICAgICAqL1xuICAgIGdldCBpbnRlcmNlcHRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVyY2VwdFBoYXNlO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI3JlcXVlc3QuaW5mbz8ucmVxdWVzdC51cmxGcmFnbWVudCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQ/LnJlcXVlc3QudXJsRnJhZ21lbnQgPz9cbiAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLiNyZXNwb25zZS5pbmZvPy51cmwgPz9cbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZD8ucmVxdWVzdC51cmwgPz9cbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3RPdmVycmlkZXM/LnVybCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5hdXRoPy5yZXF1ZXN0LnVybCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5pbmZvPy5yZXF1ZXN0LnVybCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQ/LnJlcXVlc3QudXJsID8/XG4gICAgICAgICAgICBOZXR3b3JrUmVxdWVzdC51bmtub3duUGFyYW1ldGVyO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7ZnJhZ21lbnR9YDtcbiAgICB9XG4gICAgZ2V0IHJlZGlyZWN0Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWRpcmVjdENvdW50O1xuICAgIH1cbiAgICBnZXQgY2RwVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2RwVGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgY2RwQ2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudDtcbiAgICB9XG4gICAgaXNSZWRpcmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy4jcmVxdWVzdC5pbmZvKTtcbiAgICB9XG4gICAgI2lzRGF0YVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2RhdGE6Jyk7XG4gICAgfVxuICAgIGdldCAjbWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3JlcXVlc3RPdmVycmlkZXM/Lm1ldGhvZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5pbmZvPy5yZXF1ZXN0Lm1ldGhvZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQ/LnJlcXVlc3QubWV0aG9kID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmF1dGg/LnJlcXVlc3QubWV0aG9kID8/XG4gICAgICAgICAgICB0aGlzLiNyZXNwb25zZS5wYXVzZWQ/LnJlcXVlc3QubWV0aG9kKTtcbiAgICB9XG4gICAgZ2V0ICNuYXZpZ2F0aW9uSWQoKSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhIG5hdmlnYXRpb24gcmVxdWVzdCwgYW5kIGlmIG5vdCByZXR1cm4gbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLiNyZXF1ZXN0LmluZm8gfHxcbiAgICAgICAgICAgICF0aGlzLiNyZXF1ZXN0LmluZm8ubG9hZGVySWQgfHxcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgbmF2aWdhdGUgYWxsIENEUCBuZXR3b3JrIGV2ZW50cyBoYXZlIGBsb2FkZXJJZGBcbiAgICAgICAgICAgIC8vIENEUCdzIGBsb2FkZXJJZGAgYW5kIGByZXF1ZXN0SWRgIG1hdGNoIHdoZW5cbiAgICAgICAgICAgIC8vIHRoYXQgcmVxdWVzdCB0cmlnZ2VyZWQgdGhlIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuaW5mby5sb2FkZXJJZCAhPT0gdGhpcy4jcmVxdWVzdC5pbmZvLnJlcXVlc3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHZpcnR1YWwgbmF2aWdhdGlvbiBJRCBmcm9tIHRoZSBicm93c2luZyBjb250ZXh0LlxuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29ya1N0b3JhZ2UuZ2V0VmlydHVhbE5hdmlnYXRpb25JZCh0aGlzLiNjb250ZXh0ID8/IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldCAjY29va2llcygpIHtcbiAgICAgICAgbGV0IGNvb2tpZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvKSB7XG4gICAgICAgICAgICBjb29raWVzID0gdGhpcy4jcmVxdWVzdC5leHRyYUluZm8uYXNzb2NpYXRlZENvb2tpZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IGJsb2NrZWRSZWFzb25zIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoYmxvY2tlZFJlYXNvbnMpIHx8IGJsb2NrZWRSZWFzb25zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcCgoeyBjb29raWUgfSkgPT4gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcFRvQmlEaUNvb2tpZSkoY29va2llKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgfVxuICAgIGdldCAjYm9keVNpemUoKSB7XG4gICAgICAgIGxldCBib2R5U2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcmVxdWVzdE92ZXJyaWRlcz8uYm9keVNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBib2R5U2l6ZSA9IHRoaXMuI3JlcXVlc3RPdmVycmlkZXMuYm9keVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5U2l6ZSA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpQm9keVNpemVGcm9tQ2RwUG9zdERhdGFFbnRyaWVzKSh0aGlzLiNyZXF1ZXN0LmluZm8/LnJlcXVlc3QucG9zdERhdGFFbnRyaWVzID8/IFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keVNpemU7XG4gICAgfVxuICAgIGdldCAjY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNyZXNwb25zZS5wYXVzZWQ/LmZyYW1lSWQgPz9cbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuaW5mbz8uZnJhbWVJZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQ/LmZyYW1lSWQgPz9cbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuYXV0aD8uZnJhbWVJZCA/P1xuICAgICAgICAgICAgbnVsbCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBIVFRQIHN0YXR1cyBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3QgaWYgYW55LiAqL1xuICAgIGdldCAjc3RhdHVzQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNyZXNwb25zZS5wYXVzZWQ/LnJlc3BvbnNlU3RhdHVzQ29kZSA/P1xuICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UuZXh0cmFJbmZvPy5zdGF0dXNDb2RlID8/XG4gICAgICAgICAgICB0aGlzLiNyZXNwb25zZS5pbmZvPy5zdGF0dXMpO1xuICAgIH1cbiAgICBnZXQgI3JlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBsZXQgaGVhZGVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy4jcmVxdWVzdE92ZXJyaWRlcz8uaGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVycyA9IHRoaXMuI3JlcXVlc3RPdmVycmlkZXMuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uKDAsIE5ldHdvcmtVdGlsc19qc18xLmJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVycykodGhpcy4jcmVxdWVzdC5pbmZvPy5yZXF1ZXN0LmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIC4uLigwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnMpKHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvPy5oZWFkZXJzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGdldCAjYXV0aENoYWxsZW5nZXMoKSB7XG4gICAgICAgIC8vIFRPRE86IGdldCBoZWFkZXJzIGZyb20gRmV0Y2gucmVxdWVzdFBhdXNlZFxuICAgICAgICBpZiAoIXRoaXMuI3Jlc3BvbnNlLmluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLiNzdGF0dXNDb2RlID09PSA0MDEgfHwgdGhpcy4jc3RhdHVzQ29kZSA9PT0gNDA3KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJOYW1lID0gdGhpcy4jc3RhdHVzQ29kZSA9PT0gNDAxID8gJ1dXVy1BdXRoZW50aWNhdGUnIDogJ1Byb3h5LUF1dGhlbnRpY2F0ZSc7XG4gICAgICAgIGNvbnN0IGF1dGhDaGFsbGVuZ2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2hlYWRlciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuI3Jlc3BvbnNlLmluZm8uaGVhZGVycykpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IERvIGEgcHJvcGVyIG1hdGNoIGJhc2VkIG9uIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjY3JlZGVudGlhbHNcbiAgICAgICAgICAgIC8vIE9yIHZlcmlmeSB0aGlzIHdvcmtzXG4gICAgICAgICAgICBpZiAoaGVhZGVyLmxvY2FsZUNvbXBhcmUoaGVhZGVyTmFtZSwgdW5kZWZpbmVkLCB7IHNlbnNpdGl2aXR5OiAnYmFzZScgfSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhdXRoQ2hhbGxlbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lOiB2YWx1ZS5zcGxpdCgnICcpLmF0KDApID8/ICcnLFxuICAgICAgICAgICAgICAgICAgICByZWFsbTogdmFsdWUubWF0Y2goUkVBTE1fUkVHRVgpPy5hdCgwKSA/PyAnJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aENoYWxsZW5nZXM7XG4gICAgfVxuICAgIGdldCAjdGltaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFZlcmlmeSB0aGlzIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHRpbWVPcmlnaW46ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5nZXRUaW1pbmcpKHRoaXMuI3Jlc3BvbnNlLmluZm8/LnRpbWluZz8ucmVxdWVzdFRpbWUpLFxuICAgICAgICAgICAgcmVxdWVzdFRpbWU6ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5nZXRUaW1pbmcpKHRoaXMuI3Jlc3BvbnNlLmluZm8/LnRpbWluZz8ucmVxdWVzdFRpbWUpLFxuICAgICAgICAgICAgcmVkaXJlY3RTdGFydDogMCxcbiAgICAgICAgICAgIHJlZGlyZWN0RW5kOiAwLFxuICAgICAgICAgICAgLy8gVE9ETzogVmVyaWZ5IHRoaXMgaXMgY29ycmVjdFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46bmV0L2Jhc2UvbG9hZF90aW1pbmdfaW5mby5oO2w9MTQ1XG4gICAgICAgICAgICBmZXRjaFN0YXJ0OiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXNwb25zZS5pbmZvPy50aW1pbmc/LnJlcXVlc3RUaW1lKSxcbiAgICAgICAgICAgIGRuc1N0YXJ0OiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXNwb25zZS5pbmZvPy50aW1pbmc/LmRuc1N0YXJ0KSxcbiAgICAgICAgICAgIGRuc0VuZDogKDAsIE5ldHdvcmtVdGlsc19qc18xLmdldFRpbWluZykodGhpcy4jcmVzcG9uc2UuaW5mbz8udGltaW5nPy5kbnNFbmQpLFxuICAgICAgICAgICAgY29ubmVjdFN0YXJ0OiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXNwb25zZS5pbmZvPy50aW1pbmc/LmNvbm5lY3RTdGFydCksXG4gICAgICAgICAgICBjb25uZWN0RW5kOiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXNwb25zZS5pbmZvPy50aW1pbmc/LmNvbm5lY3RFbmQpLFxuICAgICAgICAgICAgdGxzU3RhcnQ6ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5nZXRUaW1pbmcpKHRoaXMuI3Jlc3BvbnNlLmluZm8/LnRpbWluZz8uc3NsU3RhcnQpLFxuICAgICAgICAgICAgcmVxdWVzdFN0YXJ0OiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXNwb25zZS5pbmZvPy50aW1pbmc/LnNlbmRTdGFydCksXG4gICAgICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjpuZXQvYmFzZS9sb2FkX3RpbWluZ19pbmZvLmg7bD0xOTZcbiAgICAgICAgICAgIHJlc3BvbnNlU3RhcnQ6ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5nZXRUaW1pbmcpKHRoaXMuI3Jlc3BvbnNlLmluZm8/LnRpbWluZz8ucmVjZWl2ZUhlYWRlcnNTdGFydCksXG4gICAgICAgICAgICByZXNwb25zZUVuZDogKDAsIE5ldHdvcmtVdGlsc19qc18xLmdldFRpbWluZykodGhpcy4jcmVzcG9uc2UuaW5mbz8udGltaW5nPy5yZWNlaXZlSGVhZGVyc0VuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgICNwaGFzZUNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMud2FpdE5leHRQaGFzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMud2FpdE5leHRQaGFzZSA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgfVxuICAgICNpbnRlcmNlcHRzSW5QaGFzZShwaGFzZSkge1xuICAgICAgICBpZiAoIXRoaXMuI2NkcFRhcmdldC5pc1N1YnNjcmliZWRUbyhgbmV0d29yay4ke3BoYXNlfWApKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrU3RvcmFnZS5nZXRJbnRlcmNlcHRzRm9yUGhhc2UodGhpcywgcGhhc2UpO1xuICAgIH1cbiAgICAjaXNCbG9ja2VkSW5QaGFzZShwaGFzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJjZXB0c0luUGhhc2UocGhhc2UpLnNpemUgPiAwO1xuICAgIH1cbiAgICBoYW5kbGVSZWRpcmVjdChldmVudCkge1xuICAgICAgICAvLyBUT0RPOiB1c2UgZXZlbnQucmVkaXJlY3RSZXNwb25zZTtcbiAgICAgICAgLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgdG8gZW1pdCBSZXNwb25zZUNvbXBsZXRlZCBldmVudCBmb3IgcmVkaXJlY3RzXG4gICAgICAgIHRoaXMuI3Jlc3BvbnNlLmhhc0V4dHJhSW5mbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNyZXNwb25zZS5pbmZvID0gZXZlbnQucmVkaXJlY3RSZXNwb25zZTtcbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50c0lmUmVhZHkoe1xuICAgICAgICAgICAgd2FzUmVkaXJlY3RlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNlbWl0RXZlbnRzSWZSZWFkeShvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEV4dHJhSW5mb0NvbXBsZXRlZCA9IFxuICAgICAgICAvLyBGbHVzaCByZWRpcmVjdHNcbiAgICAgICAgb3B0aW9ucy53YXNSZWRpcmVjdGVkIHx8XG4gICAgICAgICAgICBvcHRpb25zLmhhc0ZhaWxlZCB8fFxuICAgICAgICAgICAgdGhpcy4jaXNEYXRhVXJsKCkgfHxcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy4jcmVxdWVzdC5leHRyYUluZm8pIHx8XG4gICAgICAgICAgICAvLyBSZXF1ZXN0cyBmcm9tIGNhY2hlIGRvbid0IGhhdmUgZXh0cmEgaW5mb1xuICAgICAgICAgICAgdGhpcy4jc2VydmVkRnJvbUNhY2hlIHx8XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlcmUgaXMgbm8gZXh0cmEgaW5mbyBhbmQgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBpcyB0aGUgb25seSBwbGFjZSB3ZSBjYW4gZmluZCBvdXRcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy4jcmVzcG9uc2UuaW5mbyAmJiAhdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvKTtcbiAgICAgICAgY29uc3Qgbm9JbnRlcmNlcHRpb25FeHBlY3RlZCA9IFxuICAgICAgICAvLyBXZSBjYW4ndCBpbnRlcmNlcHQgZGF0YSB1cmxzIGZyb20gQ0RQXG4gICAgICAgIHRoaXMuI2lzRGF0YVVybCgpIHx8XG4gICAgICAgICAgICAvLyBDYWNoZWQgcmVxdWVzdHMgbmV2ZXIgaGl0IHRoZSBuZXR3b3JrXG4gICAgICAgICAgICB0aGlzLiNzZXJ2ZWRGcm9tQ2FjaGU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRpb25FeHBlY3RlZCA9ICFub0ludGVyY2VwdGlvbkV4cGVjdGVkICYmXG4gICAgICAgICAgICB0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEludGVyY2VwdGlvbkNvbXBsZXRlZCA9ICFyZXF1ZXN0SW50ZXJjZXB0aW9uRXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIChyZXF1ZXN0SW50ZXJjZXB0aW9uRXhwZWN0ZWQgJiYgQm9vbGVhbih0aGlzLiNyZXF1ZXN0LnBhdXNlZCkpO1xuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLiNyZXF1ZXN0LmluZm8pICYmXG4gICAgICAgICAgICAocmVxdWVzdEludGVyY2VwdGlvbkV4cGVjdGVkXG4gICAgICAgICAgICAgICAgPyByZXF1ZXN0SW50ZXJjZXB0aW9uQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgOiByZXF1ZXN0RXh0cmFJbmZvQ29tcGxldGVkKSkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdEV2ZW50KHRoaXMuI2dldEJlZm9yZVJlcXVlc3RFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUV4dHJhSW5mb0NvbXBsZXRlZCA9IEJvb2xlYW4odGhpcy4jcmVzcG9uc2UuZXh0cmFJbmZvKSB8fFxuICAgICAgICAgICAgLy8gUmVzcG9uc2UgZnJvbSBjYWNoZSBkb24ndCBoYXZlIGV4dHJhIGluZm9cbiAgICAgICAgICAgIHRoaXMuI3NlcnZlZEZyb21DYWNoZSB8fFxuICAgICAgICAgICAgLy8gRG9uJ3QgZXhwZWN0IGV4dHJhIGluZm8gaWYgdGhlIGZsYWcgaXMgZmFsc2VcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy4jcmVzcG9uc2UuaW5mbyAmJiAhdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRpb25FeHBlY3RlZCA9ICFub0ludGVyY2VwdGlvbkV4cGVjdGVkICYmXG4gICAgICAgICAgICB0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwicmVzcG9uc2VTdGFydGVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5SZXNwb25zZVN0YXJ0ZWQgKi8pO1xuICAgICAgICBpZiAodGhpcy4jcmVzcG9uc2UuaW5mbyB8fFxuICAgICAgICAgICAgKHJlc3BvbnNlSW50ZXJjZXB0aW9uRXhwZWN0ZWQgJiYgQm9vbGVhbih0aGlzLiNyZXNwb25zZS5wYXVzZWQpKSkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdEV2ZW50KHRoaXMuI2dldFJlc3BvbnNlU3RhcnRlZEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0aW9uQ29tcGxldGVkID0gIXJlc3BvbnNlSW50ZXJjZXB0aW9uRXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIChyZXNwb25zZUludGVyY2VwdGlvbkV4cGVjdGVkICYmIEJvb2xlYW4odGhpcy4jcmVzcG9uc2UucGF1c2VkKSk7XG4gICAgICAgIGlmIChCb29sZWFuKHRoaXMuI3Jlc3BvbnNlLmluZm8pICYmXG4gICAgICAgICAgICByZXNwb25zZUV4dHJhSW5mb0NvbXBsZXRlZCAmJlxuICAgICAgICAgICAgcmVzcG9uc2VJbnRlcmNlcHRpb25Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXRFdmVudCh0aGlzLiNnZXRSZXNwb25zZVJlY2VpdmVkRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZS5kZWxldGVSZXF1ZXN0KHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVxdWVzdFdpbGxCZVNlbnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLiNyZXF1ZXN0LmluZm8gPSBldmVudDtcbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50c0lmUmVhZHkoKTtcbiAgICB9XG4gICAgb25SZXF1ZXN0V2lsbEJlU2VudEV4dHJhSW5mb0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuI2VtaXRFdmVudHNJZlJlYWR5KCk7XG4gICAgfVxuICAgIG9uUmVzcG9uc2VSZWNlaXZlZEV4dHJhSW5mb0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5zdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgICAgICAgZXZlbnQuc3RhdHVzQ29kZSA8PSAzOTkgJiZcbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuaW5mbyAmJlxuICAgICAgICAgICAgZXZlbnQuaGVhZGVyc1snbG9jYXRpb24nXSA9PT0gdGhpcy4jcmVxdWVzdC5pbmZvLnJlcXVlc3QudXJsKSB7XG4gICAgICAgICAgICAvLyBXZSByZWNlaXZlZCB0aGUgUmVzcG9uc2UgRXh0cmEgaW5mbyBmb3IgdGhlIHJlZGlyZWN0XG4gICAgICAgICAgICAvLyBUb28gbGF0ZSBzbyB3ZSBuZWVkIHRvIHNraXAgaXQgYXMgaXQgd2lsbFxuICAgICAgICAgICAgLy8gZmlyZSB3cm9uZ2x5IGZvciB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXNwb25zZS5leHRyYUluZm8gPSBldmVudDtcbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50c0lmUmVhZHkoKTtcbiAgICB9XG4gICAgb25SZXNwb25zZVJlY2VpdmVkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvID0gZXZlbnQuaGFzRXh0cmFJbmZvO1xuICAgICAgICB0aGlzLiNyZXNwb25zZS5pbmZvID0gZXZlbnQucmVzcG9uc2U7XG4gICAgICAgIHRoaXMuI2VtaXRFdmVudHNJZlJlYWR5KCk7XG4gICAgfVxuICAgIG9uU2VydmVkRnJvbUNhY2hlKCkge1xuICAgICAgICB0aGlzLiNzZXJ2ZWRGcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSgpO1xuICAgIH1cbiAgICBvbkxvYWRpbmdGYWlsZWRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSh7XG4gICAgICAgICAgICBoYXNGYWlsZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5GZXRjaEVycm9yLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBldmVudC5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC90b3QvRmV0Y2gvI21ldGhvZC1mYWlsUmVxdWVzdCAqL1xuICAgIGFzeW5jIGZhaWxSZXF1ZXN0KGVycm9yUmVhc29uKSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI2ZldGNoSWQsICdOZXR3b3JrIEludGVyY2VwdGlvbiBub3Qgc2V0LXVwLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guZmFpbFJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICBlcnJvclJlYXNvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ludGVyY2VwdFBoYXNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvblJlcXVlc3RQYXVzZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy4jZmV0Y2hJZCA9IGV2ZW50LnJlcXVlc3RJZDtcbiAgICAgICAgLy8gQ0RQIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9GZXRjaC8jZXZlbnQtcmVxdWVzdFBhdXNlZFxuICAgICAgICBpZiAoZXZlbnQucmVzcG9uc2VTdGF0dXNDb2RlIHx8IGV2ZW50LnJlc3BvbnNlRXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmxvY2tlZEluUGhhc2UoXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLykgJiZcbiAgICAgICAgICAgICAgICAvLyBDRFAgbWF5IGVtaXQgbXVsdGlwbGUgZXZlbnRzIGZvciBhIHNpbmdsZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgIXRoaXMuI2VtaXR0ZWRFdmVudHNbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLlJlc3BvbnNlU3RhcnRlZF0gJiZcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBhbGwgcmVzcG9uc2UgdGhhdCBoYXZlIG5vdCBlbmFibGVkIE5ldHdvcmsgZG9tYWluXG4gICAgICAgICAgICAgICAgdGhpcy4jZmV0Y2hJZCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ludGVyY2VwdFBoYXNlID0gXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy4jY29udGludWVSZXNwb25zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovKSAmJlxuICAgICAgICAgICAgICAgIC8vIENEUCBtYXkgZW1pdCBtdWx0aXBsZSBldmVudHMgZm9yIGEgc2luZ2xlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAhdGhpcy4jZW1pdHRlZEV2ZW50c1twcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQmVmb3JlUmVxdWVzdFNlbnRdICYmXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgYWxsIHJlcXVlc3RzIHRoYXQgaGF2ZSBub3QgZW5hYmxlZCBOZXR3b3JrIGRvbWFpblxuICAgICAgICAgICAgICAgIHRoaXMuI2ZldGNoSWQgIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLiNjb250aW51ZVJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSgpO1xuICAgIH1cbiAgICBvbkF1dGhSZXF1aXJlZChldmVudCkge1xuICAgICAgICB0aGlzLiNmZXRjaElkID0gZXZlbnQucmVxdWVzdElkO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0LmF1dGggPSBldmVudDtcbiAgICAgICAgaWYgKHRoaXMuI2lzQmxvY2tlZEluUGhhc2UoXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLykgJiZcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGFsbCBhdXRoIHJlcXVlc3RzIHRoYXQgaGF2ZSBub3QgZW5hYmxlZCBOZXR3b3JrIGRvbWFpblxuICAgICAgICAgICAgdGhpcy4jZmV0Y2hJZCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy4jaW50ZXJjZXB0UGhhc2UgPSBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm9pZCB0aGlzLiNjb250aW51ZVdpdGhBdXRoKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZTogJ0RlZmF1bHQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQXV0aFJlcXVpcmVkLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB0aGlzLiNnZXRSZXNwb25zZUV2ZW50UGFyYW1zKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC90b3QvRmV0Y2gvI21ldGhvZC1jb250aW51ZVJlcXVlc3QgKi9cbiAgICBhc3luYyBjb250aW51ZVJlcXVlc3Qob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVIZWFkZXJzID0gdGhpcy4jZ2V0T3ZlcnJpZGVIZWFkZXIob3ZlcnJpZGVzLmhlYWRlcnMsIG92ZXJyaWRlcy5jb29raWVzKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jZHBGZXRjaEhlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzKShvdmVycmlkZUhlYWRlcnMpO1xuICAgICAgICBjb25zdCBwb3N0RGF0YSA9IGdldENkcEJvZHlGcm9tQmlEaUJ5dGVzVmFsdWUob3ZlcnJpZGVzLmJvZHkpO1xuICAgICAgICBhd2FpdCB0aGlzLiNjb250aW51ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiBvdmVycmlkZXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvdmVycmlkZXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHBvc3REYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdE92ZXJyaWRlcyA9IHtcbiAgICAgICAgICAgIHVybDogb3ZlcnJpZGVzLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogb3ZlcnJpZGVzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG92ZXJyaWRlcy5oZWFkZXJzLFxuICAgICAgICAgICAgY29va2llczogb3ZlcnJpZGVzLmNvb2tpZXMsXG4gICAgICAgICAgICBib2R5U2l6ZTogZ2V0U2l6ZUZyb21CaURpQnl0ZXNWYWx1ZShvdmVycmlkZXMuYm9keSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICNjb250aW51ZVJlcXVlc3Qob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jZmV0Y2hJZCwgJ05ldHdvcmsgSW50ZXJjZXB0aW9uIG5vdCBzZXQtdXAuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdGZXRjaC5jb250aW51ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICB1cmw6IG92ZXJyaWRlcy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG92ZXJyaWRlcy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBvdmVycmlkZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHBvc3REYXRhOiBvdmVycmlkZXMucG9zdERhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBzZWUgaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0ZldGNoLyNtZXRob2QtY29udGludWVSZXNwb25zZSAqL1xuICAgIGFzeW5jIGNvbnRpbnVlUmVzcG9uc2Uob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0UGhhc2UgPT09IFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdE5leHRQaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ1Byb3ZpZGVDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogb3ZlcnJpZGVzLmNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IG92ZXJyaWRlcy5jcmVkZW50aWFscy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBgUHJvdmlkZUNyZWRlbnRpYWxzYFxuICAgICAgICAgICAgICAgIC8vIEFzIGBEZWZhdWx0YCBtYXkgY2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ1Byb3ZpZGVDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2ludGVyY2VwdFBoYXNlID09PSBcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovKSB7XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZUhlYWRlcnMgPSB0aGlzLiNnZXRPdmVycmlkZUhlYWRlcihvdmVycmlkZXMuaGVhZGVycywgb3ZlcnJpZGVzLmNvb2tpZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcEZldGNoSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnMpKG92ZXJyaWRlSGVhZGVycyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjb250aW51ZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvZGU6IG92ZXJyaWRlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlUGhyYXNlOiBvdmVycmlkZXMucmVhc29uUGhyYXNlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNjb250aW51ZVJlc3BvbnNlKHsgcmVzcG9uc2VDb2RlLCByZXNwb25zZVBocmFzZSwgcmVzcG9uc2VIZWFkZXJzLCB9ID0ge30pIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jZmV0Y2hJZCwgJ05ldHdvcmsgSW50ZXJjZXB0aW9uIG5vdCBzZXQtdXAuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdGZXRjaC5jb250aW51ZVJlc3BvbnNlJywge1xuICAgICAgICAgICAgcmVxdWVzdElkOiB0aGlzLiNmZXRjaElkLFxuICAgICAgICAgICAgcmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgcmVzcG9uc2VQaHJhc2UsXG4gICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBzZWUgaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0ZldGNoLyNtZXRob2QtY29udGludWVXaXRoQXV0aCAqL1xuICAgIGFzeW5jIGNvbnRpbnVlV2l0aEF1dGgoYXV0aENoYWxsZW5nZSkge1xuICAgICAgICBsZXQgdXNlcm5hbWU7XG4gICAgICAgIGxldCBwYXNzd29yZDtcbiAgICAgICAgaWYgKGF1dGhDaGFsbGVuZ2UuYWN0aW9uID09PSAncHJvdmlkZUNyZWRlbnRpYWxzJykge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVkZW50aWFscyB9ID0gYXV0aENoYWxsZW5nZTtcbiAgICAgICAgICAgIHVzZXJuYW1lID0gY3JlZGVudGlhbHMudXNlcm5hbWU7XG4gICAgICAgICAgICBwYXNzd29yZCA9IGNyZWRlbnRpYWxzLnBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcEF1dGhDaGFsbGVuZ2VSZXNwb25zZUZyb21CaWRpQXV0aENvbnRpbnVlV2l0aEF1dGhBY3Rpb24pKGF1dGhDaGFsbGVuZ2UuYWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC90b3QvRmV0Y2gvI21ldGhvZC1wcm92aWRlUmVzcG9uc2UgKi9cbiAgICBhc3luYyBwcm92aWRlUmVzcG9uc2Uob3ZlcnJpZGVzKSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI2ZldGNoSWQsICdOZXR3b3JrIEludGVyY2VwdGlvbiBub3Qgc2V0LXVwLicpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgdGhyb3VnaCBpZiB0aGUgcmVxdWVzdCBpcyBhbHJlYWR5IGluXG4gICAgICAgIC8vIEF1dGhSZXF1aXJlZCBwaGFzZVxuICAgICAgICBpZiAodGhpcy5pbnRlcmNlcHRQaGFzZSA9PT0gXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLykge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgYFByb3ZpZGVDcmVkZW50aWFsc2BcbiAgICAgICAgICAgIC8vIEFzIGBEZWZhdWx0YCBtYXkgY2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6ICdQcm92aWRlQ3JlZGVudGlhbHMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbW9kaWZ5IHRoZSByZXNwb25zZVxuICAgICAgICAvLyBqdXN0IGNvbnRpbnVlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICghb3ZlcnJpZGVzLmJvZHkgJiYgIW92ZXJyaWRlcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY29udGludWVSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVIZWFkZXJzID0gdGhpcy4jZ2V0T3ZlcnJpZGVIZWFkZXIob3ZlcnJpZGVzLmhlYWRlcnMsIG92ZXJyaWRlcy5jb29raWVzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcEZldGNoSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnMpKG92ZXJyaWRlSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29kZSA9IG92ZXJyaWRlcy5zdGF0dXNDb2RlID8/IHRoaXMuI3N0YXR1c0NvZGUgPz8gMjAwO1xuICAgICAgICBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guZnVsZmlsbFJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICByZXNwb25zZUNvZGUsXG4gICAgICAgICAgICByZXNwb25zZVBocmFzZTogb3ZlcnJpZGVzLnJlYXNvblBocmFzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGdldENkcEJvZHlGcm9tQmlEaUJ5dGVzVmFsdWUob3ZlcnJpZGVzLmJvZHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jaW50ZXJjZXB0UGhhc2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jICNjb250aW51ZVdpdGhBdXRoKGF1dGhDaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KSh0aGlzLiNmZXRjaElkLCAnTmV0d29yayBJbnRlcmNlcHRpb24gbm90IHNldC11cC4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0ZldGNoLmNvbnRpbnVlV2l0aEF1dGgnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICBhdXRoQ2hhbGxlbmdlUmVzcG9uc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgI2VtaXRFdmVudChnZXRFdmVudCkge1xuICAgICAgICBsZXQgZXZlbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IGdldEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jaXNJZ25vcmVkRXZlbnQoKSB8fFxuICAgICAgICAgICAgKHRoaXMuI2VtaXR0ZWRFdmVudHNbZXZlbnQubWV0aG9kXSAmJlxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0aGlzIGV2ZW50IGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgZXZlbnQubWV0aG9kICE9PSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQXV0aFJlcXVpcmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BoYXNlQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLiNlbWl0dGVkRXZlbnRzW2V2ZW50Lm1ldGhvZF0gPSB0cnVlO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudChPYmplY3QuYXNzaWduKGV2ZW50LCB7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICB9KSwgdGhpcy4jY29udGV4dCk7XG4gICAgfVxuICAgICNnZXRCYXNlRXZlbnRQYXJhbXMocGhhc2UpIHtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0UHJvcHMgPSB7XG4gICAgICAgICAgICBpc0Jsb2NrZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrZWRCeSA9IHRoaXMuI2ludGVyY2VwdHNJblBoYXNlKHBoYXNlKTtcbiAgICAgICAgICAgIGludGVyY2VwdFByb3BzLmlzQmxvY2tlZCA9IGJsb2NrZWRCeS5zaXplID4gMDtcbiAgICAgICAgICAgIGlmIChpbnRlcmNlcHRQcm9wcy5pc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRQcm9wcy5pbnRlcmNlcHRzID0gWy4uLmJsb2NrZWRCeV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuI2NvbnRleHQsXG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiB0aGlzLiNuYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICByZWRpcmVjdENvdW50OiB0aGlzLiNyZWRpcmVjdENvdW50LFxuICAgICAgICAgICAgcmVxdWVzdDogdGhpcy4jZ2V0UmVxdWVzdERhdGEoKSxcbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcCBzaG91bGQgYmUgaW4gbWlsbGlzZWNvbmRzLCB3aGlsZSBDRFAgcHJvdmlkZXMgaXQgaW4gc2Vjb25kcy5cbiAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5yb3VuZCgoMCwgTmV0d29ya1V0aWxzX2pzXzEuZ2V0VGltaW5nKSh0aGlzLiNyZXF1ZXN0LmluZm8/LndhbGxUaW1lKSAqIDEwMDApLFxuICAgICAgICAgICAgLy8gQ29udGFpbnMgaXNCbG9ja2VkIGFuZCBpbnRlcmNlcHRzXG4gICAgICAgICAgICAuLi5pbnRlcmNlcHRQcm9wcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2dldFJlc3BvbnNlRXZlbnRQYXJhbXMoKSB7XG4gICAgICAgIC8vIENocm9taXVtIHNlbmRzIHdyb25nIGV4dHJhSW5mbyBldmVudHMgZm9yIHJlc3BvbnNlcyBzZXJ2ZWQgZnJvbSBjYWNoZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wdXBwZXRlZXIvcHVwcGV0ZWVyL2lzc3Vlcy85OTY1IGFuZFxuICAgICAgICAvLyBodHRwczovL2NyYnVnLmNvbS8xMzQwMzk4LlxuICAgICAgICBpZiAodGhpcy4jcmVzcG9uc2UuaW5mbz8uZnJvbURpc2tDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UuZXh0cmFJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAgICAgICAuLi4oMCwgTmV0d29ya1V0aWxzX2pzXzEuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzKSh0aGlzLiNyZXNwb25zZS5pbmZvPy5oZWFkZXJzKSxcbiAgICAgICAgICAgIC4uLigwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnMpKHRoaXMuI3Jlc3BvbnNlLmV4dHJhSW5mbz8uaGVhZGVycyksXG4gICAgICAgICAgICAvLyBUT0RPOiBWZXJpZnkgaG93IHRvIGRlZHVwZSB0aGVzZVxuICAgICAgICAgICAgLy8gLi4uYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzRW50cmllcyhcbiAgICAgICAgICAgIC8vICAgdGhpcy4jcmVzcG9uc2UucGF1c2VkPy5yZXNwb25zZUhlYWRlcnNcbiAgICAgICAgICAgIC8vICksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGF1dGhDaGFsbGVuZ2VzID0gdGhpcy4jYXV0aENoYWxsZW5nZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgcHJvdG9jb2w6IHRoaXMuI3Jlc3BvbnNlLmluZm8/LnByb3RvY29sID8/ICcnLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLiNzdGF0dXNDb2RlID8/IC0xLCAvLyBUT0RPOiBUaHJvdyBhbiBleGNlcHRpb24gb3IgdXNlIHNvbWUgb3RoZXIgc3RhdHVzIGNvZGU/XG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLiNyZXNwb25zZS5pbmZvPy5zdGF0dXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UucGF1c2VkPy5yZXNwb25zZVN0YXR1c1RleHQgfHxcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGZyb21DYWNoZTogdGhpcy4jcmVzcG9uc2UuaW5mbz8uZnJvbURpc2tDYWNoZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLmluZm8/LmZyb21QcmVmZXRjaENhY2hlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy4jc2VydmVkRnJvbUNhY2hlLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiB0aGlzLiNyZXNwb25zZS5pbmZvPy5taW1lVHlwZSB8fCAnJyxcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHRoaXMuI3Jlc3BvbnNlLmluZm8/LmVuY29kZWREYXRhTGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoZWFkZXJzU2l6ZTogKDAsIE5ldHdvcmtVdGlsc19qc18xLmNvbXB1dGVIZWFkZXJzU2l6ZSkoaGVhZGVycyksXG4gICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBmcm9tIHNwZWMuXG4gICAgICAgICAgICBib2R5U2l6ZTogMCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBmcm9tIHNwZWMuXG4gICAgICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi4oYXV0aENoYWxsZW5nZXMgPyB7IGF1dGhDaGFsbGVuZ2VzIH0gOiB7fSksXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgYSBDRFAtc3BlY2lmaWMgZXh0ZW5zaW9uLlxuICAgICAgICAgICAgJ2dvb2c6c2VjdXJpdHlEZXRhaWxzJzogdGhpcy4jcmVzcG9uc2UuaW5mbz8uc2VjdXJpdHlEZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjZ2V0UmVxdWVzdERhdGEoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLiNyZXF1ZXN0SGVhZGVycztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuI2lkLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy4jbWV0aG9kID8/IE5ldHdvcmtSZXF1ZXN0LnVua25vd25QYXJhbWV0ZXIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgY29va2llczogdGhpcy4jY29va2llcyxcbiAgICAgICAgICAgIGhlYWRlcnNTaXplOiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuY29tcHV0ZUhlYWRlcnNTaXplKShoZWFkZXJzKSxcbiAgICAgICAgICAgIGJvZHlTaXplOiB0aGlzLiNib2R5U2l6ZSxcbiAgICAgICAgICAgIHRpbWluZ3M6IHRoaXMuI3RpbWluZ3MsXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIENEUC1zcGVjaWZpYyBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAnZ29vZzpwb3N0RGF0YSc6IHRoaXMuI3JlcXVlc3QuaW5mbz8ucmVxdWVzdD8ucG9zdERhdGEsXG4gICAgICAgICAgICAnZ29vZzpoYXNQb3N0RGF0YSc6IHRoaXMuI3JlcXVlc3QuaW5mbz8ucmVxdWVzdD8uaGFzUG9zdERhdGEsXG4gICAgICAgICAgICAnZ29vZzpyZXNvdXJjZVR5cGUnOiB0aGlzLiNyZXF1ZXN0LmluZm8/LnR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgICNnZXRCZWZvcmVSZXF1ZXN0RXZlbnQoKSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI3JlcXVlc3QuaW5mbywgJ1JlcXVlc3RXaWxsQmVTZW50RXZlbnQgaXMgbm90IHNldCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQmVmb3JlUmVxdWVzdFNlbnQsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi8pLFxuICAgICAgICAgICAgICAgIGluaXRpYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOZXR3b3JrUmVxdWVzdC4jZ2V0SW5pdGlhdG9yVHlwZSh0aGlzLiNyZXF1ZXN0LmluZm8uaW5pdGlhdG9yLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuI3JlcXVlc3QuaW5mby5pbml0aWF0b3IuY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLiNyZXF1ZXN0LmluZm8uaW5pdGlhdG9yLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrVHJhY2U6IHRoaXMuI3JlcXVlc3QuaW5mby5pbml0aWF0b3Iuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuI3JlcXVlc3QuaW5mby5pbml0aWF0b3IucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjZ2V0UmVzcG9uc2VTdGFydGVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5SZXNwb25zZVN0YXJ0ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLyksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHRoaXMuI2dldFJlc3BvbnNlRXZlbnRQYXJhbXMoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgICNnZXRSZXNwb25zZVJlY2VpdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5SZXNwb25zZUNvbXBsZXRlZCxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuI2dldEJhc2VFdmVudFBhcmFtcygpLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB0aGlzLiNnZXRSZXNwb25zZUV2ZW50UGFyYW1zKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjaXNJZ25vcmVkRXZlbnQoKSB7XG4gICAgICAgIGNvbnN0IGZhdmljb25VcmwgPSAnL2Zhdmljb24uaWNvJztcbiAgICAgICAgcmV0dXJuICh0aGlzLiNyZXF1ZXN0LnBhdXNlZD8ucmVxdWVzdC51cmwuZW5kc1dpdGgoZmF2aWNvblVybCkgPz9cbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuaW5mbz8ucmVxdWVzdC51cmwuZW5kc1dpdGgoZmF2aWNvblVybCkgPz9cbiAgICAgICAgICAgIGZhbHNlKTtcbiAgICB9XG4gICAgI2dldE92ZXJyaWRlSGVhZGVyKGhlYWRlcnMsIGNvb2tpZXMpIHtcbiAgICAgICAgaWYgKCFoZWFkZXJzICYmICFjb29raWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVycmlkZUhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBjb25zdCBjb29raWVIZWFkZXIgPSAoMCwgTmV0d29ya1V0aWxzX2pzXzEubmV0d29ya0hlYWRlckZyb21Db29raWVIZWFkZXJzKShjb29raWVzKTtcbiAgICAgICAgaWYgKGNvb2tpZUhlYWRlciAmJiAhb3ZlcnJpZGVIZWFkZXJzKSB7XG4gICAgICAgICAgICBvdmVycmlkZUhlYWRlcnMgPSB0aGlzLiNyZXF1ZXN0SGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29va2llSGVhZGVyICYmIG92ZXJyaWRlSGVhZGVycykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIZWFkZXJzLmZpbHRlcigoaGVhZGVyKSA9PiBoZWFkZXIubmFtZS5sb2NhbGVDb21wYXJlKCdjb29raWUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBzZW5zaXRpdml0eTogJ2Jhc2UnLFxuICAgICAgICAgICAgfSkgIT09IDApO1xuICAgICAgICAgICAgb3ZlcnJpZGVIZWFkZXJzLnB1c2goY29va2llSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcnJpZGVIZWFkZXJzO1xuICAgIH1cbiAgICBzdGF0aWMgI2dldEluaXRpYXRvclR5cGUoaW5pdGlhdG9yVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKGluaXRpYXRvclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhcnNlcic6XG4gICAgICAgICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgICAgICAgY2FzZSAncHJlZmxpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhdG9yVHlwZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtSZXF1ZXN0ID0gTmV0d29ya1JlcXVlc3Q7XG5mdW5jdGlvbiBnZXRDZHBCb2R5RnJvbUJpRGlCeXRlc1ZhbHVlKGJvZHkpIHtcbiAgICBsZXQgcGFyc2VkQm9keTtcbiAgICBpZiAoYm9keT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IGJ0b2EoYm9keS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJvZHk/LnR5cGUgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIHBhcnNlZEJvZHkgPSBib2R5LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQm9keTtcbn1cbmZ1bmN0aW9uIGdldFNpemVGcm9tQmlEaUJ5dGVzVmFsdWUoYm9keSkge1xuICAgIGlmIChib2R5Py50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYm9keS52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJvZHk/LnR5cGUgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIHJldHVybiBhdG9iKGJvZHkudmFsdWUpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXR3b3JrUmVxdWVzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya1N0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgdXVpZF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL3V1aWQuanNcIik7XG5jb25zdCBOZXR3b3JrUmVxdWVzdF9qc18xID0gcmVxdWlyZShcIi4vTmV0d29ya1JlcXVlc3QuanNcIik7XG5jb25zdCBOZXR3b3JrVXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtVdGlscy5qc1wiKTtcbi8qKiBTdG9yZXMgbmV0d29yayBhbmQgaW50ZXJjZXB0IG1hcHMuICovXG5jbGFzcyBOZXR3b3JrU3RvcmFnZSB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjbG9nZ2VyO1xuICAgIC8qKlxuICAgICAqIEEgbWFwIGZyb20gbmV0d29yayByZXF1ZXN0IElEIHRvIE5ldHdvcmsgUmVxdWVzdCBvYmplY3RzLlxuICAgICAqIE5lZWRlZCBhcyBsb25nIGFzIGluZm9ybWF0aW9uIGFib3V0IHJlcXVlc3RzIGNvbWVzIGZyb20gZGlmZmVyZW50IGV2ZW50cy5cbiAgICAgKi9cbiAgICAjcmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqIEEgbWFwIGZyb20gaW50ZXJjZXB0IElEIHRvIHRyYWNrIGFjdGl2ZSBuZXR3b3JrIGludGVyY2VwdHMuICovXG4gICAgI2ludGVyY2VwdHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3RydWN0b3IoZXZlbnRNYW5hZ2VyLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCBicm93c2VyQ2xpZW50LCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgYnJvd3NlckNsaWVudC5vbignVGFyZ2V0LmRldGFjaGVkRnJvbVRhcmdldCcsICh7IHNlc3Npb25JZCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VSZXF1ZXN0TWFwKHNlc3Npb25JZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5ldHdvcmsgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBJRCwgaWYgYW55LlxuICAgICAqIE90aGVyd2lzZSwgY3JlYXRlcyBhIG5ldyBuZXR3b3JrIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gSUQgYW5kIGNkcCB0YXJnZXQuXG4gICAgICovXG4gICAgI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QoaWQsIGNkcFRhcmdldCwgcmVkaXJlY3RDb3VudCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZ2V0UmVxdWVzdEJ5SWQoaWQpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdCA9IG5ldyBOZXR3b3JrUmVxdWVzdF9qc18xLk5ldHdvcmtSZXF1ZXN0KGlkLCB0aGlzLiNldmVudE1hbmFnZXIsIHRoaXMsIGNkcFRhcmdldCwgcmVkaXJlY3RDb3VudCwgdGhpcy4jbG9nZ2VyKTtcbiAgICAgICAgdGhpcy5hZGRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgb25DZHBUYXJnZXRDcmVhdGVkKGNkcFRhcmdldCkge1xuICAgICAgICBjb25zdCBjZHBDbGllbnQgPSBjZHBUYXJnZXQuY2RwQ2xpZW50O1xuICAgICAgICAvLyBUT0RPOiBXcmFwIGludG8gb2JqZWN0XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnTmV0d29yay5yZXF1ZXN0V2lsbEJlU2VudCcsXG4gICAgICAgICAgICAgICAgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRSZXF1ZXN0QnlJZChwYXJhbXMucmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5pc1JlZGlyZWN0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGFuZGxlUmVkaXJlY3QocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlUmVxdWVzdChwYXJhbXMucmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0LCByZXF1ZXN0LnJlZGlyZWN0Q291bnQgKyAxKS5vblJlcXVlc3RXaWxsQmVTZW50RXZlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vblJlcXVlc3RXaWxsQmVTZW50RXZlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdOZXR3b3JrLnJlcXVlc3RXaWxsQmVTZW50RXh0cmFJbmZvJyxcbiAgICAgICAgICAgICAgICAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vblJlcXVlc3RXaWxsQmVTZW50RXh0cmFJbmZvRXZlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnTmV0d29yay5yZXNwb25zZVJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vblJlc3BvbnNlUmVjZWl2ZWRFdmVudChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdOZXR3b3JrLnJlc3BvbnNlUmVjZWl2ZWRFeHRyYUluZm8nLFxuICAgICAgICAgICAgICAgIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZ2V0T3JDcmVhdGVOZXR3b3JrUmVxdWVzdChwYXJhbXMucmVxdWVzdElkLCBjZHBUYXJnZXQpLm9uUmVzcG9uc2VSZWNlaXZlZEV4dHJhSW5mb0V2ZW50KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ05ldHdvcmsucmVxdWVzdFNlcnZlZEZyb21DYWNoZScsXG4gICAgICAgICAgICAgICAgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCkub25TZXJ2ZWRGcm9tQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnTmV0d29yay5sb2FkaW5nRmFpbGVkJyxcbiAgICAgICAgICAgICAgICAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vbkxvYWRpbmdGYWlsZWRFdmVudChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdGZXRjaC5yZXF1ZXN0UGF1c2VkJyxcbiAgICAgICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZ2V0T3JDcmVhdGVOZXR3b3JrUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ0RQIHF1aXJrIGlmIHRoZSBOZXR3b3JrIGRvbWFpbiBpcyBub3QgcHJlc2VudCB0aGlzIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBldmVudC5uZXR3b3JrSWQgPz8gZXZlbnQucmVxdWVzdElkLCBjZHBUYXJnZXQpLm9uUmVxdWVzdFBhdXNlZChldmVudCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0ZldGNoLmF1dGhSZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5nZXRSZXF1ZXN0QnlGZXRjaElkKGV2ZW50LnJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QoZXZlbnQucmVxdWVzdElkLCBjZHBUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25BdXRoUmVxdWlyZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IFtldmVudCwgbGlzdGVuZXJdIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgY2RwQ2xpZW50Lm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW50ZXJjZXB0aW9uU3RhZ2VzKGJyb3dzaW5nQ29udGV4dElkKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlcyA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGZhbHNlLFxuICAgICAgICAgICAgYXV0aDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgaW50ZXJjZXB0IG9mIHRoaXMuI2ludGVyY2VwdHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmNlcHQuY29udGV4dHMgJiZcbiAgICAgICAgICAgICAgICAhaW50ZXJjZXB0LmNvbnRleHRzLmluY2x1ZGVzKGJyb3dzaW5nQ29udGV4dElkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhZ2VzLnJlcXVlc3QgfHw9IGludGVyY2VwdC5waGFzZXMuaW5jbHVkZXMoXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi8pO1xuICAgICAgICAgICAgc3RhZ2VzLnJlc3BvbnNlIHx8PSBpbnRlcmNlcHQucGhhc2VzLmluY2x1ZGVzKFwicmVzcG9uc2VTdGFydGVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5SZXNwb25zZVN0YXJ0ZWQgKi8pO1xuICAgICAgICAgICAgc3RhZ2VzLmF1dGggfHw9IGludGVyY2VwdC5waGFzZXMuaW5jbHVkZXMoXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWdlcztcbiAgICB9XG4gICAgZ2V0SW50ZXJjZXB0c0ZvclBoYXNlKHJlcXVlc3QsIHBoYXNlKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnVybCA9PT0gTmV0d29ya1JlcXVlc3RfanNfMS5OZXR3b3JrUmVxdWVzdC51bmtub3duUGFyYW1ldGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyY2VwdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ludGVyY2VwdElkLCBpbnRlcmNlcHRdIG9mIHRoaXMuI2ludGVyY2VwdHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoIWludGVyY2VwdC5waGFzZXMuaW5jbHVkZXMocGhhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGludGVyY2VwdC5jb250ZXh0cyAmJlxuICAgICAgICAgICAgICAgICAgICAhaW50ZXJjZXB0LmNvbnRleHRzLmluY2x1ZGVzKHJlcXVlc3QuY2RwVGFyZ2V0LnRvcExldmVsSWQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludGVyY2VwdC51cmxQYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRzLmFkZChpbnRlcmNlcHRJZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgaW50ZXJjZXB0LnVybFBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBOZXR3b3JrVXRpbHNfanNfMS5tYXRjaFVybFBhdHRlcm4pKHBhdHRlcm4sIHJlcXVlc3QudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRzLmFkZChpbnRlcmNlcHRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0cztcbiAgICB9XG4gICAgZGlzcG9zZVJlcXVlc3RNYXAoc2Vzc2lvbklkKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiB0aGlzLiNyZXF1ZXN0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuY2RwQ2xpZW50LnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdHMuZGVsZXRlKHJlcXVlc3QuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGVudHJ5IHRvIHRoZSBpbnRlcmNlcHQgbWFwLlxuICAgICAqIFVSTCBwYXR0ZXJucyBhcmUgYXNzdW1lZCB0byBiZSBwYXJzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBpbnRlcmNlcHQgSUQuXG4gICAgICovXG4gICAgYWRkSW50ZXJjZXB0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdElkID0gKDAsIHV1aWRfanNfMS51dWlkdjQpKCk7XG4gICAgICAgIHRoaXMuI2ludGVyY2VwdHMuc2V0KGludGVyY2VwdElkLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gaW50ZXJjZXB0IGZyb20gdGhlIGludGVyY2VwdCBtYXAuXG4gICAgICogVGhyb3dzIE5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbiBpZiB0aGUgaW50ZXJjZXB0IGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIHJlbW92ZUludGVyY2VwdChpbnRlcmNlcHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNpbnRlcmNlcHRzLmhhcyhpbnRlcmNlcHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hJbnRlcmNlcHRFeGNlcHRpb24oYEludGVyY2VwdCAnJHtpbnRlcmNlcHR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNpbnRlcmNlcHRzLmRlbGV0ZShpbnRlcmNlcHQpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0QnlJZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdHMuZ2V0KGlkKTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdEJ5RmV0Y2hJZChmZXRjaElkKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiB0aGlzLiNyZXF1ZXN0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuZmV0Y2hJZCA9PT0gZmV0Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWRkUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3JlcXVlc3RzLnNldChyZXF1ZXN0LmlkLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgZGVsZXRlUmVxdWVzdChpZCkge1xuICAgICAgICB0aGlzLiNyZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aXJ0dWFsIG5hdmlnYXRpb24gSUQgZm9yIHRoZSBnaXZlbiBuYXZpZ2FibGUgSUQuXG4gICAgICovXG4gICAgZ2V0VmlydHVhbE5hdmlnYXRpb25JZChjb250ZXh0SWQpIHtcbiAgICAgICAgaWYgKGNvbnRleHRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQoY29udGV4dElkKVxuICAgICAgICAgICAgPy52aXJ0dWFsTmF2aWdhdGlvbklkID8/IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29ya1N0b3JhZ2UgPSBOZXR3b3JrU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldHdvcmtTdG9yYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVIZWFkZXJzU2l6ZSA9IGNvbXB1dGVIZWFkZXJzU2l6ZTtcbmV4cG9ydHMuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzID0gYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzO1xuZXhwb3J0cy5iaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnNFbnRyaWVzID0gYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzRW50cmllcztcbmV4cG9ydHMuY2RwTmV0d29ya0hlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzID0gY2RwTmV0d29ya0hlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzO1xuZXhwb3J0cy5iaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwRmV0Y2hIZWFkZXJzID0gYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcEZldGNoSGVhZGVycztcbmV4cG9ydHMuY2RwRmV0Y2hIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycyA9IGNkcEZldGNoSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnM7XG5leHBvcnRzLm5ldHdvcmtIZWFkZXJGcm9tQ29va2llSGVhZGVycyA9IG5ldHdvcmtIZWFkZXJGcm9tQ29va2llSGVhZGVycztcbmV4cG9ydHMuY2RwQXV0aENoYWxsZW5nZVJlc3BvbnNlRnJvbUJpZGlBdXRoQ29udGludWVXaXRoQXV0aEFjdGlvbiA9IGNkcEF1dGhDaGFsbGVuZ2VSZXNwb25zZUZyb21CaWRpQXV0aENvbnRpbnVlV2l0aEF1dGhBY3Rpb247XG5leHBvcnRzLmNkcFRvQmlEaUNvb2tpZSA9IGNkcFRvQmlEaUNvb2tpZTtcbmV4cG9ydHMuZGVzZXJpYWxpemVCeXRlVmFsdWUgPSBkZXNlcmlhbGl6ZUJ5dGVWYWx1ZTtcbmV4cG9ydHMuYmlkaVRvQ2RwQ29va2llID0gYmlkaVRvQ2RwQ29va2llO1xuZXhwb3J0cy5zYW1lU2l0ZUJpRGlUb0NkcCA9IHNhbWVTaXRlQmlEaVRvQ2RwO1xuZXhwb3J0cy5pc1NwZWNpYWxTY2hlbWUgPSBpc1NwZWNpYWxTY2hlbWU7XG5leHBvcnRzLm1hdGNoVXJsUGF0dGVybiA9IG1hdGNoVXJsUGF0dGVybjtcbmV4cG9ydHMuYmlkaUJvZHlTaXplRnJvbUNkcFBvc3REYXRhRW50cmllcyA9IGJpZGlCb2R5U2l6ZUZyb21DZHBQb3N0RGF0YUVudHJpZXM7XG5leHBvcnRzLmdldFRpbWluZyA9IGdldFRpbWluZztcbmNvbnN0IEVycm9yUmVzcG9uc2VfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9FcnJvclJlc3BvbnNlLmpzXCIpO1xuY29uc3QgQmFzZTY0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvQmFzZTY0LmpzXCIpO1xuY29uc3QgVXJsUGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL1VybFBhdHRlcm4uanNcIik7XG5mdW5jdGlvbiBjb21wdXRlSGVhZGVyc1NpemUoaGVhZGVycykge1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gaGVhZGVycy5yZWR1Y2UoKGFjYywgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBgJHthY2N9JHtoZWFkZXIubmFtZX06ICR7aGVhZGVyLnZhbHVlLnZhbHVlfVxcclxcbmA7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVxdWVzdEhlYWRlcnMpLmxlbmd0aDtcbn1cbi8qKiBDb252ZXJ0cyBmcm9tIENEUCBOZXR3b3JrIGRvbWFpbiBoZWFkZXJzIHRvIEJpRGkgbmV0d29yayBoZWFkZXJzLiAqL1xuZnVuY3Rpb24gYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vKiogQ29udmVydHMgZnJvbSBDRFAgRmV0Y2ggZG9tYWluIGhlYWRlcnMgdG8gQmlEaSBuZXR3b3JrIGhlYWRlcnMuICovXG5mdW5jdGlvbiBiaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnNFbnRyaWVzKGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycy5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLyoqIENvbnZlcnRzIGZyb20gQmlkaSBuZXR3b3JrIGhlYWRlcnMgdG8gQ0RQIE5ldHdvcmsgZG9tYWluIGhlYWRlcnMuICovXG5mdW5jdGlvbiBjZHBOZXR3b3JrSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnMoaGVhZGVycykge1xuICAgIGlmIChoZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKChyZXN1bHQsIGhlYWRlcikgPT4ge1xuICAgICAgICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBiZXR3ZWVuIHN0cmluZyBhbmQgYnl0ZXM/XG4gICAgICAgIHJlc3VsdFtoZWFkZXIubmFtZV0gPSBoZWFkZXIudmFsdWUudmFsdWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufVxuLyoqIENvbnZlcnRzIGZyb20gQ0RQIEZldGNoIGRvbWFpbiBoZWFkZXIgZW50cmllcyB0byBCaWRpIG5ldHdvcmsgaGVhZGVycy4gKi9cbmZ1bmN0aW9uIGJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBGZXRjaEhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vKiogQ29udmVydHMgZnJvbSBCaWRpIG5ldHdvcmsgaGVhZGVycyB0byBDRFAgRmV0Y2ggZG9tYWluIGhlYWRlciBlbnRyaWVzLiAqL1xuZnVuY3Rpb24gY2RwRmV0Y2hIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycy5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIG5ldHdvcmtIZWFkZXJGcm9tQ29va2llSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnMucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBhY2MgKz0gJzsnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb2tpZVZhbHVlID0gdmFsdWUudmFsdWUudHlwZSA9PT0gJ2Jhc2U2NCdcbiAgICAgICAgICAgID8gYnRvYSh2YWx1ZS52YWx1ZS52YWx1ZSlcbiAgICAgICAgICAgIDogdmFsdWUudmFsdWUudmFsdWU7XG4gICAgICAgIGFjYyArPSBgJHt2YWx1ZS5uYW1lfT0ke2Nvb2tpZVZhbHVlfWA7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb29raWUnLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqIENvbnZlcnRzIGZyb20gQmlkaSBhdXRoIGFjdGlvbiB0byBDRFAgYXV0aCBjaGFsbGVuZ2UgcmVzcG9uc2UuICovXG5mdW5jdGlvbiBjZHBBdXRoQ2hhbGxlbmdlUmVzcG9uc2VGcm9tQmlkaUF1dGhDb250aW51ZVdpdGhBdXRoQWN0aW9uKGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgcmV0dXJuICdEZWZhdWx0JztcbiAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgIHJldHVybiAnQ2FuY2VsQXV0aCc7XG4gICAgICAgIGNhc2UgJ3Byb3ZpZGVDcmVkZW50aWFscyc6XG4gICAgICAgICAgICByZXR1cm4gJ1Byb3ZpZGVDcmVkZW50aWFscyc7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIENEUCBOZXR3b3JrIGRvbWFpbiBjb29raWUgdG8gQmlEaSBuZXR3b3JrIGNvb2tpZS5cbiAqICogaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L05ldHdvcmsvI3R5cGUtQ29va2llXG4gKiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jdHlwZS1uZXR3b3JrLUNvb2tpZVxuICovXG5mdW5jdGlvbiBjZHBUb0JpRGlDb29raWUoY29va2llKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBjb29raWUubmFtZSxcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBjb29raWUudmFsdWUgfSxcbiAgICAgICAgZG9tYWluOiBjb29raWUuZG9tYWluLFxuICAgICAgICBwYXRoOiBjb29raWUucGF0aCxcbiAgICAgICAgc2l6ZTogY29va2llLnNpemUsXG4gICAgICAgIGh0dHBPbmx5OiBjb29raWUuaHR0cE9ubHksXG4gICAgICAgIHNlY3VyZTogY29va2llLnNlY3VyZSxcbiAgICAgICAgc2FtZVNpdGU6IGNvb2tpZS5zYW1lU2l0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IFwibm9uZVwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTm9uZSAqL1xuICAgICAgICAgICAgOiBzYW1lU2l0ZUNkcFRvQmlEaShjb29raWUuc2FtZVNpdGUpLFxuICAgICAgICAuLi4oY29va2llLmV4cGlyZXMgPj0gMCA/IHsgZXhwaXJ5OiBjb29raWUuZXhwaXJlcyB9IDogdW5kZWZpbmVkKSxcbiAgICB9O1xuICAgIC8vIEV4dGVuZGluZyB3aXRoIENEUC1zcGVjaWZpYyBwcm9wZXJ0aWVzIHdpdGggYGdvb2c6YCBwcmVmaXguXG4gICAgcmVzdWx0W2Bnb29nOnNlc3Npb25gXSA9IGNvb2tpZS5zZXNzaW9uO1xuICAgIHJlc3VsdFtgZ29vZzpwcmlvcml0eWBdID0gY29va2llLnByaW9yaXR5O1xuICAgIHJlc3VsdFtgZ29vZzpzYW1lUGFydHlgXSA9IGNvb2tpZS5zYW1lUGFydHk7XG4gICAgcmVzdWx0W2Bnb29nOnNvdXJjZVNjaGVtZWBdID0gY29va2llLnNvdXJjZVNjaGVtZTtcbiAgICByZXN1bHRbYGdvb2c6c291cmNlUG9ydGBdID0gY29va2llLnNvdXJjZVBvcnQ7XG4gICAgaWYgKGNvb2tpZS5wYXJ0aXRpb25LZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRbYGdvb2c6cGFydGl0aW9uS2V5YF0gPSBjb29raWUucGFydGl0aW9uS2V5O1xuICAgIH1cbiAgICBpZiAoY29va2llLnBhcnRpdGlvbktleU9wYXF1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdFtgZ29vZzpwYXJ0aXRpb25LZXlPcGFxdWVgXSA9IGNvb2tpZS5wYXJ0aXRpb25LZXlPcGFxdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERlY29kZXMgYSBieXRlIHZhbHVlIHRvIGEgc3RyaW5nLlxuICogQHBhcmFtIHtOZXR3b3JrLkJ5dGVzVmFsdWV9IHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQnl0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIHJldHVybiAoMCwgQmFzZTY0X2pzXzEuYmFzZTY0VG9TdHJpbmcpKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIEJpRGkgc2V0IG5ldHdvcmsgY29va2llIHBhcmFtcyB0byBDRFAgTmV0d29yayBkb21haW4gY29va2llLlxuICogKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI3R5cGUtbmV0d29yay1Db29raWVcbiAqICogaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L05ldHdvcmsvI3R5cGUtQ29va2llUGFyYW1cbiAqL1xuZnVuY3Rpb24gYmlkaVRvQ2RwQ29va2llKHBhcmFtcywgcGFydGl0aW9uS2V5KSB7XG4gICAgY29uc3QgZGVzZXJpYWxpemVkVmFsdWUgPSBkZXNlcmlhbGl6ZUJ5dGVWYWx1ZShwYXJhbXMuY29va2llLnZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IHBhcmFtcy5jb29raWUubmFtZSxcbiAgICAgICAgdmFsdWU6IGRlc2VyaWFsaXplZFZhbHVlLFxuICAgICAgICBkb21haW46IHBhcmFtcy5jb29raWUuZG9tYWluLFxuICAgICAgICBwYXRoOiBwYXJhbXMuY29va2llLnBhdGggPz8gJy8nLFxuICAgICAgICBzZWN1cmU6IHBhcmFtcy5jb29raWUuc2VjdXJlID8/IGZhbHNlLFxuICAgICAgICBodHRwT25seTogcGFyYW1zLmNvb2tpZS5odHRwT25seSA/PyBmYWxzZSxcbiAgICAgICAgLi4uKHBhcnRpdGlvbktleS5zb3VyY2VPcmlnaW4gIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICBwYXJ0aXRpb25LZXk6IHtcbiAgICAgICAgICAgICAgICBoYXNDcm9zc1NpdGVBbmNlc3RvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gQ0RQJ3MgYHBhcnRpdGlvbktleS50b3BMZXZlbFNpdGVgIGlzIHRoZSBCaURpJ3MgYHBhcnRpdGlvbi5zb3VyY2VPcmlnaW5gLlxuICAgICAgICAgICAgICAgIHRvcExldmVsU2l0ZTogcGFydGl0aW9uS2V5LnNvdXJjZU9yaWdpbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocGFyYW1zLmNvb2tpZS5leHBpcnkgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICBleHBpcmVzOiBwYXJhbXMuY29va2llLmV4cGlyeSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihwYXJhbXMuY29va2llLnNhbWVTaXRlICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgc2FtZVNpdGU6IHNhbWVTaXRlQmlEaVRvQ2RwKHBhcmFtcy5jb29raWUuc2FtZVNpdGUpLFxuICAgICAgICB9KSxcbiAgICB9O1xuICAgIC8vIEV4dGVuZGluZyB3aXRoIENEUC1zcGVjaWZpYyBwcm9wZXJ0aWVzIHdpdGggYGdvb2c6YCBwcmVmaXguXG4gICAgaWYgKHBhcmFtcy5jb29raWVbYGdvb2c6dXJsYF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQudXJsID0gcGFyYW1zLmNvb2tpZVtgZ29vZzp1cmxgXTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jb29raWVbYGdvb2c6cHJpb3JpdHlgXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5wcmlvcml0eSA9IHBhcmFtcy5jb29raWVbYGdvb2c6cHJpb3JpdHlgXTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jb29raWVbYGdvb2c6c2FtZVBhcnR5YF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuc2FtZVBhcnR5ID0gcGFyYW1zLmNvb2tpZVtgZ29vZzpzYW1lUGFydHlgXTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jb29raWVbYGdvb2c6c291cmNlU2NoZW1lYF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuc291cmNlU2NoZW1lID0gcGFyYW1zLmNvb2tpZVtgZ29vZzpzb3VyY2VTY2hlbWVgXTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jb29raWVbYGdvb2c6c291cmNlUG9ydGBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnNvdXJjZVBvcnQgPSBwYXJhbXMuY29va2llW2Bnb29nOnNvdXJjZVBvcnRgXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNhbWVTaXRlQ2RwVG9CaURpKHNhbWVTaXRlKSB7XG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgICBjYXNlICdTdHJpY3QnOlxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaWN0XCIgLyogTmV0d29yay5TYW1lU2l0ZS5TdHJpY3QgKi87XG4gICAgICAgIGNhc2UgJ05vbmUnOlxuICAgICAgICAgICAgcmV0dXJuIFwibm9uZVwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTm9uZSAqLztcbiAgICAgICAgY2FzZSAnTGF4JzpcbiAgICAgICAgICAgIHJldHVybiBcImxheFwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTGF4ICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gYExheGA6XG4gICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvYXJ0aWNsZXMvc2FtZXNpdGUtY29va2llcy1leHBsYWluZWQjc2FtZXNpdGVsYXhfYnlfZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIFwibGF4XCIgLyogTmV0d29yay5TYW1lU2l0ZS5MYXggKi87XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVNpdGVCaURpVG9DZHAoc2FtZVNpdGUpIHtcbiAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpY3RcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLlN0cmljdCAqLzpcbiAgICAgICAgICAgIHJldHVybiAnU3RyaWN0JztcbiAgICAgICAgY2FzZSBcImxheFwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTGF4ICovOlxuICAgICAgICAgICAgcmV0dXJuICdMYXgnO1xuICAgICAgICBjYXNlIFwibm9uZVwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTm9uZSAqLzpcbiAgICAgICAgICAgIHJldHVybiAnTm9uZSc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBVbmtub3duICdzYW1lU2l0ZScgdmFsdWUgJHtzYW1lU2l0ZX1gKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm90b2NvbCBpcyBzcGVjaWFsLlxuICogU3BlY2lhbCBwcm90b2NvbHMgYXJlIHRob3NlIHRoYXQgaGF2ZSBhIGRlZmF1bHQgcG9ydC5cbiAqXG4gKiBFeGFtcGxlIGlucHV0czogJ2h0dHAnLCAnaHR0cDonXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NwZWNpYWwtc2NoZW1lXG4gKi9cbmZ1bmN0aW9uIGlzU3BlY2lhbFNjaGVtZShwcm90b2NvbCkge1xuICAgIHJldHVybiBbJ2Z0cCcsICdmaWxlJywgJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLCAnd3NzJ10uaW5jbHVkZXMocHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykpO1xufVxuLyoqIE1hdGNoZXMgdGhlIGdpdmVuIFVSTFBhdHRlcm4gYWdhaW5zdCB0aGUgZ2l2ZW4gVVJMLiAqL1xuZnVuY3Rpb24gbWF0Y2hVcmxQYXR0ZXJuKHVybFBhdHRlcm4sIHVybCkge1xuICAgIHN3aXRjaCAodXJsUGF0dGVybi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgVXJsUGF0dGVybl9qc18xLlVSTFBhdHRlcm4odXJsUGF0dGVybi5wYXR0ZXJuKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsUGF0dGVybl9qc18xLlVSTFBhdHRlcm4oe1xuICAgICAgICAgICAgICAgIHByb3RvY29sOiBwYXR0ZXJuLnByb3RvY29sLFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lOiBwYXR0ZXJuLmhvc3RuYW1lLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHBhdHRlcm4ucG9ydCxcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogcGF0dGVybi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHBhdHRlcm4uc2VhcmNoLFxuICAgICAgICAgICAgfSkudGVzdCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3BhdHRlcm4nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxQYXR0ZXJuX2pzXzEuVVJMUGF0dGVybih1cmxQYXR0ZXJuKS50ZXN0KHVybCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmlkaUJvZHlTaXplRnJvbUNkcFBvc3REYXRhRW50cmllcyhlbnRyaWVzKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBzaXplICs9IGF0b2IoZW50cnkuYnl0ZXMgPz8gJycpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBnZXRUaW1pbmcodGltaW5nKSB7XG4gICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh0aW1pbmcgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGltaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya1V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25zUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNsYXNzIFBlcm1pc3Npb25zUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyQ2RwQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBzZXRQZXJtaXNzaW9ucyhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDb250ZXh0SWQgPSBwYXJhbXNbJ2dvb2c6dXNlckNvbnRleHQnXSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtcy51c2VyQ29udGV4dDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ0Jyb3dzZXIuc2V0UGVybWlzc2lvbicsIHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IHBhcmFtcy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdXNlckNvbnRleHRJZCAmJiB1c2VyQ29udGV4dElkICE9PSAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICAgICAgPyB1c2VyQ29udGV4dElkXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLmRlc2NyaXB0b3IubmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmc6IHBhcmFtcy5zdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgICBgUGVybWlzc2lvbiBjYW4ndCBiZSBncmFudGVkIHRvIG9wYXF1ZSBvcmlnaW5zLmApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc3VjY2VzcyBpZiB0aGUgb3JpZ2luIGlzIG5vdCB2YWxpZCAoZG9lcyBub3QgbWF0Y2ggYW55XG4gICAgICAgICAgICAgICAgLy8gZXhpc3Rpbmcgb3JpZ2lucykuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uc1Byb2Nlc3NvciA9IFBlcm1pc3Npb25zUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVybWlzc2lvbnNQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbFByb3h5ID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91dWlkLmpzXCIpO1xuLyoqXG4gKiBVc2VkIHRvIHNlbmQgbWVzc2FnZXMgZnJvbSByZWFsbSB0byBCaURpIHVzZXIuXG4gKi9cbmNsYXNzIENoYW5uZWxQcm94eSB7XG4gICAgI3Byb3BlcnRpZXM7XG4gICAgI2lkID0gKDAsIHV1aWRfanNfMS51dWlkdjQpKCk7XG4gICAgI2xvZ2dlcjtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvcGVydGllcyA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoYW5uZWwgcHJveHkgaW4gdGhlIGdpdmVuIHJlYWxtLCBpbml0aWFsaXNlcyBsaXN0ZW5lciBhbmRcbiAgICAgKiByZXR1cm5zIGEgaGFuZGxlIHRvIGBzZW5kTWVzc2FnZWAgZGVsZWdhdGUuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdChyZWFsbSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxIYW5kbGUgPSBhd2FpdCBDaGFubmVsUHJveHkuI2NyZWF0ZUFuZEdldEhhbmRsZUluUmVhbG0ocmVhbG0pO1xuICAgICAgICBjb25zdCBzZW5kTWVzc2FnZUhhbmRsZSA9IGF3YWl0IENoYW5uZWxQcm94eS4jY3JlYXRlU2VuZE1lc3NhZ2VIYW5kbGUocmVhbG0sIGNoYW5uZWxIYW5kbGUpO1xuICAgICAgICB2b2lkIHRoaXMuI3N0YXJ0TGlzdGVuZXIocmVhbG0sIGNoYW5uZWxIYW5kbGUsIGV2ZW50TWFuYWdlcik7XG4gICAgICAgIHJldHVybiBzZW5kTWVzc2FnZUhhbmRsZTtcbiAgICB9XG4gICAgLyoqIEdldHMgYSBDaGFubmVsUHJveHkgZnJvbSB3aW5kb3cgYW5kIHJldHVybnMgaXRzIGhhbmRsZS4gKi9cbiAgICBhc3luYyBzdGFydExpc3RlbmVyRnJvbVdpbmRvdyhyZWFsbSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsSGFuZGxlID0gYXdhaXQgdGhpcy4jZ2V0SGFuZGxlRnJvbVdpbmRvdyhyZWFsbSk7XG4gICAgICAgICAgICB2b2lkIHRoaXMuI3N0YXJ0TGlzdGVuZXIocmVhbG0sIGNoYW5uZWxIYW5kbGUsIGV2ZW50TWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0aW9uIHN0cmluZyB3aGljaCBjcmVhdGVzIGEgQ2hhbm5lbFByb3h5IG9iamVjdCBvbiB0aGUgY2xpZW50IHNpZGUuXG4gICAgICovXG4gICAgc3RhdGljICNjcmVhdGVDaGFubmVsUHJveHlFdmFsU3RyKCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0ciA9IFN0cmluZygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbGV0IHF1ZXVlTm9uRW1wdHlSZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBwcm9taXNlLCB3aGljaCBpcyByZXNvbHZlZCBhcyBzb29uIGFzIGEgbWVzc2FnZSBvY2N1cnNcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXN5bmMgZ2V0TWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gcXVldWUubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTm9uRW1wdHlSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25NZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlcyB0aGUgcGVuZGluZyBwcm9taXNlIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZU5vbkVtcHR5UmVzb2x2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTm9uRW1wdHlSZXNvbHZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVOb25FbXB0eVJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGAoJHtmdW5jdGlvblN0cn0pKClgO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIENoYW5uZWxQcm94eSBpbiB0aGUgZ2l2ZW4gcmVhbG0uICovXG4gICAgc3RhdGljIGFzeW5jICNjcmVhdGVBbmRHZXRIYW5kbGVJblJlYWxtKHJlYWxtKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNoYW5uZWxIYW5kbGVSZXN1bHQgPSBhd2FpdCByZWFsbS5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuZXZhbHVhdGUnLCB7XG4gICAgICAgICAgICBleHByZXNzaW9uOiB0aGlzLiNjcmVhdGVDaGFubmVsUHJveHlFdmFsU3RyKCksXG4gICAgICAgICAgICBjb250ZXh0SWQ6IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJpZE9ubHlcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5JZE9ubHkgKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNyZWF0ZUNoYW5uZWxIYW5kbGVSZXN1bHQuZXhjZXB0aW9uRGV0YWlscyB8fFxuICAgICAgICAgICAgY3JlYXRlQ2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGNoYW5uZWxgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKiBHZXRzIGEgaGFuZGxlIHRvIGBzZW5kTWVzc2FnZWAgZGVsZWdhdGUgZnJvbSB0aGUgQ2hhbm5lbFByb3h5IGhhbmRsZS4gKi9cbiAgICBzdGF0aWMgYXN5bmMgI2NyZWF0ZVNlbmRNZXNzYWdlSGFuZGxlKHJlYWxtLCBjaGFubmVsSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlQXJnUmVzdWx0ID0gYXdhaXQgcmVhbG0uY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChjaGFubmVsSGFuZGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxIYW5kbGUuc2VuZE1lc3NhZ2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW3sgb2JqZWN0SWQ6IGNoYW5uZWxIYW5kbGUgfV0sXG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJpZE9ubHlcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5JZE9ubHkgKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4Y2VwdGlvbkRldGFpbHMuXG4gICAgICAgIHJldHVybiBzZW5kTWVzc2FnZUFyZ1Jlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKiBTdGFydHMgbGlzdGVuaW5nIGZvciB0aGUgY2hhbm5lbCBldmVudHMgb2YgdGhlIHByb3ZpZGVkIENoYW5uZWxQcm94eS4gKi9cbiAgICBhc3luYyAjc3RhcnRMaXN0ZW5lcihyZWFsbSwgY2hhbm5lbEhhbmRsZSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBJbmZpbml0ZUxvb3BKU1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCByZWFsbS5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuY2FsbEZ1bmN0aW9uT24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZyhhc3luYyAoY2hhbm5lbEhhbmRsZSkgPT4gYXdhaXQgY2hhbm5lbEhhbmRsZS5nZXRNZXNzYWdlKCkpLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJZDogY2hhbm5lbEhhbmRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiByZWFsbS5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMuI3Byb3BlcnRpZXMuc2VyaWFsaXphdGlvbk9wdGlvbnM/Lm1heE9iamVjdERlcHRoID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uIGluIENoYW5uZWxQcm94eScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtZXNzYWdlLmV4Y2VwdGlvbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzaW5nQ29udGV4dCBvZiByZWFsbS5hc3NvY2lhdGVkQnJvd3NpbmdDb250ZXh0cykge1xuICAgICAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy4jcHJvcGVydGllcy5jaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlYWxtLmNkcFRvQmlkaVZhbHVlKG1lc3NhZ2UsIHRoaXMuI3Byb3BlcnRpZXMub3duZXJzaGlwID8/IFwibm9uZVwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZWFsbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBicm93c2luZ0NvbnRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIGlzIHRocm93biwgdGhlbiB0aGUgY2hhbm5lbCBpcyBwZXJtYW5lbnRseSBicm9rZW4sIHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gZXhpdCB0aGUgbG9vcC5cbiAgICAgICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgaGFuZGxlIG9mIENoYW5uZWxQcm94eSBmcm9tIHdpbmRvdydzIHByb3BlcnR5IHdoaWNoIHdhcyBzZXQgdGhlcmVcbiAgICAgKiBieSBgZ2V0RXZhbEluV2luZG93U3RyYC4gSWYgd2luZG93IHByb3BlcnR5IGlzIG5vdCBzZXQgeWV0LCBzZXRzIGEgcHJvbWlzZVxuICAgICAqIHJlc29sdmVyIHRvIHRoZSB3aW5kb3cgcHJvcGVydHksIHNvIHRoYXQgYGdldEV2YWxJbldpbmRvd1N0cmAgY2FuIHJlc29sdmVcbiAgICAgKiB0aGUgcHJvbWlzZSBsYXRlciBvbiB3aXRoIHRoZSBjaGFubmVsLlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgYGdldEV2YWxJbldpbmRvd1N0cmAgY2FuIGJlIGNhbGxlZCBiZWZvcmUgb3JcbiAgICAgKiBhZnRlciB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyAjZ2V0SGFuZGxlRnJvbVdpbmRvdyhyZWFsbSkge1xuICAgICAgICBjb25zdCBjaGFubmVsSGFuZGxlUmVzdWx0ID0gYXdhaXQgcmVhbG0uY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKHdbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNoYW5uZWxQcm94eSBpcyBub3QgY3JlYXRlZCB5ZXQuIENyZWF0ZSBhIHByb21pc2UsIHB1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXIgdG8gd2luZG93IHByb3BlcnR5IGFuZCByZXR1cm4gdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIGBnZXRFdmFsSW5XaW5kb3dTdHJgIHdpbGwgcmVzb2x2ZSB0aGUgcHJvbWlzZSBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAod1tpZF0gPSByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBjaGFubmVsUHJveHkgaXMgYWxyZWFkeSBjcmVhdGVkIGJ5IGBnZXRFdmFsSW5XaW5kb3dTdHJgIGFuZFxuICAgICAgICAgICAgICAgIC8vIGlzIHNldCBpbnRvIHdpbmRvdyBwcm9wZXJ0eS4gUmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxQcm94eSA9IHdbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3W2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbFByb3h5O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhcmd1bWVudHM6IFt7IHZhbHVlOiB0aGlzLiNpZCB9XSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogcmVhbG0uZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgYXdhaXRQcm9taXNlOiB0cnVlLFxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImlkT25seVwiIC8qIFByb3RvY29sLlJ1bnRpbWUuU2VyaWFsaXphdGlvbk9wdGlvbnNTZXJpYWxpemF0aW9uLklkT25seSAqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbm5lbEhhbmRsZVJlc3VsdC5leGNlcHRpb25EZXRhaWxzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNoYW5uZWxIYW5kbGVSZXN1bHQucmVzdWx0Lm9iamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhbm5lbEhhbmRsZSBub3QgZm91bmQgaW4gd2luZG93W1wiJHt0aGlzLiNpZH1cIl1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyB0byBiZSBldmFsdWF0ZWQgdG8gY3JlYXRlIGEgUHJveHlDaGFubmVsIGFuZCBwdXQgaXQgdG8gd2luZG93LlxuICAgICAqIFJldHVybnMgdGhlIGRlbGVnYXRlIGBzZW5kTWVzc2FnZWAuIFVzZWQgdG8gcHJvdmlkZSBhbiBhcmd1bWVudCBmb3IgcHJlbG9hZFxuICAgICAqIHNjcmlwdC4gRG9lcyB0aGUgZm9sbG93aW5nOlxuICAgICAqIDEuIENyZWF0ZXMgYSBDaGFubmVsUHJveHkuXG4gICAgICogMi4gUHV0cyB0aGUgQ2hhbm5lbFByb3h5IHRvIHdpbmRvd1snJHt0aGlzLiNpZH0nXSBvciByZXNvbHZlcyB0aGUgcHJvbWlzZVxuICAgICAqICAgIGJ5IGNhbGxpbmcgZGVsZWdhdGUgc3RvcmVkIGluIHdpbmRvd1snJHt0aGlzLiNpZH0nXS5cbiAgICAgKiAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAjZ2V0SGFuZGxlRnJvbVdpbmRvd2AgY2FuIGJlIGNhbGxlZCBiZWZvcmUgb3JcbiAgICAgKiAgICBhZnRlciB0aGlzIG1ldGhvZC5cbiAgICAgKiAzLiBSZXR1cm5zIHRoZSBkZWxlZ2F0ZSBgc2VuZE1lc3NhZ2VgIG9mIHRoZSBjcmVhdGVkIENoYW5uZWxQcm94eS5cbiAgICAgKi9cbiAgICBnZXRFdmFsSW5XaW5kb3dTdHIoKSB7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gU3RyaW5nKChpZCwgY2hhbm5lbFByb3h5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gd2luZG93O1xuICAgICAgICAgICAgaWYgKHdbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBgI2dldEhhbmRsZUZyb21XaW5kb3dgIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQsIGFuZCB3aWxsIGdldCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVsUHJveHkgbGF0ZXIuXG4gICAgICAgICAgICAgICAgd1tpZF0gPSBjaGFubmVsUHJveHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBgI2dldEhhbmRsZUZyb21XaW5kb3dgIGlzIGFscmVhZHkgc2V0IGEgZGVsZWdhdGUgdG8gd2luZG93IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHdhaXRpbmcgZm9yIGl0IHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjaGFubmVsUHJveHkuXG4gICAgICAgICAgICAgICAgd1tpZF0oY2hhbm5lbFByb3h5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbFByb3h5LnNlbmRNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFByb3h5RXZhbCA9IENoYW5uZWxQcm94eS4jY3JlYXRlQ2hhbm5lbFByb3h5RXZhbFN0cigpO1xuICAgICAgICByZXR1cm4gYCgke2RlbGVnYXRlfSkoJyR7dGhpcy4jaWR9Jywke2NoYW5uZWxQcm94eUV2YWx9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsUHJveHkgPSBDaGFubmVsUHJveHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFubmVsUHJveHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlbG9hZFNjcmlwdCA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91dWlkLmpzXCIpO1xuY29uc3QgQ2hhbm5lbFByb3h5X2pzXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsUHJveHkuanNcIik7XG4vKipcbiAqIEJpRGkgSURzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBhbmQgYXJlIHVuaXF1ZSB3aXRoaW4gY29udGV4dHMuXG4gKlxuICogQ0RQIHByZWxvYWQgc2NyaXB0IElEcyBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBjbGllbnQgYW5kIGFyZSB1bmlxdWVcbiAqIHdpdGhpbiBzZXNzaW9ucy5cbiAqXG4gKiBUaGUgbWFwcGluZyBiZXR3ZWVuIEJpRGkgYW5kIENEUCBwcmVsb2FkIHNjcmlwdCBJRHMgaXMgMTptYW55LlxuICogQmlEaSBJRHMgYXJlIG5lZWRlZCBieSB0aGUgbWFwcGVyIHRvIGtlZXAgdHJhY2sgb2YgcG90ZW50aWFsIG11bHRpcGxlIENEUCBJRHNcbiAqIGluIHRoZSBjbGllbnQuXG4gKi9cbmNsYXNzIFByZWxvYWRTY3JpcHQge1xuICAgIC8qKiBCaURpIElELCBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBVVUlELiAqL1xuICAgICNpZCA9ICgwLCB1dWlkX2pzXzEudXVpZHY0KSgpO1xuICAgIC8qKiBDRFAgcHJlbG9hZCBzY3JpcHRzLiAqL1xuICAgICNjZHBQcmVsb2FkU2NyaXB0cyA9IFtdO1xuICAgIC8qKiBUaGUgc2NyaXB0IGl0c2VsZiwgaW4gYSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIHNwZWMgaS5lLiBhIGZ1bmN0aW9uLiAqL1xuICAgICNmdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgIC8qKiBUYXJnZXRzLCBpbiB3aGljaCB0aGUgcHJlbG9hZCBzY3JpcHQgaXMgaW5pdGlhbGl6ZWQuICovXG4gICAgI3RhcmdldElkcyA9IG5ldyBTZXQoKTtcbiAgICAvKiogQ2hhbm5lbHMgdG8gYmUgYWRkZWQgYXMgYXJndW1lbnRzIHRvIGZ1bmN0aW9uRGVjbGFyYXRpb24uICovXG4gICAgI2NoYW5uZWxzO1xuICAgIC8qKiBUaGUgc2NyaXB0IHNhbmRib3ggLyB3b3JsZCBuYW1lLiAqL1xuICAgICNzYW5kYm94O1xuICAgIC8qKiBUaGUgYnJvd3NpbmcgY29udGV4dHMgdG8gZXhlY3V0ZSB0aGUgcHJlbG9hZCBzY3JpcHRzIGluLCBpZiBhbnkuICovXG4gICAgI2NvbnRleHRzO1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdGFyZ2V0SWRzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNjaGFubmVscyA9XG4gICAgICAgICAgICBwYXJhbXMuYXJndW1lbnRzPy5tYXAoKGEpID0+IG5ldyBDaGFubmVsUHJveHlfanNfMS5DaGFubmVsUHJveHkoYS52YWx1ZSwgbG9nZ2VyKSkgPz8gW107XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9uRGVjbGFyYXRpb24gPSBwYXJhbXMuZnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy4jc2FuZGJveCA9IHBhcmFtcy5zYW5kYm94O1xuICAgICAgICB0aGlzLiNjb250ZXh0cyA9IHBhcmFtcy5jb250ZXh0cztcbiAgICB9XG4gICAgLyoqIENoYW5uZWxzIG9mIHRoZSBwcmVsb2FkIHNjcmlwdC4gKi9cbiAgICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGFubmVscztcbiAgICB9XG4gICAgLyoqIENvbnRleHRzIG9mIHRoZSBwcmVsb2FkIHNjcmlwdCwgaWYgYW55ICovXG4gICAgZ2V0IGNvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyB0byBiZSBldmFsdWF0ZWQuIFdyYXBzIHVzZXItcHJvdmlkZWQgZnVuY3Rpb24gc28gdGhhdCB0aGUgZm9sbG93aW5nXG4gICAgICogc3RlcHMgYXJlIHJ1bjpcbiAgICAgKiAxLiBDcmVhdGUgY2hhbm5lbHMuXG4gICAgICogMi4gU3RvcmUgdGhlIGNyZWF0ZWQgY2hhbm5lbHMgaW4gd2luZG93LlxuICAgICAqIDMuIENhbGwgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBjaGFubmVscyBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgI2dldEV2YWx1YXRlU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBjaGFubmVsc0FyZ1N0ciA9IGBbJHt0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAubWFwKChjKSA9PiBjLmdldEV2YWxJbldpbmRvd1N0cigpKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XG4gICAgICAgIHJldHVybiBgKCgpPT57KCR7dGhpcy4jZnVuY3Rpb25EZWNsYXJhdGlvbn0pKC4uLiR7Y2hhbm5lbHNBcmdTdHJ9KX0pKClgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzY3JpcHQgdG8gdGhlIGdpdmVuIENEUCB0YXJnZXRzIGJ5IGNhbGxpbmcgdGhlXG4gICAgICogYFBhZ2UuYWRkU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnRgIGNvbW1hbmQuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdEluVGFyZ2V0cyhjZHBUYXJnZXRzLCBydW5JbW1lZGlhdGVseSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChBcnJheS5mcm9tKGNkcFRhcmdldHMpLm1hcCgoY2RwVGFyZ2V0KSA9PiB0aGlzLmluaXRJblRhcmdldChjZHBUYXJnZXQsIHJ1bkltbWVkaWF0ZWx5KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzY3JpcHQgdG8gdGhlIGdpdmVuIENEUCB0YXJnZXQgYnkgY2FsbGluZyB0aGVcbiAgICAgKiBgUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudGAgY29tbWFuZC5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0SW5UYXJnZXQoY2RwVGFyZ2V0LCBydW5JbW1lZGlhdGVseSkge1xuICAgICAgICBjb25zdCBhZGRDZHBQcmVsb2FkU2NyaXB0UmVzdWx0ID0gYXdhaXQgY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudCcsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy4jZ2V0RXZhbHVhdGVTdHJpbmcoKSxcbiAgICAgICAgICAgIHdvcmxkTmFtZTogdGhpcy4jc2FuZGJveCxcbiAgICAgICAgICAgIHJ1bkltbWVkaWF0ZWx5LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGNkcFRhcmdldCxcbiAgICAgICAgICAgIHByZWxvYWRTY3JpcHRJZDogYWRkQ2RwUHJlbG9hZFNjcmlwdFJlc3VsdC5pZGVudGlmaWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdGFyZ2V0SWRzLmFkZChjZHBUYXJnZXQuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoaXMgc2NyaXB0IGZyb20gYWxsIENEUCB0YXJnZXRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZSgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMubWFwKGFzeW5jIChjZHBQcmVsb2FkU2NyaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwVGFyZ2V0ID0gY2RwUHJlbG9hZFNjcmlwdC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwUHJlbG9hZFNjcmlwdElkID0gY2RwUHJlbG9hZFNjcmlwdC5wcmVsb2FkU2NyaXB0SWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UucmVtb3ZlU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGNkcFByZWxvYWRTY3JpcHRJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGNkcCB0YXJnZXQgZnJvbSB0aGUgbGlzdCBvZiBjZHAgcHJlbG9hZCBzY3JpcHRzLiAqL1xuICAgIGRpc3Bvc2UoY2RwVGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMgPSB0aGlzLiNjZHBQcmVsb2FkU2NyaXB0cy5maWx0ZXIoKGNkcFByZWxvYWRTY3JpcHQpID0+IGNkcFByZWxvYWRTY3JpcHQudGFyZ2V0Py5pZCAhPT0gY2RwVGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLiN0YXJnZXRJZHMuZGVsZXRlKGNkcFRhcmdldElkKTtcbiAgICB9XG59XG5leHBvcnRzLlByZWxvYWRTY3JpcHQgPSBQcmVsb2FkU2NyaXB0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlbG9hZFNjcmlwdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSB2b2lkIDA7XG4vKipcbiAqIENvbnRhaW5lciBjbGFzcyBmb3IgcHJlbG9hZCBzY3JpcHRzLlxuICovXG5jbGFzcyBQcmVsb2FkU2NyaXB0U3RvcmFnZSB7XG4gICAgLyoqIFRyYWNrcyBhbGwgQmlEaSBwcmVsb2FkIHNjcmlwdHMuICAqL1xuICAgICNzY3JpcHRzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBlbnRyaWVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGZpbHRlciAoT1IgbG9naWMpLlxuICAgICAqL1xuICAgIGZpbmQoZmlsdGVyKSB7XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuI3NjcmlwdHNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4udGhpcy4jc2NyaXB0c10uZmlsdGVyKChzY3JpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaWQgIT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIuaWQgPT09IHNjcmlwdC5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci50YXJnZXRJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2NyaXB0LnRhcmdldElkcy5oYXMoZmlsdGVyLnRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci5nbG9iYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIC8vIEdsb2JhbCBzY3JpcHRzIGhhdmUgbm8gY29udGV4dHNcbiAgICAgICAgICAgICAgICAoKGZpbHRlci5nbG9iYWwgJiYgc2NyaXB0LmNvbnRleHRzID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vbiBnbG9iYWwgc2NyaXB0cyBhbHdheXMgaGF2ZSBjb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAoIWZpbHRlci5nbG9iYWwgJiYgc2NyaXB0LmNvbnRleHRzICE9PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkKHByZWxvYWRTY3JpcHQpIHtcbiAgICAgICAgdGhpcy4jc2NyaXB0cy5hZGQocHJlbG9hZFNjcmlwdCk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFsbCBCaURpIHByZWxvYWQgc2NyaXB0IGVudHJpZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIHJlbW92ZShmaWx0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcmVsb2FkU2NyaXB0IG9mIHRoaXMuZmluZChmaWx0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLiNzY3JpcHRzLmRlbGV0ZShwcmVsb2FkU2NyaXB0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSBQcmVsb2FkU2NyaXB0U3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZWxvYWRTY3JpcHRTdG9yYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFsbSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCB1dWlkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXVpZC5qc1wiKTtcbmNvbnN0IENoYW5uZWxQcm94eV9qc18xID0gcmVxdWlyZShcIi4vQ2hhbm5lbFByb3h5LmpzXCIpO1xuY2xhc3MgUmVhbG0ge1xuICAgICNjZHBDbGllbnQ7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjZXhlY3V0aW9uQ29udGV4dElkO1xuICAgICNsb2dnZXI7XG4gICAgI29yaWdpbjtcbiAgICAjcmVhbG1JZDtcbiAgICAjcmVhbG1TdG9yYWdlO1xuICAgIGNvbnN0cnVjdG9yKGNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBleGVjdXRpb25Db250ZXh0SWQsIGxvZ2dlciwgb3JpZ2luLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy4jY2RwQ2xpZW50ID0gY2RwQ2xpZW50O1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI2V4ZWN1dGlvbkNvbnRleHRJZCA9IGV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLiNvcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMuI3JlYWxtSWQgPSByZWFsbUlkO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UgPSByZWFsbVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZS5hZGRSZWFsbSh0aGlzKTtcbiAgICB9XG4gICAgY2RwVG9CaWRpVmFsdWUoY2RwVmFsdWUsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICBjb25zdCBiaWRpVmFsdWUgPSB0aGlzLnNlcmlhbGl6ZUZvckJpRGkoY2RwVmFsdWUucmVzdWx0LmRlZXBTZXJpYWxpemVkVmFsdWUsIG5ldyBNYXAoKSk7XG4gICAgICAgIGlmIChjZHBWYWx1ZS5yZXN1bHQub2JqZWN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdElkID0gY2RwVmFsdWUucmVzdWx0Lm9iamVjdElkO1xuICAgICAgICAgICAgaWYgKHJlc3VsdE93bmVyc2hpcCA9PT0gXCJyb290XCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Sb290ICovKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIEJpRGkgdmFsdWUgd2l0aCBgaGFuZGxlYCBiYXNlZCBvbiByZXF1aXJlZCBgcmVzdWx0T3duZXJzaGlwYFxuICAgICAgICAgICAgICAgIC8vIGFuZCAgQ0RQIHJlc3BvbnNlIGJ1dCBub3Qgb24gdGhlIGFjdHVhbCBCaURpIHR5cGUuXG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlLmhhbmRsZSA9IG9iamVjdElkO1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIGFsbCB0aGUgaGFuZGxlcyBzZW50IHRvIGNsaWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2Uua25vd25IYW5kbGVzVG9SZWFsbU1hcC5zZXQob2JqZWN0SWQsIHRoaXMucmVhbG1JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGF3YWl0IGZvciB0aGUgb2JqZWN0IHRvIGJlIHJlbGVhc2VkLlxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy4jcmVsZWFzZU9iamVjdChvYmplY3RJZCkuY2F0Y2goKGVycm9yKSA9PiB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpZGlWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsaWVzIG9uIHRoZSBDRFAgdG8gaW1wbGVtZW50IHByb3BlciBCaURpIHNlcmlhbGl6YXRpb24sIGV4Y2VwdDpcbiAgICAgKiAqIENEUCBpbnRlZ2VyIHByb3BlcnR5IGBiYWNrZW5kTm9kZUlkYCBpcyByZXBsYWNlZCB3aXRoIGBzaGFyZWRJZGAgb2ZcbiAgICAgKiBge2RvY3VtZW50SWR9X2VsZW1lbnRfe2JhY2tlbmROb2RlSWR9YDtcbiAgICAgKiAqIENEUCBpbnRlZ2VyIHByb3BlcnR5IGB3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2VgIGlzIHJlcGxhY2VkIHdpdGggVVVJRCBgaW50ZXJuYWxJZGBcbiAgICAgKiB1c2luZyB1bmlxdWUtcGVyIHNlcmlhbGl6YXRpb24gYGludGVybmFsSWRNYXBgLlxuICAgICAqICogQ0RQIHR5cGUgYHBsYXRmb3Jtb2JqZWN0YCBpcyByZXBsYWNlZCB3aXRoIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSBkZWVwU2VyaWFsaXplZFZhbHVlIC0gQ0RQIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBCaURpLlxuICAgICAqIEBwYXJhbSBpbnRlcm5hbElkTWFwIC0gTWFwIGZyb20gQ0RQIGludGVnZXIgYHdlYWtMb2NhbE9iamVjdFJlZmVyZW5jZWAgdG8gQmlEaSBVVUlEXG4gICAgICogYGludGVybmFsSWRgLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZUZvckJpRGkoZGVlcFNlcmlhbGl6ZWRWYWx1ZSwgaW50ZXJuYWxJZE1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkZWVwU2VyaWFsaXplZFZhbHVlLCAnd2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlYWtMb2NhbE9iamVjdFJlZmVyZW5jZSA9IGRlZXBTZXJpYWxpemVkVmFsdWUud2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlO1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbElkTWFwLmhhcyh3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxJZE1hcC5zZXQod2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlLCAoMCwgdXVpZF9qc18xLnV1aWR2NCkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWVwU2VyaWFsaXplZFZhbHVlLmludGVybmFsSWQgPSBpbnRlcm5hbElkTWFwLmdldCh3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2UpO1xuICAgICAgICAgICAgZGVsZXRlIGRlZXBTZXJpYWxpemVkVmFsdWVbJ3dlYWtMb2NhbE9iamVjdFJlZmVyZW5jZSddO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYXRmb3JtIG9iamVjdCBpcyBhIHNwZWNpYWwgY2FzZS4gSXQgc2hvdWxkIGhhdmUgb25seSBge3R5cGU6IG9iamVjdH1gXG4gICAgICAgIC8vIHdpdGhvdXQgYHZhbHVlYCBmaWVsZC5cbiAgICAgICAgaWYgKGRlZXBTZXJpYWxpemVkVmFsdWUudHlwZSA9PT0gJ3BsYXRmb3Jtb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29iamVjdCcgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaWRpVmFsdWUgPSBkZWVwU2VyaWFsaXplZFZhbHVlLnZhbHVlO1xuICAgICAgICBpZiAoYmlkaVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwU2VyaWFsaXplZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgbmVzdGVkIHZhbHVlcy5cbiAgICAgICAgaWYgKFsnYXJyYXknLCAnc2V0JywgJ2h0bWxjb2xsZWN0aW9uJywgJ25vZGVsaXN0J10uaW5jbHVkZXMoZGVlcFNlcmlhbGl6ZWRWYWx1ZS50eXBlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGJpZGlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJpZGlWYWx1ZVtpXSA9IHRoaXMuc2VyaWFsaXplRm9yQmlEaShiaWRpVmFsdWVbaV0sIGludGVybmFsSWRNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChbJ29iamVjdCcsICdtYXAnXS5pbmNsdWRlcyhkZWVwU2VyaWFsaXplZFZhbHVlLnR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gYmlkaVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlW2ldID0gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZvckJpRGkoYmlkaVZhbHVlW2ldWzBdLCBpbnRlcm5hbElkTWFwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGb3JCaURpKGJpZGlWYWx1ZVtpXVsxXSwgaW50ZXJuYWxJZE1hcCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVlcFNlcmlhbGl6ZWRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJlYWxtSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWFsbUlkO1xuICAgIH1cbiAgICBnZXQgZXhlY3V0aW9uQ29udGV4dElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXhlY3V0aW9uQ29udGV4dElkO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3JpZ2luO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNkcENsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NkcENsaWVudDtcbiAgICB9XG4gICAgZ2V0IGJhc2VJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlKGV4cHJlc3Npb24sIGF3YWl0UHJvbWlzZSwgcmVzdWx0T3duZXJzaGlwID0gXCJub25lXCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Ob25lICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHt9LCB1c2VyQWN0aXZhdGlvbiA9IGZhbHNlLCBpbmNsdWRlQ29tbWFuZExpbmVBcGkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjZHBFdmFsdWF0ZVJlc3VsdCA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmV2YWx1YXRlJywge1xuICAgICAgICAgICAgY29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBhd2FpdFByb21pc2UsXG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9uczogUmVhbG0uI2dldFNlcmlhbGl6YXRpb25PcHRpb25zKFwiZGVlcFwiIC8qIFByb3RvY29sLlJ1bnRpbWUuU2VyaWFsaXphdGlvbk9wdGlvbnNTZXJpYWxpemF0aW9uLkRlZXAgKi8sIHNlcmlhbGl6YXRpb25PcHRpb25zKSxcbiAgICAgICAgICAgIHVzZXJHZXN0dXJlOiB1c2VyQWN0aXZhdGlvbixcbiAgICAgICAgICAgIGluY2x1ZGVDb21tYW5kTGluZUFQSTogaW5jbHVkZUNvbW1hbmRMaW5lQXBpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNkcEV2YWx1YXRlUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNnZXRFeGNlcHRpb25SZXN1bHQoY2RwRXZhbHVhdGVSZXN1bHQuZXhjZXB0aW9uRGV0YWlscywgMCwgcmVzdWx0T3duZXJzaGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBFdmFsdWF0ZVJlc3VsdCwgcmVzdWx0T3duZXJzaGlwKSxcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI3JlZ2lzdGVyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudChldmVudCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzaW5nQ29udGV4dCBvZiB0aGlzLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoZXZlbnQsIGJyb3dzaW5nQ29udGV4dC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy4jcmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5SZWFsbUNyZWF0ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMucmVhbG1JbmZvLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIGdpdmVuIENEUCBvYmplY3QgaW50byBCaURpLCBrZWVwaW5nIHJlZmVyZW5jZXMgaW4gdGhlXG4gICAgICogdGFyZ2V0J3MgYGdsb2JhbFRoaXNgLlxuICAgICAqL1xuICAgIGFzeW5jIHNlcmlhbGl6ZUNkcE9iamVjdChjZHBSZW1vdGVPYmplY3QsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IFJlYWxtLiNjZHBSZW1vdGVPYmplY3RUb0NhbGxBcmd1bWVudChjZHBSZW1vdGVPYmplY3QpO1xuICAgICAgICBjb25zdCBjZHBWYWx1ZSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChyZW1vdGVPYmplY3QpID0+IHJlbW90ZU9iamVjdCksXG4gICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbYXJndW1lbnRdLFxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBWYWx1ZSwgcmVzdWx0T3duZXJzaGlwKTtcbiAgICB9XG4gICAgc3RhdGljICNjZHBSZW1vdGVPYmplY3RUb0NhbGxBcmd1bWVudChjZHBSZW1vdGVPYmplY3QpIHtcbiAgICAgICAgaWYgKGNkcFJlbW90ZU9iamVjdC5vYmplY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogY2RwUmVtb3RlT2JqZWN0Lm9iamVjdElkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNkcFJlbW90ZU9iamVjdC51bnNlcmlhbGl6YWJsZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6IGNkcFJlbW90ZU9iamVjdC51bnNlcmlhbGl6YWJsZVZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNkcFJlbW90ZU9iamVjdC52YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBjYWxsaW5nIGB0b1N0cmluZygpYCBvbiB0aGUgb2JqZWN0IHZhbHVlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0cmluZ2lmeU9iamVjdChjZHBSZW1vdGVPYmplY3QpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChyZW1vdGVPYmplY3QpID0+IFN0cmluZyhyZW1vdGVPYmplY3QpKSxcbiAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogZmFsc2UsXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtjZHBSZW1vdGVPYmplY3RdLFxuICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICBhc3luYyAjZmxhdHRlbktleVZhbHVlUGFpcnMobWFwcGluZ0xvY2FsVmFsdWUpIHtcbiAgICAgICAgY29uc3Qga2V5VmFsdWVBcnJheSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcHBpbmdMb2NhbFZhbHVlLm1hcChhc3luYyAoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBsZXQga2V5QXJnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGlzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGtleUFyZyA9IHsgdmFsdWU6IGtleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGlzIGEgc2VyaWFsaXplZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBrZXlBcmcgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplRm9yQ2RwKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFyZyA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlBcmcsIHZhbHVlQXJnXTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ga2V5VmFsdWVBcnJheS5mbGF0KCk7XG4gICAgfVxuICAgIGFzeW5jICNmbGF0dGVuVmFsdWVMaXN0KGxpc3RMb2NhbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChsaXN0TG9jYWxWYWx1ZS5tYXAoKGxvY2FsVmFsdWUpID0+IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAobG9jYWxWYWx1ZSkpKTtcbiAgICB9XG4gICAgYXN5bmMgI3NlcmlhbGl6ZUNkcEV4Y2VwdGlvbkRldGFpbHMoY2RwRXhjZXB0aW9uRGV0YWlscywgbGluZU9mZnNldCwgcmVzdWx0T3duZXJzaGlwKSB7XG4gICAgICAgIGNvbnN0IGNhbGxGcmFtZXMgPSBjZHBFeGNlcHRpb25EZXRhaWxzLnN0YWNrVHJhY2U/LmNhbGxGcmFtZXMubWFwKChmcmFtZSkgPT4gKHtcbiAgICAgICAgICAgIHVybDogZnJhbWUudXJsLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmcmFtZS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBmcmFtZS5saW5lTnVtYmVyIC0gbGluZU9mZnNldCxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogZnJhbWUuY29sdW1uTnVtYmVyLFxuICAgICAgICB9KSkgPz8gW107XG4gICAgICAgIC8vIEV4Y2VwdGlvbiBzaG91bGQgYWx3YXlzIGJlIHRoZXJlLlxuICAgICAgICBjb25zdCBleGNlcHRpb24gPSBjZHBFeGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogYXdhaXQgdGhpcy5zZXJpYWxpemVDZHBPYmplY3QoZXhjZXB0aW9uLCByZXN1bHRPd25lcnNoaXApLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjZHBFeGNlcHRpb25EZXRhaWxzLmNvbHVtbk51bWJlcixcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGNkcEV4Y2VwdGlvbkRldGFpbHMubGluZU51bWJlciAtIGxpbmVPZmZzZXQsXG4gICAgICAgICAgICBzdGFja1RyYWNlOiB7XG4gICAgICAgICAgICAgICAgY2FsbEZyYW1lcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAoYXdhaXQgdGhpcy5zdHJpbmdpZnlPYmplY3QoZXhjZXB0aW9uKSkgfHwgY2RwRXhjZXB0aW9uRGV0YWlscy50ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgYXdhaXRQcm9taXNlLCB0aGlzTG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgdHlwZTogJ3VuZGVmaW5lZCcsXG4gICAgfSwgYXJndW1lbnRzTG9jYWxWYWx1ZXMgPSBbXSwgcmVzdWx0T3duZXJzaGlwID0gXCJub25lXCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Ob25lICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHt9LCB1c2VyQWN0aXZhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxGdW5jdGlvbkFuZFNlcmlhbGl6ZVNjcmlwdCA9IGAoLi4uYXJncykgPT4ge1xuICAgICAgZnVuY3Rpb24gY2FsbEZ1bmN0aW9uKGYsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkVGhpcyA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkQXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KGRlc2VyaWFsaXplZFRoaXMsIGRlc2VyaWFsaXplZEFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxGdW5jdGlvbigoXG4gICAgICAgICR7ZnVuY3Rpb25EZWNsYXJhdGlvbn1cbiAgICAgICksIGFyZ3MpO1xuICAgIH1gO1xuICAgICAgICBjb25zdCB0aGlzQW5kQXJndW1lbnRzTGlzdCA9IFtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAodGhpc0xvY2FsVmFsdWUpLFxuICAgICAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKGFyZ3VtZW50c0xvY2FsVmFsdWVzLm1hcChhc3luYyAoYXJndW1lbnRMb2NhbFZhbHVlKSA9PiBhd2FpdCB0aGlzLmRlc2VyaWFsaXplRm9yQ2RwKGFyZ3VtZW50TG9jYWxWYWx1ZSkpKSksXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjZHBDYWxsRnVuY3Rpb25SZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjZHBDYWxsRnVuY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUnVudGltZS5jYWxsRnVuY3Rpb25PbicsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBjYWxsRnVuY3Rpb25BbmRTZXJpYWxpemVTY3JpcHQsXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogdGhpc0FuZEFyZ3VtZW50c0xpc3QsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IFJlYWxtLiNnZXRTZXJpYWxpemF0aW9uT3B0aW9ucyhcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgICAgICB1c2VyR2VzdHVyZTogdXNlckFjdGl2YXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlcm1pbmUgaWYgdGhlIHByb2JsZW0gaXMgaW4gdGhlIGFyZ3VtZW50LlxuICAgICAgICAgICAgLy8gVGhlIGNoZWNrIGNhbiBiZSBkb25lIG9uIHRoZSBgZGVzZXJpYWxpemF0aW9uYCBzdGVwLCBidXQgdGhpcyBhcHByb2FjaFxuICAgICAgICAgICAgLy8gaGVscHMgdG8gc2F2ZSByb3VuZC10cmlwcy5cbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAtMzIwMDAgLyogQ2RwRXJyb3JDb25zdGFudHMuR0VORVJJQ19FUlJPUiAqLyAmJlxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIG9iamVjdCB3aXRoIGdpdmVuIGlkJyxcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IHNob3VsZCBiZWxvbmcgdG8gdGhlIHNhbWUgSmF2YVNjcmlwdCB3b3JsZCBhcyB0YXJnZXQgb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcmVtb3RlIG9iamVjdCBpZCcsXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaEhhbmRsZUV4Y2VwdGlvbignSGFuZGxlIHdhcyBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2RwQ2FsbEZ1bmN0aW9uUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNnZXRFeGNlcHRpb25SZXN1bHQoY2RwQ2FsbEZ1bmN0aW9uUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMsIDEsIHJlc3VsdE93bmVyc2hpcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBDYWxsRnVuY3Rpb25SZXN1bHQsIHJlc3VsdE93bmVyc2hpcCksXG4gICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbUlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZUZvckNkcChsb2NhbFZhbHVlKSB7XG4gICAgICAgIGlmICgnaGFuZGxlJyBpbiBsb2NhbFZhbHVlICYmIGxvY2FsVmFsdWUuaGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogbG9jYWxWYWx1ZS5oYW5kbGUgfTtcbiAgICAgICAgICAgIC8vIFdlIHRyaWVkIHRvIGZpbmQgYSBoYW5kbGUgdmFsdWUgYnV0IGZhaWxlZFxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBleGhhdXN0aXZlIHN3aXRjaCBvbiBgbG9jYWxWYWx1ZS50eXBlYFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdoYW5kbGUnIGluIGxvY2FsVmFsdWUgfHwgJ3NoYXJlZElkJyBpbiBsb2NhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hIYW5kbGVFeGNlcHRpb24oJ0hhbmRsZSB3YXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobG9jYWxWYWx1ZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bnNlcmlhbGl6YWJsZVZhbHVlOiAnbnVsbCcgfTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGxvY2FsVmFsdWUudmFsdWUgfTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVmFsdWUudmFsdWUgPT09ICdOYU4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICdOYU4nIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsVmFsdWUudmFsdWUgPT09ICctMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJy0wJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhbFZhbHVlLnZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICdJbmZpbml0eScgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxWYWx1ZS52YWx1ZSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJy1JbmZpbml0eScgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsVmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBCb29sZWFuKGxvY2FsVmFsdWUudmFsdWUpIH07XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHVuc2VyaWFsaXphYmxlVmFsdWU6IGBCaWdJbnQoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlKX0pYCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGVWYWx1ZTogYG5ldyBEYXRlKERhdGUucGFyc2UoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlKX0pKWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGVWYWx1ZTogYG5ldyBSZWdFeHAoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlLnBhdHRlcm4pfSwgJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlLmZsYWdzKX0pYCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbWFwJzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IElmIG5vbmUgb2YgdGhlIG5lc3RlZCBrZXlzIGFuZCB2YWx1ZXMgaGFzIGEgcmVtb3RlXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlLCBzZXJpYWxpemUgdG8gYHVuc2VyaWFsaXphYmxlVmFsdWVgIHdpdGhvdXQgQ0RQIHJvdW5kdHJpcC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlWYWx1ZUFycmF5ID0gYXdhaXQgdGhpcy4jZmxhdHRlbktleVZhbHVlUGFpcnMobG9jYWxWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYXJnc1tpXSwgYXJnc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czoga2V5VmFsdWVBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjMzc1KTogUmVsZWFzZSBgcmVzdWx0Lm9iamVjdElkYCBhZnRlciB1c2luZy5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogcmVzdWx0Lm9iamVjdElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgbm9uZSBvZiB0aGUgbmVzdGVkIGtleXMgYW5kIHZhbHVlcyBoYXMgYSByZW1vdGVcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UsIHNlcmlhbGl6ZSB0byBgdW5zZXJpYWxpemFibGVWYWx1ZWAgd2l0aG91dCBDRFAgcm91bmR0cmlwLlxuICAgICAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlQXJyYXkgPSBhd2FpdCB0aGlzLiNmbGF0dGVuS2V5VmFsdWVQYWlycyhsb2NhbFZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgdGhpcy5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuY2FsbEZ1bmN0aW9uT24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZygoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZXkgc2hvdWxkIGJlIGVpdGhlciBgc3RyaW5nYCwgYG51bWJlcmAsIG9yIGBzeW1ib2xgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGtleVZhbHVlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHRoaXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IFJlbGVhc2UgYHJlc3VsdC5vYmplY3RJZGAgYWZ0ZXIgdXNpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IHJlc3VsdC5vYmplY3RJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgbm9uZSBvZiB0aGUgbmVzdGVkIGl0ZW1zIGhhcyBhIHJlbW90ZSByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIHRvIGB1bnNlcmlhbGl6YWJsZVZhbHVlYCB3aXRob3V0IENEUCByb3VuZHRyaXAuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGF3YWl0IHRoaXMuI2ZsYXR0ZW5WYWx1ZUxpc3QobG9jYWxWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKC4uLmFyZ3MpID0+IGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHRoaXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IFJlbGVhc2UgYHJlc3VsdC5vYmplY3RJZGAgYWZ0ZXIgdXNpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IHJlc3VsdC5vYmplY3RJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2V0Jzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIG5vbmUgb2YgdGhlIG5lc3RlZCBpdGVtcyBoYXMgYSByZW1vdGUgcmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSB0byBgdW5zZXJpYWxpemFibGVWYWx1ZWAgd2l0aG91dCBDRFAgcm91bmR0cmlwLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhd2FpdCB0aGlzLiNmbGF0dGVuVmFsdWVMaXN0KGxvY2FsVmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUnVudGltZS5jYWxsRnVuY3Rpb25PbicsIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKCguLi5hcmdzKSA9PiBuZXcgU2V0KGFyZ3MpKSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5CeVZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKCMzNzUpOiBSZWxlYXNlIGByZXN1bHQub2JqZWN0SWRgIGFmdGVyIHVzaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG9iamVjdElkOiByZXN1bHQub2JqZWN0SWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbFByb3h5ID0gbmV3IENoYW5uZWxQcm94eV9qc18xLkNoYW5uZWxQcm94eShsb2NhbFZhbHVlLnZhbHVlLCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxQcm94eVNlbmRNZXNzYWdlSGFuZGxlID0gYXdhaXQgY2hhbm5lbFByb3h5LmluaXQodGhpcywgdGhpcy4jZXZlbnRNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogY2hhbm5lbFByb3h5U2VuZE1lc3NhZ2VIYW5kbGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IERpc3Bvc2Ugb2YgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBvdXRzaWRlIHRvIGhhbmRsZSB1bmtub3duIHR5cGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlKX0gaXMgbm90IGRlc2VyaWFsaXphYmxlLmApO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0RXhjZXB0aW9uUmVzdWx0KGV4Y2VwdGlvbkRldGFpbHMsIGxpbmVPZmZzZXQsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhjZXB0aW9uRGV0YWlsczogYXdhaXQgdGhpcy4jc2VyaWFsaXplQ2RwRXhjZXB0aW9uRGV0YWlscyhleGNlcHRpb25EZXRhaWxzLCBsaW5lT2Zmc2V0LCByZXN1bHRPd25lcnNoaXApLFxuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIHR5cGU6ICdleGNlcHRpb24nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgI2dldFNlcmlhbGl6YXRpb25PcHRpb25zKHNlcmlhbGl6YXRpb24sIHNlcmlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uLFxuICAgICAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IFJlYWxtLiNnZXRBZGRpdGlvbmFsU2VyaWFsaXphdGlvblBhcmFtZXRlcnMoc2VyaWFsaXphdGlvbk9wdGlvbnMpLFxuICAgICAgICAgICAgLi4uUmVhbG0uI2dldE1heE9iamVjdERlcHRoKHNlcmlhbGl6YXRpb25PcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljICNnZXRBZGRpdGlvbmFsU2VyaWFsaXphdGlvblBhcmFtZXRlcnMoc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHNlcmlhbGl6YXRpb25PcHRpb25zLm1heERvbURlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzWydtYXhOb2RlRGVwdGgnXSA9XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnMubWF4RG9tRGVwdGggPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyAxMDAwXG4gICAgICAgICAgICAgICAgICAgIDogc2VyaWFsaXphdGlvbk9wdGlvbnMubWF4RG9tRGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmlhbGl6YXRpb25PcHRpb25zLmluY2x1ZGVTaGFkb3dUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzWydpbmNsdWRlU2hhZG93VHJlZSddID1cbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9ucy5pbmNsdWRlU2hhZG93VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbFBhcmFtZXRlcnM7XG4gICAgfVxuICAgIHN0YXRpYyAjZ2V0TWF4T2JqZWN0RGVwdGgoc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoID09PSBudWxsXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHsgbWF4RGVwdGg6IHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoIH07XG4gICAgfVxuICAgIGFzeW5jICNyZWxlYXNlT2JqZWN0KGhhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUucmVsZWFzZU9iamVjdCcsIHtcbiAgICAgICAgICAgICAgICBvYmplY3RJZDogaGFuZGxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBIZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBwcm9ibGVtIGlzIGluIHRoZSB1bmtub3duIGhhbmRsZXIuXG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9yIGlmIHNvLlxuICAgICAgICAgICAgaWYgKCEoZXJyb3IuY29kZSA9PT0gLTMyMDAwIC8qIENkcEVycm9yQ29uc3RhbnRzLkdFTkVSSUNfRVJST1IgKi8gJiZcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCByZW1vdGUgb2JqZWN0IGlkJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaXNvd24oaGFuZGxlKSB7XG4gICAgICAgIC8vIERpc293bmluZyBhbiBvYmplY3QgZnJvbSBkaWZmZXJlbnQgcmVhbG0gZG9lcyBub3RoaW5nLlxuICAgICAgICBpZiAodGhpcy4jcmVhbG1TdG9yYWdlLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZ2V0KGhhbmRsZSkgIT09IHRoaXMucmVhbG1JZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI3JlbGVhc2VPYmplY3QoaGFuZGxlKTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZGVsZXRlKGhhbmRsZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuI3JlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuU2NyaXB0LkV2ZW50TmFtZXMuUmVhbG1EZXN0cm95ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbUlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFsbSA9IFJlYWxtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbG0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWxtU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBXaW5kb3dSZWFsbV9qc18xID0gcmVxdWlyZShcIi4vV2luZG93UmVhbG0uanNcIik7XG4vKiogQ29udGFpbmVyIGNsYXNzIGZvciBicm93c2luZyByZWFsbXMuICovXG5jbGFzcyBSZWFsbVN0b3JhZ2Uge1xuICAgIC8qKiBUcmFja3MgaGFuZGxlcyBhbmQgdGhlaXIgcmVhbG1zIHNlbnQgdG8gdGhlIGNsaWVudC4gKi9cbiAgICAja25vd25IYW5kbGVzVG9SZWFsbU1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogTWFwIGZyb20gcmVhbG0gSUQgdG8gUmVhbG0uICovXG4gICAgI3JlYWxtTWFwID0gbmV3IE1hcCgpO1xuICAgIGdldCBrbm93bkhhbmRsZXNUb1JlYWxtTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4ja25vd25IYW5kbGVzVG9SZWFsbU1hcDtcbiAgICB9XG4gICAgYWRkUmVhbG0ocmVhbG0pIHtcbiAgICAgICAgdGhpcy4jcmVhbG1NYXAuc2V0KHJlYWxtLnJlYWxtSWQsIHJlYWxtKTtcbiAgICB9XG4gICAgLyoqIEZpbmRzIGFsbCByZWFsbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIGZpbmRSZWFsbXMoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3JlYWxtTWFwLnZhbHVlcygpKS5maWx0ZXIoKHJlYWxtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnJlYWxtSWQgIT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIucmVhbG1JZCAhPT0gcmVhbG0ucmVhbG1JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIuYnJvd3NpbmdDb250ZXh0SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICFyZWFsbS5hc3NvY2lhdGVkQnJvd3NpbmdDb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChicm93c2luZ0NvbnRleHQpID0+IGJyb3dzaW5nQ29udGV4dC5pZClcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKGZpbHRlci5icm93c2luZ0NvbnRleHRJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnNhbmRib3ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICghKHJlYWxtIGluc3RhbmNlb2YgV2luZG93UmVhbG1fanNfMS5XaW5kb3dSZWFsbSkgfHwgZmlsdGVyLnNhbmRib3ggIT09IHJlYWxtLnNhbmRib3gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci5leGVjdXRpb25Db250ZXh0SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGZpbHRlci5leGVjdXRpb25Db250ZXh0SWQgIT09IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIub3JpZ2luICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyLm9yaWdpbiAhPT0gcmVhbG0ub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci50eXBlICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyLnR5cGUgIT09IHJlYWxtLnJlYWxtVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIuY2RwU2Vzc2lvbklkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBmaWx0ZXIuY2RwU2Vzc2lvbklkICE9PSByZWFsbS5jZHBDbGllbnQuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5kUmVhbG0oZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IG1heWJlUmVhbG1zID0gdGhpcy5maW5kUmVhbG1zKGZpbHRlcik7XG4gICAgICAgIGlmIChtYXliZVJlYWxtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUmVhbG1zWzBdO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgb25seSByZWFsbSB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGZpbHRlciwgaWYgYW55LCBvdGhlcndpc2UgdGhyb3dzLiAqL1xuICAgIGdldFJlYWxtKGZpbHRlcikge1xuICAgICAgICBjb25zdCBtYXliZVJlYWxtID0gdGhpcy5maW5kUmVhbG0oZmlsdGVyKTtcbiAgICAgICAgaWYgKG1heWJlUmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRnJhbWVFeGNlcHRpb24oYFJlYWxtICR7SlNPTi5zdHJpbmdpZnkoZmlsdGVyKX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUmVhbG07XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFsbCByZWFsbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIGRlbGV0ZVJlYWxtcyhmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maW5kUmVhbG1zKGZpbHRlcikubWFwKChyZWFsbSkgPT4ge1xuICAgICAgICAgICAgcmVhbG0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy4jcmVhbG1NYXAuZGVsZXRlKHJlYWxtLnJlYWxtSWQpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFssIHJdKSA9PiByID09PSByZWFsbS5yZWFsbUlkKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtoYW5kbGVdKSA9PiB0aGlzLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZGVsZXRlKGhhbmRsZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWxtU3RvcmFnZSA9IFJlYWxtU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWxtU3RvcmFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JpcHRQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgUHJlbG9hZFNjcmlwdF9qc18xID0gcmVxdWlyZShcIi4vUHJlbG9hZFNjcmlwdC5qc1wiKTtcbmNsYXNzIFNjcmlwdFByb2Nlc3NvciB7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjcmVhbG1TdG9yYWdlO1xuICAgICNwcmVsb2FkU2NyaXB0U3RvcmFnZTtcbiAgICAjbG9nZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgcmVhbG1TdG9yYWdlLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UgPSByZWFsbVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlID0gcHJlbG9hZFNjcmlwdFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIuYWRkU3Vic2NyaWJlSG9vayhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5SZWFsbUNyZWF0ZWQsIHRoaXMuI29uUmVhbG1DcmVhdGVkU3Vic2NyaWJlSG9vay5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgI29uUmVhbG1DcmVhdGVkU3Vic2NyaWJlSG9vayhjb250ZXh0SWQpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xuICAgICAgICBjb25zdCBjb250ZXh0c1RvUmVwb3J0ID0gW1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIC4uLnRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpLmFsbENoaWxkcmVuLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZWFsbXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVwb3J0Q29udGV4dCBvZiBjb250ZXh0c1RvUmVwb3J0KSB7XG4gICAgICAgICAgICBjb25zdCByZWFsbXNGb3JDb250ZXh0ID0gdGhpcy4jcmVhbG1TdG9yYWdlLmZpbmRSZWFsbXMoe1xuICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiByZXBvcnRDb250ZXh0LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWxtIG9mIHJlYWxtc0ZvckNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZWFsbXMuYWRkKHJlYWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJlYWxtIG9mIHJlYWxtcykge1xuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5SZWFsbUNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiByZWFsbS5yZWFsbUluZm8sXG4gICAgICAgICAgICB9LCBjb250ZXh0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHRzID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS52ZXJpZnlUb3BMZXZlbENvbnRleHRzTGlzdChwYXJhbXMuY29udGV4dHMpO1xuICAgICAgICBjb25zdCBwcmVsb2FkU2NyaXB0ID0gbmV3IFByZWxvYWRTY3JpcHRfanNfMS5QcmVsb2FkU2NyaXB0KHBhcmFtcywgdGhpcy4jbG9nZ2VyKTtcbiAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UuYWRkKHByZWxvYWRTY3JpcHQpO1xuICAgICAgICBjb25zdCBjZHBUYXJnZXRzID0gY29udGV4dHMuc2l6ZSA9PT0gMFxuICAgICAgICAgICAgPyBuZXcgU2V0KHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2VcbiAgICAgICAgICAgICAgICAuZ2V0VG9wTGV2ZWxDb250ZXh0cygpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29udGV4dCkgPT4gY29udGV4dC5jZHBUYXJnZXQpKVxuICAgICAgICAgICAgOiBuZXcgU2V0KFsuLi5jb250ZXh0cy52YWx1ZXMoKV0ubWFwKChjb250ZXh0KSA9PiBjb250ZXh0LmNkcFRhcmdldCkpO1xuICAgICAgICBhd2FpdCBwcmVsb2FkU2NyaXB0LmluaXRJblRhcmdldHMoY2RwVGFyZ2V0cywgZmFsc2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0OiBwcmVsb2FkU2NyaXB0LmlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVQcmVsb2FkU2NyaXB0KHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHNjcmlwdDogaWQgfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qgc2NyaXB0cyA9IHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlLmZpbmQoeyBpZCB9KTtcbiAgICAgICAgaWYgKHNjcmlwdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hTY3JpcHRFeGNlcHRpb24oYE5vIHByZWxvYWQgc2NyaXB0IHdpdGggaWQgJyR7aWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKChzY3JpcHQpID0+IHNjcmlwdC5yZW1vdmUoKSkpO1xuICAgICAgICB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZS5yZW1vdmUoeyBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBjYWxsRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gYXdhaXQgdGhpcy4jZ2V0UmVhbG0ocGFyYW1zLnRhcmdldCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFsbS5jYWxsRnVuY3Rpb24ocGFyYW1zLmZ1bmN0aW9uRGVjbGFyYXRpb24sIHBhcmFtcy5hd2FpdFByb21pc2UsIHBhcmFtcy50aGlzLCBwYXJhbXMuYXJndW1lbnRzLCBwYXJhbXMucmVzdWx0T3duZXJzaGlwLCBwYXJhbXMuc2VyaWFsaXphdGlvbk9wdGlvbnMsIHBhcmFtcy51c2VyQWN0aXZhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZWFsbSA9IGF3YWl0IHRoaXMuI2dldFJlYWxtKHBhcmFtcy50YXJnZXQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhbG0uZXZhbHVhdGUocGFyYW1zLmV4cHJlc3Npb24sIHBhcmFtcy5hd2FpdFByb21pc2UsIHBhcmFtcy5yZXN1bHRPd25lcnNoaXAsIHBhcmFtcy5zZXJpYWxpemF0aW9uT3B0aW9ucywgcGFyYW1zLnVzZXJBY3RpdmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzb3duKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZWFsbSA9IGF3YWl0IHRoaXMuI2dldFJlYWxtKHBhcmFtcy50YXJnZXQpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwYXJhbXMuaGFuZGxlcy5tYXAoYXN5bmMgKGhhbmRsZSkgPT4gYXdhaXQgcmVhbG0uZGlzb3duKGhhbmRsZSkpKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBnZXRSZWFsbXMocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRleHQgaXMga25vd24uXG4gICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWxtcyA9IHRoaXMuI3JlYWxtU3RvcmFnZVxuICAgICAgICAgICAgLmZpbmRSZWFsbXMoe1xuICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0SWQ6IHBhcmFtcy5jb250ZXh0LFxuICAgICAgICAgICAgdHlwZTogcGFyYW1zLnR5cGUsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKChyZWFsbSkgPT4gcmVhbG0ucmVhbG1JbmZvKTtcbiAgICAgICAgcmV0dXJuIHsgcmVhbG1zIH07XG4gICAgfVxuICAgIGFzeW5jICNnZXRSZWFsbSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCdjb250ZXh0JyBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQodGFyZ2V0LmNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnRleHQuZ2V0T3JDcmVhdGVTYW5kYm94KHRhcmdldC5zYW5kYm94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jcmVhbG1TdG9yYWdlLmdldFJlYWxtKHtcbiAgICAgICAgICAgIHJlYWxtSWQ6IHRhcmdldC5yZWFsbSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TY3JpcHRQcm9jZXNzb3IgPSBTY3JpcHRQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY3JpcHRQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTaGFyZWRJZCA9IGdldFNoYXJlZElkO1xuZXhwb3J0cy5wYXJzZVNoYXJlZElkID0gcGFyc2VTaGFyZWRJZDtcbmNvbnN0IFNIQVJFRF9JRF9ESVZJREVSID0gJ19lbGVtZW50Xyc7XG5mdW5jdGlvbiBnZXRTaGFyZWRJZChmcmFtZUlkLCBkb2N1bWVudElkLCBiYWNrZW5kTm9kZUlkKSB7XG4gICAgcmV0dXJuIGBmLiR7ZnJhbWVJZH0uZC4ke2RvY3VtZW50SWR9LmUuJHtiYWNrZW5kTm9kZUlkfWA7XG59XG5mdW5jdGlvbiBwYXJzZUxlZ2FjeVNoYXJlZElkKHNoYXJlZElkKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBzaGFyZWRJZC5tYXRjaChuZXcgUmVnRXhwKGAoLiopJHtTSEFSRURfSURfRElWSURFUn0oLiopYCkpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgLy8gU2hhcmVkSWQgaXMgaW5jb3JyZWN0bHkgZm9ybWF0dGVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZG9jdW1lbnRJZCA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IGVsZW1lbnRJZCA9IG1hdGNoWzJdO1xuICAgIGlmIChkb2N1bWVudElkID09PSB1bmRlZmluZWQgfHwgZWxlbWVudElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJhY2tlbmROb2RlSWQgPSBwYXJzZUludChlbGVtZW50SWQgPz8gJycpO1xuICAgIGlmIChpc05hTihiYWNrZW5kTm9kZUlkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG9jdW1lbnRJZCxcbiAgICAgICAgYmFja2VuZE5vZGVJZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VTaGFyZWRJZChzaGFyZWRJZCkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBsZWdhY3kgY2hlY2sgb25jZSBDaHJvbWVEcml2ZXIgcHJvdmlkZXMgc2hhcmVkSWQgaW4gdGhlIG5ldyBmb3JtYXQuXG4gICAgY29uc3QgbGVnYWN5Rm9ybWF0dGVkU2hhcmVkSWQgPSBwYXJzZUxlZ2FjeVNoYXJlZElkKHNoYXJlZElkKTtcbiAgICBpZiAobGVnYWN5Rm9ybWF0dGVkU2hhcmVkSWQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubGVnYWN5Rm9ybWF0dGVkU2hhcmVkSWQsIGZyYW1lSWQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHNoYXJlZElkLm1hdGNoKC9mXFwuKC4qKVxcLmRcXC4oLiopXFwuZVxcLihbMC05XSopLyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAvLyBTaGFyZWRJZCBpcyBpbmNvcnJlY3RseSBmb3JtYXR0ZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZUlkID0gbWF0Y2hbMV07XG4gICAgY29uc3QgZG9jdW1lbnRJZCA9IG1hdGNoWzJdO1xuICAgIGNvbnN0IGVsZW1lbnRJZCA9IG1hdGNoWzNdO1xuICAgIGlmIChmcmFtZUlkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZG9jdW1lbnRJZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGVsZW1lbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBiYWNrZW5kTm9kZUlkID0gcGFyc2VJbnQoZWxlbWVudElkID8/ICcnKTtcbiAgICBpZiAoaXNOYU4oYmFja2VuZE5vZGVJZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZyYW1lSWQsXG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYXJlZElkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpbmRvd1JlYWxtID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IFJlYWxtX2pzXzEgPSByZXF1aXJlKFwiLi9SZWFsbS5qc1wiKTtcbmNvbnN0IFNoYXJlZElkX2pzXzEgPSByZXF1aXJlKFwiLi9TaGFyZWRJZC5qc1wiKTtcbmNsYXNzIFdpbmRvd1JlYWxtIGV4dGVuZHMgUmVhbG1fanNfMS5SZWFsbSB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dElkO1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgIHNhbmRib3g7XG4gICAgY29uc3RydWN0b3IoYnJvd3NpbmdDb250ZXh0SWQsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIGNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBleGVjdXRpb25Db250ZXh0SWQsIGxvZ2dlciwgb3JpZ2luLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UsIHNhbmRib3gpIHtcbiAgICAgICAgc3VwZXIoY2RwQ2xpZW50LCBldmVudE1hbmFnZXIsIGV4ZWN1dGlvbkNvbnRleHRJZCwgbG9nZ2VyLCBvcmlnaW4sIHJlYWxtSWQsIHJlYWxtU3RvcmFnZSk7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dElkID0gYnJvd3NpbmdDb250ZXh0SWQ7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLnNhbmRib3ggPSBzYW5kYm94O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgI2dldEJyb3dzaW5nQ29udGV4dElkKG5hdmlnYWJsZUlkKSB7XG4gICAgICAgIGNvbnN0IG1heWJlQnJvd3NpbmdDb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZVxuICAgICAgICAgICAgLmdldEFsbENvbnRleHRzKClcbiAgICAgICAgICAgIC5maW5kKChjb250ZXh0KSA9PiBjb250ZXh0Lm5hdmlnYWJsZUlkID09PSBuYXZpZ2FibGVJZCk7XG4gICAgICAgIHJldHVybiBtYXliZUJyb3dzaW5nQ29udGV4dD8uaWQgPz8gJ1VOS05PV04nO1xuICAgIH1cbiAgICBnZXQgYnJvd3NpbmdDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHRoaXMuI2Jyb3dzaW5nQ29udGV4dElkKTtcbiAgICB9XG4gICAgZ2V0IGFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuYnJvd3NpbmdDb250ZXh0XTtcbiAgICB9XG4gICAgZ2V0IHJlYWxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICd3aW5kb3cnO1xuICAgIH1cbiAgICBnZXQgcmVhbG1JbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5iYXNlSW5mbyxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMucmVhbG1UeXBlLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy4jYnJvd3NpbmdDb250ZXh0SWQsXG4gICAgICAgICAgICBzYW5kYm94OiB0aGlzLnNhbmRib3gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbUlkLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5icm93c2luZ0NvbnRleHQuaWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZUZvckJpRGkoZGVlcFNlcmlhbGl6ZWRWYWx1ZSwgaW50ZXJuYWxJZE1hcCkge1xuICAgICAgICBjb25zdCBiaWRpVmFsdWUgPSBkZWVwU2VyaWFsaXplZFZhbHVlLnZhbHVlO1xuICAgICAgICBpZiAoZGVlcFNlcmlhbGl6ZWRWYWx1ZS50eXBlID09PSAnbm9kZScgJiYgYmlkaVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGJpZGlWYWx1ZSwgJ2JhY2tlbmROb2RlSWQnKSkge1xuICAgICAgICAgICAgICAgIGxldCBuYXZpZ2FibGVJZCA9IHRoaXMuYnJvd3NpbmdDb250ZXh0Lm5hdmlnYWJsZUlkID8/ICdVTktOT1dOJztcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihiaWRpVmFsdWUsICdsb2FkZXJJZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBsb2FkZXJJZGAgc2hvdWxkIGJlIGFsd2F5cyB0aGVyZSBhZnRlciB+MjAyNC0wMy0wNSwgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NycmV2LmNvbS9jLzUxMTYyNDAgcmVhY2hlcyBzdGFibGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGUgY2hlY2sgYWZ0ZXIgdGhlIGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYWJsZUlkID0gYmlkaVZhbHVlLmxvYWRlcklkO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYmlkaVZhbHVlWydsb2FkZXJJZCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWVwU2VyaWFsaXplZFZhbHVlLnNoYXJlZElkID1cbiAgICAgICAgICAgICAgICAgICAgKDAsIFNoYXJlZElkX2pzXzEuZ2V0U2hhcmVkSWQpKHRoaXMuI2dldEJyb3dzaW5nQ29udGV4dElkKG5hdmlnYWJsZUlkKSwgbmF2aWdhYmxlSWQsIGJpZGlWYWx1ZS5iYWNrZW5kTm9kZUlkKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgYmlkaVZhbHVlWydiYWNrZW5kTm9kZUlkJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihiaWRpVmFsdWUsICdjaGlsZHJlbicpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGJpZGlWYWx1ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBiaWRpVmFsdWUuY2hpbGRyZW5baV0gPSB0aGlzLnNlcmlhbGl6ZUZvckJpRGkoYmlkaVZhbHVlLmNoaWxkcmVuW2ldLCBpbnRlcm5hbElkTWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihiaWRpVmFsdWUsICdzaGFkb3dSb290JykgJiZcbiAgICAgICAgICAgICAgICBiaWRpVmFsdWUuc2hhZG93Um9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJpZGlWYWx1ZS5zaGFkb3dSb290ID0gdGhpcy5zZXJpYWxpemVGb3JCaURpKGJpZGlWYWx1ZS5zaGFkb3dSb290LCBpbnRlcm5hbElkTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGBuYW1lc3BhY2VVUklgIGNhbiBiZSBpcyBlaXRoZXIgYG51bGxgIG9yIG5vbi1lbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBpZiAoYmlkaVZhbHVlLm5hbWVzcGFjZVVSSSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBiaWRpVmFsdWUubmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuc2VyaWFsaXplRm9yQmlEaShkZWVwU2VyaWFsaXplZFZhbHVlLCBpbnRlcm5hbElkTWFwKTtcbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemVGb3JDZHAobG9jYWxWYWx1ZSkge1xuICAgICAgICBpZiAoJ3NoYXJlZElkJyBpbiBsb2NhbFZhbHVlICYmIGxvY2FsVmFsdWUuc2hhcmVkSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNoYXJlZElkID0gKDAsIFNoYXJlZElkX2pzXzEucGFyc2VTaGFyZWRJZCkobG9jYWxWYWx1ZS5zaGFyZWRJZCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkU2hhcmVkSWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hOb2RlRXhjZXB0aW9uKGBTaGFyZWRJZCBcIiR7bG9jYWxWYWx1ZS5zaGFyZWRJZH1cIiB3YXMgbm90IGZvdW5kLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudElkLCBiYWNrZW5kTm9kZUlkIH0gPSBwYXJzZWRTaGFyZWRJZDtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBwcm9wZXIgdmFsaWRhdGlvbiBpZiB0aGUgZWxlbWVudCBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGN1cnJlbnQgcmVhbG0uXG4gICAgICAgICAgICBpZiAodGhpcy5icm93c2luZ0NvbnRleHQubmF2aWdhYmxlSWQgIT09IGRvY3VtZW50SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hOb2RlRXhjZXB0aW9uKGBTaGFyZWRJZCBcIiR7bG9jYWxWYWx1ZS5zaGFyZWRJZH1cIiBiZWxvbmdzIHRvIGRpZmZlcmVudCBkb2N1bWVudC4gQ3VycmVudCBkb2N1bWVudCBpcyAke3RoaXMuYnJvd3NpbmdDb250ZXh0Lm5hdmlnYWJsZUlkfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdET00ucmVzb2x2ZU5vZGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjMzc1KTogUmVsZWFzZSBgb2JqLm9iamVjdC5vYmplY3RJZGAgYWZ0ZXIgdXNpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IG9iamVjdC5vYmplY3RJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSGV1cmlzdGljIHRvIGRldGVjdCBcIm5vIHN1Y2ggbm9kZVwiIGV4Y2VwdGlvbi4gQmFzZWQgb24gdGhlICBzcGVjaWZpY1xuICAgICAgICAgICAgICAgIC8vIENEUCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gLTMyMDAwIC8qIENkcEVycm9yQ29uc3RhbnRzLkdFTkVSSUNfRVJST1IgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ05vIG5vZGUgd2l0aCBnaXZlbiBpZCBmb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoTm9kZUV4Y2VwdGlvbihgU2hhcmVkSWQgXCIke2xvY2FsVmFsdWUuc2hhcmVkSWR9XCIgd2FzIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemVGb3JDZHAobG9jYWxWYWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlKGV4cHJlc3Npb24sIGF3YWl0UHJvbWlzZSwgcmVzdWx0T3duZXJzaGlwLCBzZXJpYWxpemF0aW9uT3B0aW9ucywgdXNlckFjdGl2YXRpb24sIGluY2x1ZGVDb21tYW5kTGluZUFwaSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlXG4gICAgICAgICAgICAuZ2V0Q29udGV4dCh0aGlzLiNicm93c2luZ0NvbnRleHRJZClcbiAgICAgICAgICAgIC50YXJnZXRVbmJsb2NrZWRPclRocm93KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5ldmFsdWF0ZShleHByZXNzaW9uLCBhd2FpdFByb21pc2UsIHJlc3VsdE93bmVyc2hpcCwgc2VyaWFsaXphdGlvbk9wdGlvbnMsIHVzZXJBY3RpdmF0aW9uLCBpbmNsdWRlQ29tbWFuZExpbmVBcGkpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgYXdhaXRQcm9taXNlLCB0aGlzTG9jYWxWYWx1ZSwgYXJndW1lbnRzTG9jYWxWYWx1ZXMsIHJlc3VsdE93bmVyc2hpcCwgc2VyaWFsaXphdGlvbk9wdGlvbnMsIHVzZXJBY3RpdmF0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2VcbiAgICAgICAgICAgIC5nZXRDb250ZXh0KHRoaXMuI2Jyb3dzaW5nQ29udGV4dElkKVxuICAgICAgICAgICAgLnRhcmdldFVuYmxvY2tlZE9yVGhyb3coKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLmNhbGxGdW5jdGlvbihmdW5jdGlvbkRlY2xhcmF0aW9uLCBhd2FpdFByb21pc2UsIHRoaXNMb2NhbFZhbHVlLCBhcmd1bWVudHNMb2NhbFZhbHVlcywgcmVzdWx0T3duZXJzaGlwLCBzZXJpYWxpemF0aW9uT3B0aW9ucywgdXNlckFjdGl2YXRpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuV2luZG93UmVhbG0gPSBXaW5kb3dSZWFsbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpbmRvd1JlYWxtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmtlclJlYWxtID0gdm9pZCAwO1xuY29uc3QgUmVhbG1fanNfMSA9IHJlcXVpcmUoXCIuL1JlYWxtLmpzXCIpO1xuY2xhc3MgV29ya2VyUmVhbG0gZXh0ZW5kcyBSZWFsbV9qc18xLlJlYWxtIHtcbiAgICAjcmVhbG1UeXBlO1xuICAgICNvd25lclJlYWxtcztcbiAgICBjb25zdHJ1Y3RvcihjZHBDbGllbnQsIGV2ZW50TWFuYWdlciwgZXhlY3V0aW9uQ29udGV4dElkLCBsb2dnZXIsIG9yaWdpbiwgb3duZXJSZWFsbXMsIHJlYWxtSWQsIHJlYWxtU3RvcmFnZSwgcmVhbG1UeXBlKSB7XG4gICAgICAgIHN1cGVyKGNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBleGVjdXRpb25Db250ZXh0SWQsIGxvZ2dlciwgb3JpZ2luLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UpO1xuICAgICAgICB0aGlzLiNvd25lclJlYWxtcyA9IG93bmVyUmVhbG1zO1xuICAgICAgICB0aGlzLiNyZWFsbVR5cGUgPSByZWFsbVR5cGU7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBnZXQgYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNvd25lclJlYWxtcy5mbGF0TWFwKChyZWFsbSkgPT4gcmVhbG0uYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMpO1xuICAgIH1cbiAgICBnZXQgcmVhbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVhbG1UeXBlO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2UgUHVwcGV0ZWVyIGFibGUgdG8gdHJhY2sgd29ya2Vycy5cbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBhZnRlciBQdXBwZXRlZXIgdHJhY2tzIHdvcmtlcnMgYnkgb3duZXJzIGFuZCB1c2UgdGhlIGJhc2UgdmVyc2lvbi5cbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHNbMF0/LmlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgcmVhbG1JbmZvKCkge1xuICAgICAgICBjb25zdCBvd25lcnMgPSB0aGlzLiNvd25lclJlYWxtcy5tYXAoKHJlYWxtKSA9PiByZWFsbS5yZWFsbUlkKTtcbiAgICAgICAgY29uc3QgeyByZWFsbVR5cGUgfSA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAocmVhbG1UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkZWRpY2F0ZWQtd29ya2VyJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gb3duZXJzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChvd25lciA9PT0gdW5kZWZpbmVkIHx8IG93bmVycy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWRpY2F0ZWQgd29ya2VyIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBvd25lcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmJhc2VJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWFsbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyczogW293bmVyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2VydmljZS13b3JrZXInOlxuICAgICAgICAgICAgY2FzZSAnc2hhcmVkLXdvcmtlcic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmJhc2VJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWFsbVR5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV29ya2VyUmVhbG0gPSBXb3JrZXJSZWFsbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdvcmtlclJlYWxtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBCdWZmZXJfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9CdWZmZXIuanNcIik7XG5jb25zdCBEZWZhdWx0TWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRGVmYXVsdE1hcC5qc1wiKTtcbmNvbnN0IERpc3RpbmN0VmFsdWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRGlzdGluY3RWYWx1ZXMuanNcIik7XG5jb25zdCBFdmVudEVtaXR0ZXJfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9FdmVudEVtaXR0ZXIuanNcIik7XG5jb25zdCBJZFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9JZFdyYXBwZXIuanNcIik7XG5jb25zdCBPdXRnb2luZ01lc3NhZ2VfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9PdXRnb2luZ01lc3NhZ2UuanNcIik7XG5jb25zdCBldmVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50cy5qc1wiKTtcbmNvbnN0IFN1YnNjcmlwdGlvbk1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuL1N1YnNjcmlwdGlvbk1hbmFnZXIuanNcIik7XG5jbGFzcyBFdmVudFdyYXBwZXIge1xuICAgICNpZFdyYXBwZXIgPSBuZXcgSWRXcmFwcGVyX2pzXzEuSWRXcmFwcGVyKCk7XG4gICAgI2NvbnRleHRJZDtcbiAgICAjZXZlbnQ7XG4gICAgY29uc3RydWN0b3IoZXZlbnQsIGNvbnRleHRJZCkge1xuICAgICAgICB0aGlzLiNldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLiNjb250ZXh0SWQgPSBjb250ZXh0SWQ7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkV3JhcHBlci5pZDtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbnRleHRJZDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQ7XG4gICAgfVxufVxuLyoqXG4gKiBNYXBzIGV2ZW50IG5hbWUgdG8gYSBkZXNpcmVkIGJ1ZmZlciBsZW5ndGguXG4gKi9cbmNvbnN0IGV2ZW50QnVmZmVyTGVuZ3RoID0gbmV3IE1hcChbW3Byb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzLkxvZ0VudHJ5QWRkZWQsIDEwMF1dKTtcbmNsYXNzIEV2ZW50TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlcl9qc18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogTWFwcyBldmVudCBuYW1lIHRvIGEgc2V0IG9mIGNvbnRleHRzIHdoZXJlIHRoaXMgZXZlbnQgYWxyZWFkeSBoYXBwZW5lZC5cbiAgICAgKiBOZWVkZWQgZm9yIGdldHRpbmcgYnVmZmVyZWQgZXZlbnRzIGZyb20gYWxsIHRoZSBjb250ZXh0cyBpbiBjYXNlIG9mXG4gICAgICogc3Vic2NyaXB0aW5nIHRvIGFsbCBjb250ZXh0cy5cbiAgICAgKi9cbiAgICAjZXZlbnRUb0NvbnRleHRzTWFwID0gbmV3IERlZmF1bHRNYXBfanNfMS5EZWZhdWx0TWFwKCgpID0+IG5ldyBTZXQoKSk7XG4gICAgLyoqXG4gICAgICogTWFwcyBgZXZlbnROYW1lYCArIGBicm93c2luZ0NvbnRleHRgIHRvIGJ1ZmZlci4gVXNlZCB0byBnZXQgYnVmZmVyZWQgZXZlbnRzXG4gICAgICogZHVyaW5nIHN1YnNjcmlwdGlvbi4gQ2hhbm5lbC1hZ25vc3RpYy5cbiAgICAgKi9cbiAgICAjZXZlbnRCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIE1hcHMgYGV2ZW50TmFtZWAgKyBgYnJvd3NpbmdDb250ZXh0YCArIGBjaGFubmVsYCB0byBsYXN0IHNlbnQgZXZlbnQgaWQuXG4gICAgICogVXNlZCB0byBhdm9pZCBzZW5kaW5nIGR1cGxpY2F0ZWQgZXZlbnRzIHdoZW4gdXNlclxuICAgICAqIHN1YnNjcmliZXMgLT4gdW5zdWJzY3JpYmVzIC0+IHN1YnNjcmliZXMuXG4gICAgICovXG4gICAgI2xhc3RNZXNzYWdlU2VudCA9IG5ldyBNYXAoKTtcbiAgICAjc3Vic2NyaXB0aW9uTWFuYWdlcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAvKipcbiAgICAgKiBNYXAgb2YgZXZlbnQgbmFtZSB0byBob29rcyB0byBiZSBjYWxsZWQgd2hlbiBjbGllbnQgaXMgc3Vic2NyaWJlZCB0byB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgI3N1YnNjcmliZUhvb2tzO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3N1YnNjcmlwdGlvbk1hbmFnZXIgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcl9qc18xLlN1YnNjcmlwdGlvbk1hbmFnZXIoYnJvd3NpbmdDb250ZXh0U3RvcmFnZSk7XG4gICAgICAgIHRoaXMuI3N1YnNjcmliZUhvb2tzID0gbmV3IERlZmF1bHRNYXBfanNfMS5EZWZhdWx0TWFwKCgpID0+IFtdKTtcbiAgICB9XG4gICAgZ2V0IHN1YnNjcmlwdGlvbk1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzY3JpcHRpb25NYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnNpc3RlbnQga2V5IHRvIGJlIHVzZWQgdG8gYWNjZXNzIHZhbHVlIG1hcHMuXG4gICAgICovXG4gICAgc3RhdGljICNnZXRNYXBLZXkoZXZlbnROYW1lLCBicm93c2luZ0NvbnRleHQsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgZXZlbnROYW1lLCBicm93c2luZ0NvbnRleHQsIGNoYW5uZWwgfSk7XG4gICAgfVxuICAgIGFkZFN1YnNjcmliZUhvb2soZXZlbnQsIGhvb2spIHtcbiAgICAgICAgdGhpcy4jc3Vic2NyaWJlSG9va3MuZ2V0KGV2ZW50KS5wdXNoKGhvb2spO1xuICAgIH1cbiAgICByZWdpc3RlckV2ZW50KGV2ZW50LCBjb250ZXh0SWQpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclByb21pc2VFdmVudChQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAga2luZDogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LFxuICAgICAgICB9KSwgY29udGV4dElkLCBldmVudC5tZXRob2QpO1xuICAgIH1cbiAgICByZWdpc3RlclByb21pc2VFdmVudChldmVudCwgY29udGV4dElkLCBldmVudE5hbWUpIHtcbiAgICAgICAgY29uc3QgZXZlbnRXcmFwcGVyID0gbmV3IEV2ZW50V3JhcHBlcihldmVudCwgY29udGV4dElkKTtcbiAgICAgICAgY29uc3Qgc29ydGVkQ2hhbm5lbHMgPSB0aGlzLiNzdWJzY3JpcHRpb25NYW5hZ2VyLmdldENoYW5uZWxzU3Vic2NyaWJlZFRvRXZlbnQoZXZlbnROYW1lLCBjb250ZXh0SWQpO1xuICAgICAgICB0aGlzLiNidWZmZXJFdmVudChldmVudFdyYXBwZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgIC8vIFNlbmQgZXZlbnRzIHRvIGNoYW5uZWxzIGluIHRoZSBzdWJzY3JpcHRpb24gcHJpb3JpdHkuXG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBzb3J0ZWRDaGFubmVscykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiAvKiBFdmVudE1hbmFnZXJFdmVudHMuRXZlbnQgKi8sIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBPdXRnb2luZ01lc3NhZ2VfanNfMS5PdXRnb2luZ01lc3NhZ2UuY3JlYXRlRnJvbVByb21pc2UoZXZlbnQsIGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI21hcmtFdmVudFNlbnQoZXZlbnRXcmFwcGVyLCBjaGFubmVsLCBldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShldmVudE5hbWVzLCBjb250ZXh0SWRzLCBjaGFubmVsKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBldmVudE5hbWVzKSB7XG4gICAgICAgICAgICAoMCwgZXZlbnRzX2pzXzEuYXNzZXJ0U3VwcG9ydGVkRXZlbnQpKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGFsbCB0aGUgY29udGV4dHMgYXJlIGtub3duLlxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRleHRJZCBvZiBjb250ZXh0SWRzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzZXJ0IHRoZSBjb250ZXh0IGlzIGtub3duLiBUaHJvdyBleGNlcHRpb24gb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExpc3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBpdGVtcyB0aGF0IHdlcmUgYWN0dWFsbHkgYWRkZWQuIEVhY2ggY29udGFpbnMgYSBzcGVjaWZpY1xuICAgICAgICAvLyBldmVudCBhbmQgY29udGV4dC4gTm8gZG9tYWluIGV2ZW50IChsaWtlIFwibmV0d29ya1wiKSBvciBnbG9iYWwgY29udGV4dCBzdWJzY3JpcHRpb25cbiAgICAgICAgLy8gKGxpa2UgbnVsbCkgYXJlIGluY2x1ZGVkLlxuICAgICAgICBjb25zdCBhZGRlZFN1YnNjcmlwdGlvbkl0ZW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGV4dElkIG9mIGNvbnRleHRJZHMpIHtcbiAgICAgICAgICAgICAgICBhZGRlZFN1YnNjcmlwdGlvbkl0ZW1zLnB1c2goLi4udGhpcy4jc3Vic2NyaXB0aW9uTWFuYWdlci5zdWJzY3JpYmUoZXZlbnROYW1lLCBjb250ZXh0SWQsIGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50V3JhcHBlciBvZiB0aGlzLiNnZXRCdWZmZXJlZEV2ZW50cyhldmVudE5hbWUsIGNvbnRleHRJZCwgY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHRoZSBldmVudHMgaXMgaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJldmVudFwiIC8qIEV2ZW50TWFuYWdlckV2ZW50cy5FdmVudCAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogT3V0Z29pbmdNZXNzYWdlX2pzXzEuT3V0Z29pbmdNZXNzYWdlLmNyZWF0ZUZyb21Qcm9taXNlKGV2ZW50V3JhcHBlci5ldmVudCwgY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbWFya0V2ZW50U2VudChldmVudFdyYXBwZXIsIGNoYW5uZWwsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbmV3IHN1YnNjcmlwdGlvbiBpdGVtcyBhbmQgY2FsbCBob29rcyBpZiBhbnkuIFRoZXJlIGNhbiBiZVxuICAgICAgICAvLyBkdXBsaWNhdGVzLCBlLmcuIHdoZW4gc3Vic2NyaWJpbmcgdG8gdGhlIHdob2xlIGRvbWFpbiBhbmQgc29tZSBzcGVjaWZpYyBldmVudCBpblxuICAgICAgICAvLyB0aGUgc2FtZSB0aW1lIChcIm5ldHdvcmtcIiwgXCJuZXR3b3JrLnJlc3BvbnNlQ29tcGxldGVkXCIpLiBgZGlzdGluY3RWYWx1ZXNgIGd1YXJhbnRlZXNcbiAgICAgICAgLy8gdGhhdCBob29rcyBhcmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgcGFpciBldmVudCArIGNvbnRleHQuXG4gICAgICAgICgwLCBEaXN0aW5jdFZhbHVlc19qc18xLmRpc3RpbmN0VmFsdWVzKShhZGRlZFN1YnNjcmlwdGlvbkl0ZW1zKS5mb3JFYWNoKCh7IGNvbnRleHRJZCwgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jc3Vic2NyaWJlSG9va3MuZ2V0KGV2ZW50KS5mb3JFYWNoKChob29rKSA9PiBob29rKGNvbnRleHRJZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVNb2R1bGVzSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUoZXZlbnROYW1lcywgY29udGV4dElkcywgY2hhbm5lbCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZXZlbnROYW1lcykge1xuICAgICAgICAgICAgKDAsIGV2ZW50c19qc18xLmFzc2VydFN1cHBvcnRlZEV2ZW50KShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzdWJzY3JpcHRpb25NYW5hZ2VyLnVuc3Vic2NyaWJlQWxsKGV2ZW50TmFtZXMsIGNvbnRleHRJZHMsIGNoYW5uZWwpO1xuICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZU1vZHVsZXNJZk5lZWRlZCgpO1xuICAgIH1cbiAgICBhc3luYyB0b2dnbGVNb2R1bGVzSWZOZWVkZWQoKSB7XG4gICAgICAgIC8vIFRPRE8oMSk6IE9ubHkgdXBkYXRlIGNoYW5nZWQgc3Vic2NyaWJlcnNcbiAgICAgICAgLy8gVE9ETygyKTogRW5hYmxlIGZvciBXb3JrZXIgVGFyZ2V0c1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldEFsbENvbnRleHRzKCkubWFwKGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY29udGV4dC50b2dnbGVNb2R1bGVzSWZOZWVkZWQoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgYnVmZmVyLWFibGUsIHB1dCBpdCBpbiB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgICNidWZmZXJFdmVudChldmVudFdyYXBwZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50QnVmZmVyTGVuZ3RoLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBldmVudCBpcyBubyBidWZmZXItYWJsZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXJNYXBLZXkgPSBFdmVudE1hbmFnZXIuI2dldE1hcEtleShldmVudE5hbWUsIGV2ZW50V3JhcHBlci5jb250ZXh0SWQpO1xuICAgICAgICBpZiAoIXRoaXMuI2V2ZW50QnVmZmVycy5oYXMoYnVmZmVyTWFwS2V5KSkge1xuICAgICAgICAgICAgdGhpcy4jZXZlbnRCdWZmZXJzLnNldChidWZmZXJNYXBLZXksIG5ldyBCdWZmZXJfanNfMS5CdWZmZXIoZXZlbnRCdWZmZXJMZW5ndGguZ2V0KGV2ZW50TmFtZSkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNldmVudEJ1ZmZlcnMuZ2V0KGJ1ZmZlck1hcEtleSkuYWRkKGV2ZW50V3JhcHBlcik7XG4gICAgICAgIC8vIEFkZCB0aGUgY29udGV4dCB0byB0aGUgbGlzdCBvZiBjb250ZXh0cyBoYXZpbmcgYGV2ZW50TmFtZWAgZXZlbnRzLlxuICAgICAgICB0aGlzLiNldmVudFRvQ29udGV4dHNNYXAuZ2V0KGV2ZW50TmFtZSkuYWRkKGV2ZW50V3JhcHBlci5jb250ZXh0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgYnVmZmVyLWFibGUsIG1hcmsgaXQgYXMgc2VudCB0byB0aGUgZ2l2ZW4gY29udGV4dElkIGFuZCBjaGFubmVsLlxuICAgICAqL1xuICAgICNtYXJrRXZlbnRTZW50KGV2ZW50V3JhcHBlciwgY2hhbm5lbCwgZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnRCdWZmZXJMZW5ndGguaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGV2ZW50IGlzIG5vIGJ1ZmZlci1hYmxlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RTZW50TWFwS2V5ID0gRXZlbnRNYW5hZ2VyLiNnZXRNYXBLZXkoZXZlbnROYW1lLCBldmVudFdyYXBwZXIuY29udGV4dElkLCBjaGFubmVsKTtcbiAgICAgICAgdGhpcy4jbGFzdE1lc3NhZ2VTZW50LnNldChsYXN0U2VudE1hcEtleSwgTWF0aC5tYXgodGhpcy4jbGFzdE1lc3NhZ2VTZW50LmdldChsYXN0U2VudE1hcEtleSkgPz8gMCwgZXZlbnRXcmFwcGVyLmlkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZXZlbnRzIHdoaWNoIGFyZSBidWZmZXJlZCBhbmQgbm90IHlldCBzZW50IHRvIHRoZSBnaXZlbiBjaGFubmVsIGV2ZW50cy5cbiAgICAgKi9cbiAgICAjZ2V0QnVmZmVyZWRFdmVudHMoZXZlbnROYW1lLCBjb250ZXh0SWQsIGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyTWFwS2V5ID0gRXZlbnRNYW5hZ2VyLiNnZXRNYXBLZXkoZXZlbnROYW1lLCBjb250ZXh0SWQpO1xuICAgICAgICBjb25zdCBsYXN0U2VudE1hcEtleSA9IEV2ZW50TWFuYWdlci4jZ2V0TWFwS2V5KGV2ZW50TmFtZSwgY29udGV4dElkLCBjaGFubmVsKTtcbiAgICAgICAgY29uc3QgbGFzdFNlbnRNZXNzYWdlSWQgPSB0aGlzLiNsYXN0TWVzc2FnZVNlbnQuZ2V0KGxhc3RTZW50TWFwS2V5KSA/PyAtSW5maW5pdHk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2V2ZW50QnVmZmVyc1xuICAgICAgICAgICAgLmdldChidWZmZXJNYXBLZXkpXG4gICAgICAgICAgICA/LmdldCgpXG4gICAgICAgICAgICAuZmlsdGVyKCh3cmFwcGVyKSA9PiB3cmFwcGVyLmlkID4gbGFzdFNlbnRNZXNzYWdlSWQpID8/IFtdO1xuICAgICAgICBpZiAoY29udGV4dElkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGb3IgZ2xvYmFsIHN1YnNjcmlwdGlvbnMsIGV2ZW50cyBidWZmZXJlZCBpbiBlYWNoIGNvbnRleHQgc2hvdWxkIGJlIHNlbnQgYmFjay5cbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy4jZXZlbnRUb0NvbnRleHRzTWFwLmdldChldmVudE5hbWUpLmtleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChfY29udGV4dElkKSA9PiBcbiAgICAgICAgICAgIC8vIEV2ZW50cyB3aXRob3V0IGNvbnRleHQgYXJlIGFscmVhZHkgaW4gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIF9jb250ZXh0SWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAvLyBFdmVudHMgZnJvbSBkZWxldGVkIGNvbnRleHRzIHNob3VsZCBub3QgYmUgc2VudC5cbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmhhc0NvbnRleHQoX2NvbnRleHRJZCkpXG4gICAgICAgICAgICAgICAgLm1hcCgoX2NvbnRleHRJZCkgPT4gdGhpcy4jZ2V0QnVmZmVyZWRFdmVudHMoZXZlbnROYW1lLCBfY29udGV4dElkLCBjaGFubmVsKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZXZlbnRzKSA9PiByZXN1bHQucHVzaCguLi5ldmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKGUxLCBlMikgPT4gZTEuaWQgLSBlMi5pZCk7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudE1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2Vzc2lvblByb2Nlc3NvciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jbGFzcyBTZXNzaW9uUHJvY2Vzc29yIHtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgICNpbml0Q29ubmVjdGlvbjtcbiAgICAjY3JlYXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgYnJvd3NlckNkcENsaWVudCwgaW5pdENvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jaW5pdENvbm5lY3Rpb24gPSBpbml0Q29ubmVjdGlvbjtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4geyByZWFkeTogZmFsc2UsIG1lc3NhZ2U6ICdhbHJlYWR5IGNvbm5lY3RlZCcgfTtcbiAgICB9XG4gICAgI21lcmdlQ2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllc1JlcXVlc3QpIHtcbiAgICAgICAgLy8gUm91Z2hseSBmb2xsb3dpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlcjIvI2Rmbi1jYXBhYmlsaXRpZXMtcHJvY2Vzc2luZy5cbiAgICAgICAgLy8gVmFsaWRhdGlvbnMgc2hvdWxkIGFscmVhZHkgYmUgZG9uZSBieSB0aGUgcGFyc2VyLlxuICAgICAgICBjb25zdCBtZXJnZWRDYXBhYmlsaXRpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaXJzdCBvZiBjYXBhYmlsaXRpZXNSZXF1ZXN0LmZpcnN0TWF0Y2ggPz8gW3t9XSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIC4uLmNhcGFiaWxpdGllc1JlcXVlc3QuYWx3YXlzTWF0Y2gsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBDYXBhYmlsaXR5ICR7a2V5fSBpbiBmaXJzdE1hdGNoIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBhbHdheXNNYXRjaGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpcnN0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWRDYXBhYmlsaXRpZXMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbWVyZ2VkQ2FwYWJpbGl0aWVzLmZpbmQoKGMpID0+IGMuYnJvd3Nlck5hbWUgPT09ICdjaHJvbWUnKSA/P1xuICAgICAgICAgICAgbWVyZ2VkQ2FwYWJpbGl0aWVzWzBdID8/XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgbWF0Y2gudW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IgPSB0aGlzLiNnZXRVbmhhbmRsZWRQcm9tcHRCZWhhdmlvcihtYXRjaC51bmhhbmRsZWRQcm9tcHRCZWhhdmlvcik7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgI2dldFVuaGFuZGxlZFByb21wdEJlaGF2aW9yKGNhcGFiaWxpdHlWYWx1ZSkge1xuICAgICAgICBpZiAoY2FwYWJpbGl0eVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYXBhYmlsaXR5VmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgdmFsaWRhdGUgY2FwYWJpbGl0aWVzLiBJbmNvcnJlY3Qgb25lcyB3aWxsIGJlIGlnbm9yZWQgYnkgTWFwcGVyLlxuICAgICAgICAgICAgcmV0dXJuIGNhcGFiaWxpdHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhcGFiaWxpdHlWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVW5leHBlY3RlZCAndW5oYW5kbGVkUHJvbXB0QmVoYXZpb3InIHR5cGU6ICR7dHlwZW9mIGNhcGFiaWxpdHlWYWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNhcGFiaWxpdHlWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYWNjZXB0JzpcbiAgICAgICAgICAgIGNhc2UgJ2FjY2VwdCBhbmQgbm90aWZ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWZhdWx0OiBcImFjY2VwdFwiIC8qIFNlc3Npb24uVXNlclByb21wdEhhbmRsZXJUeXBlLkFjY2VwdCAqLyB9O1xuICAgICAgICAgICAgY2FzZSAnZGlzbWlzcyc6XG4gICAgICAgICAgICBjYXNlICdkaXNtaXNzIGFuZCBub3RpZnknOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlZmF1bHQ6IFwiZGlzbWlzc1wiIC8qIFNlc3Npb24uVXNlclByb21wdEhhbmRsZXJUeXBlLkRpc21pc3MgKi8gfTtcbiAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGVmYXVsdDogXCJpZ25vcmVcIiAvKiBTZXNzaW9uLlVzZXJQcm9tcHRIYW5kbGVyVHlwZS5JZ25vcmUgKi8gfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBVbmV4cGVjdGVkICd1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcicgdmFsdWU6ICR7Y2FwYWJpbGl0eVZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5ldyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NyZWF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jY3JlYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRDYXBhYml0bGl0ZXMgPSB0aGlzLiNtZXJnZUNhcGFiaWxpdGllcyhwYXJhbXMuY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jaW5pdENvbm5lY3Rpb24obWF0Y2hlZENhcGFiaXRsaXRlcyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdCcm93c2VyLmdldFZlcnNpb24nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlc3Npb25JZDogJ3Vua25vd24nLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICAgICAgLi4ubWF0Y2hlZENhcGFiaXRsaXRlcyxcbiAgICAgICAgICAgICAgICBhY2NlcHRJbnNlY3VyZUNlcnRzOiBtYXRjaGVkQ2FwYWJpdGxpdGVzLmFjY2VwdEluc2VjdXJlQ2VydHMgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgYnJvd3Nlck5hbWU6IHZlcnNpb24ucHJvZHVjdCxcbiAgICAgICAgICAgICAgICBicm93c2VyVmVyc2lvbjogdmVyc2lvbi5yZXZpc2lvbixcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybU5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHNldFdpbmRvd1JlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldFVybDogJycsXG4gICAgICAgICAgICAgICAgdXNlckFnZW50OiB2ZXJzaW9uLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShwYXJhbXMsIGNoYW5uZWwgPSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2V2ZW50TWFuYWdlci5zdWJzY3JpYmUocGFyYW1zLmV2ZW50cywgcGFyYW1zLmNvbnRleHRzID8/IFtudWxsXSwgY2hhbm5lbCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUocGFyYW1zLCBjaGFubmVsID0gbnVsbCkge1xuICAgICAgICBhd2FpdCB0aGlzLiNldmVudE1hbmFnZXIudW5zdWJzY3JpYmUocGFyYW1zLmV2ZW50cywgcGFyYW1zLmNvbnRleHRzID8/IFtudWxsXSwgY2hhbm5lbCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5leHBvcnRzLlNlc3Npb25Qcm9jZXNzb3IgPSBTZXNzaW9uUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Vzc2lvblByb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25NYW5hZ2VyID0gdm9pZCAwO1xuZXhwb3J0cy5jYXJ0ZXNpYW5Qcm9kdWN0ID0gY2FydGVzaWFuUHJvZHVjdDtcbmV4cG9ydHMudW5yb2xsRXZlbnRzID0gdW5yb2xsRXZlbnRzO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGV2ZW50c19qc18xID0gcmVxdWlyZShcIi4vZXZlbnRzLmpzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiB0aGUgZ2l2ZW4gYXJyYXlzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiAgIGNhcnRlc2lhbihbMSwgMl0sIFsnYScsICdiJ10pOyA9PiBbWzEsICdhJ10sIFsxLCAnYiddLCBbMiwgJ2EnXSwgWzIsICdiJ11dXG4gKi9cbmZ1bmN0aW9uIGNhcnRlc2lhblByb2R1Y3QoLi4uYSkge1xuICAgIHJldHVybiBhLnJlZHVjZSgoYSwgYikgPT4gYS5mbGF0TWFwKChkKSA9PiBiLm1hcCgoZSkgPT4gW2QsIGVdLmZsYXQoKSkpKTtcbn1cbi8qKiBFeHBhbmRzIFwiQWxsRXZlbnRzXCIgZXZlbnRzIGludG8gYXRvbWljIGV2ZW50cy4gKi9cbmZ1bmN0aW9uIHVucm9sbEV2ZW50cyhldmVudHMpIHtcbiAgICBjb25zdCBhbGxFdmVudHMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gYWRkRXZlbnRzKGV2ZW50cykge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgYWxsRXZlbnRzLmFkZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLkJyb3dzaW5nQ29udGV4dDpcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLkxvZzpcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Mb2cuRXZlbnROYW1lcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLk5ldHdvcms6XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuU2NyaXB0OlxuICAgICAgICAgICAgICAgIGFkZEV2ZW50cyhPYmplY3QudmFsdWVzKHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLlNjcmlwdC5FdmVudE5hbWVzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFsbEV2ZW50cy5hZGQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWxsRXZlbnRzLnZhbHVlcygpXTtcbn1cbmNsYXNzIFN1YnNjcmlwdGlvbk1hbmFnZXIge1xuICAgICNzdWJzY3JpcHRpb25Qcmlvcml0eSA9IDA7XG4gICAgLy8gQnJvd3NpbmdDb250ZXh0IGBudWxsYCBtZWFucyB0aGUgZXZlbnQgaGFzIHN1YnNjcmlwdGlvbiBhY3Jvc3MgYWxsIHRoZVxuICAgIC8vIGJyb3dzaW5nIGNvbnRleHRzLlxuICAgIC8vIENoYW5uZWwgYG51bGxgIG1lYW5zIG5vIGBjaGFubmVsYCBzaG91bGQgYmUgYWRkZWQuXG4gICAgI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgfVxuICAgIGdldENoYW5uZWxzU3Vic2NyaWJlZFRvRXZlbnQoZXZlbnRNZXRob2QsIGNvbnRleHRJZCkge1xuICAgICAgICBjb25zdCBwcmlvcml0aWVzQW5kQ2hhbm5lbHMgPSBBcnJheS5mcm9tKHRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmtleXMoKSlcbiAgICAgICAgICAgIC5tYXAoKGNoYW5uZWwpID0+ICh7XG4gICAgICAgICAgICBwcmlvcml0eTogdGhpcy4jZ2V0RXZlbnRTdWJzY3JpcHRpb25Qcmlvcml0eUZvckNoYW5uZWwoZXZlbnRNZXRob2QsIGNvbnRleHRJZCwgY2hhbm5lbCksXG4gICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcHJpb3JpdHkgfSkgPT4gcHJpb3JpdHkgIT09IG51bGwpO1xuICAgICAgICAvLyBTb3J0IGNoYW5uZWxzIGJ5IHByaW9yaXR5LlxuICAgICAgICByZXR1cm4gcHJpb3JpdGllc0FuZENoYW5uZWxzXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpXG4gICAgICAgICAgICAubWFwKCh7IGNoYW5uZWwgfSkgPT4gY2hhbm5lbCk7XG4gICAgfVxuICAgICNnZXRFdmVudFN1YnNjcmlwdGlvblByaW9yaXR5Rm9yQ2hhbm5lbChldmVudE1ldGhvZCwgY29udGV4dElkLCBjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHRUb0V2ZW50TWFwID0gdGhpcy4jY2hhbm5lbFRvQ29udGV4dFRvRXZlbnRNYXAuZ2V0KGNoYW5uZWwpO1xuICAgICAgICBpZiAoY29udGV4dFRvRXZlbnRNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF5YmVUb3BMZXZlbENvbnRleHRJZCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZFRvcExldmVsQ29udGV4dElkKGNvbnRleHRJZCk7XG4gICAgICAgIC8vIGBudWxsYCBjb3ZlcnMgZ2xvYmFsIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgY29uc3QgcmVsZXZhbnRDb250ZXh0cyA9IFsuLi5uZXcgU2V0KFtudWxsLCBtYXliZVRvcExldmVsQ29udGV4dElkXSldO1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSBzdWJzY3JpcHRpb24gcHJpb3JpdGllcy5cbiAgICAgICAgY29uc3QgcHJpb3JpdGllcyA9IHJlbGV2YW50Q29udGV4dHNcbiAgICAgICAgICAgIC5tYXAoKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHJpb3JpdHkgZm9yIGV4YWN0IGV2ZW50IG5hbWVcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5ID0gY29udGV4dFRvRXZlbnRNYXAuZ2V0KGNvbnRleHQpPy5nZXQoZXZlbnRNZXRob2QpO1xuICAgICAgICAgICAgLy8gRm9yIENEUCB3ZSBjYW4ndCBwcm92aWRlIHNwZWNpZmljIGV2ZW50IG5hbWUgd2hlbiBzdWJzY3JpYmluZ1xuICAgICAgICAgICAgLy8gdG8gdGhlIG1vZHVsZSBkaXJlY3RseS5cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCB3ZSBuZWVkIHRvIHNlZSBldmVudCBgY2RwYCBleGl0cyBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgaWYgKCgwLCBldmVudHNfanNfMS5pc0NkcEV2ZW50KShldmVudE1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZHBQcmlvcml0eSA9IGNvbnRleHRUb0V2ZW50TWFwXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgPy5nZXQocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5DZHApO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN1YnNjcmliZSB0byB0aGUgZXZlbnQgZGlyZWN0bHkgYW5kIGBjZHBgIG1vZHVsZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgd2lsbCBiZSBkaWZmZXJlbnQgd2UgdGFrZSBtaW5pbWFsIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5ICYmIGNkcFByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocHJpb3JpdHksIGNkcFByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICA6IC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGF0IHdlIGhhdmUgc3Vic2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gb25seSBvbmUgb2YgdGhlIHR3b1xuICAgICAgICAgICAgICAgICAgICAgICAgKHByaW9yaXR5ID8/IGNkcFByaW9yaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmlvcml0eTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHApID0+IHAgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChwcmlvcml0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm90IHN1YnNjcmliZWQsIHJldHVybiBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIG1pbmltYWwgcHJpb3JpdHkuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbiguLi5wcmlvcml0aWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1vZHVsZSBCaURpKyBtb2R1bGVcbiAgICAgKiBAcGFyYW0gY29udGV4dElkIGBudWxsYCA9PSBnbG9iYWxseSBzdWJzY3JpYmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGlzU3Vic2NyaWJlZFRvKG1vZHVsZU9yRXZlbnQsIGNvbnRleHRJZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxDb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kVG9wTGV2ZWxDb250ZXh0SWQoY29udGV4dElkKTtcbiAgICAgICAgZm9yIChjb25zdCBicm93c2VyQ29udGV4dFRvRXZlbnRNYXAgb2YgdGhpcy4jY2hhbm5lbFRvQ29udGV4dFRvRXZlbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBldmVudE1hcF0gb2YgYnJvd3NlckNvbnRleHRUb0V2ZW50TWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBzdWJzY3JpYmVkIHRvIHRoaXMgY29udGV4dCBvciBnbG9iYWxseVxuICAgICAgICAgICAgICAgIGlmICh0b3BMZXZlbENvbnRleHQgIT09IGlkICYmIGlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50TWFwLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gY292ZXJzIHRoZSBgY2RwYCBjYXNlIHdoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHVucm9sbCB0aGUgZXZlbnQgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBleHBsaWNpdGx5IHN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPT09IG1vZHVsZU9yRXZlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IHN1YnNjcmliZWQgdmlhIG1vZHVsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPT09IG1vZHVsZU9yRXZlbnQuc3BsaXQoJy4nKS5hdCgwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgZXhwbGljaXRseSBzdWJzY3JpYmVkIGNvbXBhcmVkIHRvIG1vZHVsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3BsaXQoJy4nKS5hdCgwKSA9PT0gbW9kdWxlT3JFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGV2ZW50IGluIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7RXZlbnROYW1lc30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jyb3dzaW5nQ29udGV4dC5Ccm93c2luZ0NvbnRleHQgfCBudWxsfSBjb250ZXh0SWRcbiAgICAgKiBAcGFyYW0ge0JpZGlQbHVzQ2hhbm5lbH0gY2hhbm5lbFxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbkl0ZW1bXX0gTGlzdCBvZlxuICAgICAqIHN1YnNjcmlwdGlvbnMuIElmIHRoZSBldmVudCBpcyBhIHdob2xlIG1vZHVsZSwgaXQgd2lsbCByZXR1cm4gYWxsIHRoZSBzcGVjaWZpY1xuICAgICAqIGV2ZW50cy4gSWYgdGhlIGNvbnRleHRJZCBpcyBudWxsLCBpdCB3aWxsIHJldHVybiBhbGwgdGhlIHRvcC1sZXZlbCBjb250ZXh0cyB3aGljaCB3ZXJlXG4gICAgICogbm90IHN1YnNjcmliZWQgYmVmb3JlIHRoZSBjb21tYW5kLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShldmVudCwgY29udGV4dElkLCBjaGFubmVsKSB7XG4gICAgICAgIC8vIEFsbCB0aGUgc3Vic2NyaXB0aW9ucyBhcmUgaGFuZGxlZCBvbiB0aGUgdG9wLWxldmVsIGNvbnRleHRzLlxuICAgICAgICBjb250ZXh0SWQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRUb3BMZXZlbENvbnRleHRJZChjb250ZXh0SWQpO1xuICAgICAgICAvLyBDaGVjayBpZiBzdWJzY3JpYmVkIGV2ZW50IGlzIGEgd2hvbGUgbW9kdWxlXG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5Ccm93c2luZ0NvbnRleHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHNwZWNpZmljRXZlbnQpID0+IHRoaXMuc3Vic2NyaWJlKHNwZWNpZmljRXZlbnQsIGNvbnRleHRJZCwgY2hhbm5lbCkpXG4gICAgICAgICAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgICAgICBjYXNlIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuTG9nOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChzcGVjaWZpY0V2ZW50KSA9PiB0aGlzLnN1YnNjcmliZShzcGVjaWZpY0V2ZW50LCBjb250ZXh0SWQsIGNoYW5uZWwpKVxuICAgICAgICAgICAgICAgICAgICAuZmxhdCgpO1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLk5ldHdvcms6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChzcGVjaWZpY0V2ZW50KSA9PiB0aGlzLnN1YnNjcmliZShzcGVjaWZpY0V2ZW50LCBjb250ZXh0SWQsIGNoYW5uZWwpKVxuICAgICAgICAgICAgICAgICAgICAuZmxhdCgpO1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLlNjcmlwdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3BlY2lmaWNFdmVudCkgPT4gdGhpcy5zdWJzY3JpYmUoc3BlY2lmaWNFdmVudCwgY29udGV4dElkLCBjaGFubmVsKSlcbiAgICAgICAgICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGxlZnQgZW1wdHkuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC5oYXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIHRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLnNldChjaGFubmVsLCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHRUb0V2ZW50TWFwID0gdGhpcy4jY2hhbm5lbFRvQ29udGV4dFRvRXZlbnRNYXAuZ2V0KGNoYW5uZWwpO1xuICAgICAgICBpZiAoIWNvbnRleHRUb0V2ZW50TWFwLmhhcyhjb250ZXh0SWQpKSB7XG4gICAgICAgICAgICBjb250ZXh0VG9FdmVudE1hcC5zZXQoY29udGV4dElkLCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50TWFwID0gY29udGV4dFRvRXZlbnRNYXAuZ2V0KGNvbnRleHRJZCk7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkQ29udGV4dElkcyA9IChjb250ZXh0SWQgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRUb3BMZXZlbENvbnRleHRzKCkubWFwKChjKSA9PiBjLmlkKVxuICAgICAgICAgICAgOiBbY29udGV4dElkXSlcbiAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBiZSBjb250ZXh0cyB0aGF0IGFyZSBhbHJlYWR5IHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LiBEbyBub3QgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdGhlbSB0byB0aGUgb3V0cHV0LlxuICAgICAgICAgICAgLmZpbHRlcigoY29udGV4dElkKSA9PiAhdGhpcy5pc1N1YnNjcmliZWRUbyhldmVudCwgY29udGV4dElkKSk7XG4gICAgICAgIGlmICghZXZlbnRNYXAuaGFzKGV2ZW50KSkge1xuICAgICAgICAgICAgLy8gQWRkIHN1YnNjcmlwdGlvbiBvbmx5IGlmIGl0J3Mgbm90IGFscmVhZHkgc3Vic2NyaWJlZC5cbiAgICAgICAgICAgIGV2ZW50TWFwLnNldChldmVudCwgdGhpcy4jc3Vic2NyaXB0aW9uUHJpb3JpdHkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFmZmVjdGVkQ29udGV4dElkcy5tYXAoKGNvbnRleHRJZCkgPT4gKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgY29udGV4dElkLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhdG9taWNhbGx5IGZyb20gYWxsIGV2ZW50cyBpbiB0aGUgZ2l2ZW4gY29udGV4dHMgYW5kIGNoYW5uZWwuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmVBbGwoZXZlbnRzLCBjb250ZXh0SWRzLCBjaGFubmVsKSB7XG4gICAgICAgIC8vIEFzc2VydCBhbGwgY29udGV4dHMgYXJlIGtub3duLlxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRleHRJZCBvZiBjb250ZXh0SWRzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KGNvbnRleHRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRDb250ZXh0UGFpcnMgPSBjYXJ0ZXNpYW5Qcm9kdWN0KHVucm9sbEV2ZW50cyhldmVudHMpLCBjb250ZXh0SWRzKTtcbiAgICAgICAgLy8gQXNzZXJ0IGFsbCB1bnN1YnNjcmlwdGlvbnMgYXJlIHZhbGlkLlxuICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIHVuc3Vic2NyaXB0aW9ucyBhcmUgaW52YWxpZCwgZG8gbm90IHVuc3Vic2NyaWJlIGZyb20gYW55dGhpbmcuXG4gICAgICAgIGV2ZW50Q29udGV4dFBhaXJzXG4gICAgICAgICAgICAubWFwKChbZXZlbnQsIGNvbnRleHRJZF0pID0+IHRoaXMuI2NoZWNrVW5zdWJzY3JpYmUoZXZlbnQsIGNvbnRleHRJZCwgY2hhbm5lbCkpXG4gICAgICAgICAgICAuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGNvbnRleHQgYW5kIGNoYW5uZWwuXG4gICAgICogU3ludGFjdGljIHN1Z2FyIGZvciBcInVuc3Vic2NyaWJlQWxsXCIuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lLCBjb250ZXh0SWQsIGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUFsbChbZXZlbnROYW1lXSwgW2NvbnRleHRJZF0sIGNoYW5uZWwpO1xuICAgIH1cbiAgICAjY2hlY2tVbnN1YnNjcmliZShldmVudCwgY29udGV4dElkLCBjaGFubmVsKSB7XG4gICAgICAgIC8vIEFsbCB0aGUgc3Vic2NyaXB0aW9ucyBhcmUgaGFuZGxlZCBvbiB0aGUgdG9wLWxldmVsIGNvbnRleHRzLlxuICAgICAgICBjb250ZXh0SWQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRUb3BMZXZlbENvbnRleHRJZChjb250ZXh0SWQpO1xuICAgICAgICBpZiAoIXRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmhhcyhjaGFubmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBDYW5ub3QgdW5zdWJzY3JpYmUgZnJvbSAke2V2ZW50fSwgJHtjb250ZXh0SWQgPT09IG51bGwgPyAnbnVsbCcgOiBjb250ZXh0SWR9LiBObyBzdWJzY3JpcHRpb24gZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dFRvRXZlbnRNYXAgPSB0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC5nZXQoY2hhbm5lbCk7XG4gICAgICAgIGlmICghY29udGV4dFRvRXZlbnRNYXAuaGFzKGNvbnRleHRJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgQ2Fubm90IHVuc3Vic2NyaWJlIGZyb20gJHtldmVudH0sICR7Y29udGV4dElkID09PSBudWxsID8gJ251bGwnIDogY29udGV4dElkfS4gTm8gc3Vic2NyaXB0aW9uIGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50TWFwID0gY29udGV4dFRvRXZlbnRNYXAuZ2V0KGNvbnRleHRJZCk7XG4gICAgICAgIGlmICghZXZlbnRNYXAuaGFzKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBDYW5ub3QgdW5zdWJzY3JpYmUgZnJvbSAke2V2ZW50fSwgJHtjb250ZXh0SWQgPT09IG51bGwgPyAnbnVsbCcgOiBjb250ZXh0SWR9LiBObyBzdWJzY3JpcHRpb24gZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50TWFwLmRlbGV0ZShldmVudCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBtYXBzIGlmIGVtcHR5LlxuICAgICAgICAgICAgaWYgKGV2ZW50TWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0VG9FdmVudE1hcC5kZWxldGUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHRUb0V2ZW50TWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC5kZWxldGUoY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpcHRpb25NYW5hZ2VyID0gU3Vic2NyaXB0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbk1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQ2RwRXZlbnQgPSBpc0NkcEV2ZW50O1xuZXhwb3J0cy5hc3NlcnRTdXBwb3J0ZWRFdmVudCA9IGFzc2VydFN1cHBvcnRlZEV2ZW50O1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgQ0RQIGV2ZW50LlxuICogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC9cbiAqL1xuZnVuY3Rpb24gaXNDZHBFdmVudChuYW1lKSB7XG4gICAgcmV0dXJuIChuYW1lLnNwbGl0KCcuJykuYXQoMCk/LnN0YXJ0c1dpdGgocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5DZHApID8/IGZhbHNlKTtcbn1cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBldmVudCBpcyBrbm93biB0byBCaURpIG9yIEJpRGkrLCBvciB0aHJvd3Mgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdXBwb3J0ZWRFdmVudChuYW1lKSB7XG4gICAgaWYgKCFwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5FVkVOVF9OQU1FUy5oYXMobmFtZSkgJiYgIWlzQ2RwRXZlbnQobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBVbmtub3duIGV2ZW50OiAke25hbWV9YCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yYWdlUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGFzc2VydF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2Fzc2VydC5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IE5ldHdvcmtQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL05ldHdvcmtQcm9jZXNzb3IuanNcIik7XG5jb25zdCBOZXR3b3JrVXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL05ldHdvcmtVdGlscy5qc1wiKTtcbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBgc3RvcmFnZWAgZG9tYWluLlxuICovXG5jbGFzcyBTdG9yYWdlUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjbG9nZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzZXJDZHBDbGllbnQsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudCA9IGJyb3dzZXJDZHBDbGllbnQ7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlQ29va2llcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFydGl0aW9uS2V5ID0gdGhpcy4jZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWMocGFyYW1zLnBhcnRpdGlvbik7XG4gICAgICAgIGxldCBjZHBSZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNkcFJlc3BvbnNlID0gYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnU3RvcmFnZS5nZXRDb29raWVzJywge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0SWQ6IHRoaXMuI2dldENkcEJyb3dzZXJDb250ZXh0SWQocGFydGl0aW9uS2V5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc05vU3VjaFVzZXJDb250ZXh0RXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGNvbnRleHQgaXMgbm90IGZvdW5kLCBzcGVjaWFsIGVycm9yIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hVc2VyQ29udGV4dEV4Y2VwdGlvbihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2RwQ29va2llc1RvRGVsZXRlID0gY2RwUmVzcG9uc2UuY29va2llc1xuICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgLy8gQ0RQJ3MgcGFydGl0aW9uIGtleSBpcyB0aGUgc291cmNlIG9yaWdpbi4gSWYgdGhlIHJlcXVlc3Qgc3BlY2lmaWVzIHRoZVxuICAgICAgICAvLyBgc291cmNlT3JpZ2luYCBwYXJ0aXRpb24ga2V5LCBvbmx5IGNvb2tpZXMgd2l0aCB0aGUgcmVxdWVzdGVkIHNvdXJjZSBvcmlnaW5cbiAgICAgICAgLy8gYXJlIHJldHVybmVkLlxuICAgICAgICAoYykgPT4gcGFydGl0aW9uS2V5LnNvdXJjZU9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjLnBhcnRpdGlvbktleT8udG9wTGV2ZWxTaXRlID09PSBwYXJ0aXRpb25LZXkuc291cmNlT3JpZ2luKVxuICAgICAgICAgICAgLmZpbHRlcigoY2RwQ29va2llKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiaWRpQ29va2llID0gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcFRvQmlEaUNvb2tpZSkoY2RwQ29va2llKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNtYXRjaENvb2tpZShiaWRpQ29va2llLCBwYXJhbXMuZmlsdGVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKGNvb2tpZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmNvb2tpZSxcbiAgICAgICAgICAgIC8vIFNldCBleHBpcnkgdG8gcGFzcyBkYXRlIHRvIGRlbGV0ZSB0aGUgY29va2llLlxuICAgICAgICAgICAgZXhwaXJlczogMSxcbiAgICAgICAgfSkpO1xuICAgICAgICBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdTdG9yYWdlLnNldENvb2tpZXMnLCB7XG4gICAgICAgICAgICBjb29raWVzOiBjZHBDb29raWVzVG9EZWxldGUsXG4gICAgICAgICAgICBicm93c2VyQ29udGV4dElkOiB0aGlzLiNnZXRDZHBCcm93c2VyQ29udGV4dElkKHBhcnRpdGlvbktleSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydGl0aW9uS2V5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRDb29raWVzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJ0aXRpb25LZXkgPSB0aGlzLiNleHBhbmRTdG9yYWdlUGFydGl0aW9uU3BlYyhwYXJhbXMucGFydGl0aW9uKTtcbiAgICAgICAgbGV0IGNkcFJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2RwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdTdG9yYWdlLmdldENvb2tpZXMnLCB7XG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdGhpcy4jZ2V0Q2RwQnJvd3NlckNvbnRleHRJZChwYXJ0aXRpb25LZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzTm9TdWNoVXNlckNvbnRleHRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY29udGV4dCBpcyBub3QgZm91bmQsIHNwZWNpYWwgZXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZEJpRGlDb29raWVzID0gY2RwUmVzcG9uc2UuY29va2llc1xuICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgLy8gQ0RQJ3MgcGFydGl0aW9uIGtleSBpcyB0aGUgc291cmNlIG9yaWdpbi4gSWYgdGhlIHJlcXVlc3Qgc3BlY2lmaWVzIHRoZVxuICAgICAgICAvLyBgc291cmNlT3JpZ2luYCBwYXJ0aXRpb24ga2V5LCBvbmx5IGNvb2tpZXMgd2l0aCB0aGUgcmVxdWVzdGVkIHNvdXJjZSBvcmlnaW5cbiAgICAgICAgLy8gYXJlIHJldHVybmVkLlxuICAgICAgICAoYykgPT4gcGFydGl0aW9uS2V5LnNvdXJjZU9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjLnBhcnRpdGlvbktleT8udG9wTGV2ZWxTaXRlID09PSBwYXJ0aXRpb25LZXkuc291cmNlT3JpZ2luKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcFRvQmlEaUNvb2tpZSkoYykpXG4gICAgICAgICAgICAuZmlsdGVyKChjKSA9PiB0aGlzLiNtYXRjaENvb2tpZShjLCBwYXJhbXMuZmlsdGVyKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29raWVzOiBmaWx0ZXJlZEJpRGlDb29raWVzLFxuICAgICAgICAgICAgcGFydGl0aW9uS2V5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZXRDb29raWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbktleSA9IHRoaXMuI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjKHBhcmFtcy5wYXJ0aXRpb24pO1xuICAgICAgICBjb25zdCBjZHBDb29raWUgPSAoMCwgTmV0d29ya1V0aWxzX2pzXzEuYmlkaVRvQ2RwQ29va2llKShwYXJhbXMsIHBhcnRpdGlvbktleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdTdG9yYWdlLnNldENvb2tpZXMnLCB7XG4gICAgICAgICAgICAgICAgY29va2llczogW2NkcENvb2tpZV0sXG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdGhpcy4jZ2V0Q2RwQnJvd3NlckNvbnRleHRJZChwYXJ0aXRpb25LZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzTm9TdWNoVXNlckNvbnRleHRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY29udGV4dCBpcyBub3QgZm91bmQsIHNwZWNpYWwgZXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgZXJyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuYWJsZVRvU2V0Q29va2llRXhjZXB0aW9uKGVyci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydGl0aW9uS2V5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjaXNOb1N1Y2hVc2VyQ29udGV4dEVycm9yKGVycikge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gZGV0ZWN0IGlmIHRoZSB1c2VyIGNvbnRleHQgaXMgbm90IGZvdW5kLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46Y29udGVudC9icm93c2VyL2RldnRvb2xzL3Byb3RvY29sL2Jyb3dzZXJfaGFuZGxlci5jYztkcmM9YTU2MTU0ZGQ4MWU0Njc5NzEyNDIyYWM2ZWVkMmM5NTgxY2I1MWFiMDtsPTMxNFxuICAgICAgICByZXR1cm4gZXJyLm1lc3NhZ2U/LnN0YXJ0c1dpdGgoJ0ZhaWxlZCB0byBmaW5kIGJyb3dzZXIgY29udGV4dCBmb3IgaWQnKTtcbiAgICB9XG4gICAgI2dldENkcEJyb3dzZXJDb250ZXh0SWQocGFydGl0aW9uS2V5KSB7XG4gICAgICAgIHJldHVybiBwYXJ0aXRpb25LZXkudXNlckNvbnRleHQgPT09ICdkZWZhdWx0J1xuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcGFydGl0aW9uS2V5LnVzZXJDb250ZXh0O1xuICAgIH1cbiAgICAjZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWNCeUJyb3dzaW5nQ29udGV4dChkZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dElkID0gZGVzY3JpcHRvci5jb250ZXh0O1xuICAgICAgICBjb25zdCBicm93c2luZ0NvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoYnJvd3NpbmdDb250ZXh0SWQpO1xuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI2Fzc29jaWF0ZWQtc3RvcmFnZS1wYXJ0aXRpb24uXG4gICAgICAgIC8vIEVhY2ggYnJvd3NpbmcgY29udGV4dCBhbHNvIGhhcyBhbiBhc3NvY2lhdGVkIHN0b3JhZ2UgcGFydGl0aW9uLCB3aGljaCBpcyB0aGVcbiAgICAgICAgLy8gc3RvcmFnZSBwYXJ0aXRpb24gaXQgdXNlcyB0byBwZXJzaXN0IGRhdGEuIEluIENocm9taXVtIGl0J3MgYSBgQnJvd3NlckNvbnRleHRgXG4gICAgICAgIC8vIHdoaWNoIG1hcHMgdG8gQmlEaSBgVXNlckNvbnRleHRgLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckNvbnRleHQ6IGJyb3dzaW5nQ29udGV4dC51c2VyQ29udGV4dCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjQnlTdG9yYWdlS2V5KGRlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgdW5zdXBwb3J0ZWRQYXJ0aXRpb25LZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgc291cmNlT3JpZ2luID0gZGVzY3JpcHRvci5zb3VyY2VPcmlnaW47XG4gICAgICAgIGlmIChzb3VyY2VPcmlnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gTmV0d29ya1Byb2Nlc3Nvcl9qc18xLk5ldHdvcmtQcm9jZXNzb3IucGFyc2VVcmxTdHJpbmcoc291cmNlT3JpZ2luKTtcbiAgICAgICAgICAgIGlmICh1cmwub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW4gYG51bGxgIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBsb2NhbCBwYWdlcy5cbiAgICAgICAgICAgICAgICBzb3VyY2VPcmlnaW4gPSB1cmwub3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUG9ydCBpcyBub3Qgc3VwcG9ydGVkIGluIENEUCBDb29raWUncyBgcGFydGl0aW9uS2V5YCwgc28gaXQgc2hvdWxkIGJlIHN0cmlwcGVkXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgcmVxdWVzdGVkIHNvdXJjZSBvcmlnaW4uXG4gICAgICAgICAgICAgICAgc291cmNlT3JpZ2luID0gYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdG5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICFbJ3R5cGUnLCAnc291cmNlT3JpZ2luJywgJ3VzZXJDb250ZXh0J10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkUGFydGl0aW9uS2V5cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkUGFydGl0aW9uS2V5cy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5kZWJ1Z0luZm8sIGBVbnN1cHBvcnRlZCBwYXJ0aXRpb24ga2V5czogJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModW5zdXBwb3J0ZWRQYXJ0aXRpb25LZXlzKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGB1c2VyQ29udGV4dGAgdG8gYGRlZmF1bHRgIGlmIG5vdCBwcm92aWRlZCwgYXMgaXQncyByZXF1aXJlZCBpbiBDaHJvbWl1bS5cbiAgICAgICAgY29uc3QgdXNlckNvbnRleHQgPSBkZXNjcmlwdG9yLnVzZXJDb250ZXh0ID8/ICdkZWZhdWx0JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXJDb250ZXh0LFxuICAgICAgICAgICAgLi4uKHNvdXJjZU9yaWdpbiA9PT0gdW5kZWZpbmVkID8ge30gOiB7IHNvdXJjZU9yaWdpbiB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjKHBhcnRpdGlvblNwZWMpIHtcbiAgICAgICAgaWYgKHBhcnRpdGlvblNwZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYHVzZXJDb250ZXh0YCBpcyByZXF1aXJlZCBpbiBDaHJvbWl1bS5cbiAgICAgICAgICAgIHJldHVybiB7IHVzZXJDb250ZXh0OiAnZGVmYXVsdCcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGl0aW9uU3BlYy50eXBlID09PSAnY29udGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNleHBhbmRTdG9yYWdlUGFydGl0aW9uU3BlY0J5QnJvd3NpbmdDb250ZXh0KHBhcnRpdGlvblNwZWMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHBhcnRpdGlvblNwZWMudHlwZSA9PT0gJ3N0b3JhZ2VLZXknLCAnVW5rbm93biBwYXJ0aXRpb24gdHlwZScpO1xuICAgICAgICAvLyBQYXJ0aXRpb24gc3BlYyBpcyBhIHN0b3JhZ2UgcGFydGl0aW9uLlxuICAgICAgICAvLyBMZXQgcGFydGl0aW9uIGtleSBiZSBwYXJ0aXRpb24gc3BlYy5cbiAgICAgICAgcmV0dXJuIHRoaXMuI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjQnlTdG9yYWdlS2V5KHBhcnRpdGlvblNwZWMpO1xuICAgIH1cbiAgICAjbWF0Y2hDb29raWUoY29va2llLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChmaWx0ZXIuZG9tYWluID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLmRvbWFpbiA9PT0gY29va2llLmRvbWFpbikgJiZcbiAgICAgICAgICAgIChmaWx0ZXIubmFtZSA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlci5uYW1lID09PSBjb29raWUubmFtZSkgJiZcbiAgICAgICAgICAgIC8vIGB2YWx1ZWAgY29udGFpbnMgZmllbGRzIGB0eXBlYCBhbmQgYHZhbHVlYC5cbiAgICAgICAgICAgIChmaWx0ZXIudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICgwLCBOZXR3b3JrVXRpbHNfanNfMS5kZXNlcmlhbGl6ZUJ5dGVWYWx1ZSkoZmlsdGVyLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgKDAsIE5ldHdvcmtVdGlsc19qc18xLmRlc2VyaWFsaXplQnl0ZVZhbHVlKShjb29raWUudmFsdWUpKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5wYXRoID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLnBhdGggPT09IGNvb2tpZS5wYXRoKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5zaXplID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLnNpemUgPT09IGNvb2tpZS5zaXplKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5odHRwT25seSA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlci5odHRwT25seSA9PT0gY29va2llLmh0dHBPbmx5KSAmJlxuICAgICAgICAgICAgKGZpbHRlci5zZWN1cmUgPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIuc2VjdXJlID09PSBjb29raWUuc2VjdXJlKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5zYW1lU2l0ZSA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlci5zYW1lU2l0ZSA9PT0gY29va2llLnNhbWVTaXRlKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5leHBpcnkgPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIuZXhwaXJ5ID09PSBjb29raWUuZXhwaXJ5KSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yYWdlUHJvY2Vzc29yID0gU3RvcmFnZVByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3JhZ2VQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGVyc3BlY2lmaWVkU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5hYmxlVG9TZXRGaWxlSW5wdXRFeGNlcHRpb24gPSBleHBvcnRzLlVuYWJsZVRvU2V0Q29va2llRXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hTdG9yYWdlUGFydGl0aW9uRXhjZXB0aW9uID0gZXhwb3J0cy5VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5hYmxlVG9DbG9zZUJyb3dzZXJFeGNlcHRpb24gPSBleHBvcnRzLlVuYWJsZVRvQ2FwdHVyZVNjcmVlbkV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5rbm93bkVycm9yRXhjZXB0aW9uID0gZXhwb3J0cy5Vbmtub3duQ29tbWFuZEV4Y2VwdGlvbiA9IGV4cG9ydHMuU2Vzc2lvbk5vdENyZWF0ZWRFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hTY3JpcHRFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaFJlcXVlc3RFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaE5vZGVFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoSGlzdG9yeUVudHJ5RXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hIYW5kbGVFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaEZyYW1lRXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hBbGVydEV4Y2VwdGlvbiA9IGV4cG9ydHMuTW92ZVRhcmdldE91dE9mQm91bmRzRXhjZXB0aW9uID0gZXhwb3J0cy5JbnZhbGlkU2Vzc2lvbklkRXhjZXB0aW9uID0gZXhwb3J0cy5JbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24gPSBleHBvcnRzLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbiA9IGV4cG9ydHMuRXhjZXB0aW9uID0gdm9pZCAwO1xuY2xhc3MgRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGVycm9yO1xuICAgIG1lc3NhZ2U7XG4gICAgc3RhY2t0cmFjZTtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgbWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IHN0YWNrdHJhY2U7XG4gICAgfVxuICAgIHRvRXJyb3JSZXNwb25zZShjb21tYW5kSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBpZDogY29tbWFuZElkLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFja3RyYWNlOiB0aGlzLnN0YWNrdHJhY2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5FeGNlcHRpb24gPSBFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJpbnZhbGlkIGFyZ3VtZW50XCIgLyogRXJyb3JDb2RlLkludmFsaWRBcmd1bWVudCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gPSBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJpbnZhbGlkIHNlbGVjdG9yXCIgLyogRXJyb3JDb2RlLkludmFsaWRTZWxlY3RvciAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24gPSBJbnZhbGlkU2VsZWN0b3JFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkU2Vzc2lvbklkRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIgLyogRXJyb3JDb2RlLkludmFsaWRTZXNzaW9uSWQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFNlc3Npb25JZEV4Y2VwdGlvbiA9IEludmFsaWRTZXNzaW9uSWRFeGNlcHRpb247XG5jbGFzcyBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJtb3ZlIHRhcmdldCBvdXQgb2YgYm91bmRzXCIgLyogRXJyb3JDb2RlLk1vdmVUYXJnZXRPdXRPZkJvdW5kcyAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb24gPSBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb247XG5jbGFzcyBOb1N1Y2hBbGVydEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggYWxlcnRcIiAvKiBFcnJvckNvZGUuTm9TdWNoQWxlcnQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoQWxlcnRFeGNlcHRpb24gPSBOb1N1Y2hBbGVydEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIGVsZW1lbnRcIiAvKiBFcnJvckNvZGUuTm9TdWNoRWxlbWVudCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uID0gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEZyYW1lRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBmcmFtZVwiIC8qIEVycm9yQ29kZS5Ob1N1Y2hGcmFtZSAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hGcmFtZUV4Y2VwdGlvbiA9IE5vU3VjaEZyYW1lRXhjZXB0aW9uO1xuY2xhc3MgTm9TdWNoSGFuZGxlRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBoYW5kbGVcIiAvKiBFcnJvckNvZGUuTm9TdWNoSGFuZGxlICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaEhhbmRsZUV4Y2VwdGlvbiA9IE5vU3VjaEhhbmRsZUV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEhpc3RvcnlFbnRyeUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggaGlzdG9yeSBlbnRyeVwiIC8qIEVycm9yQ29kZS5Ob1N1Y2hIaXN0b3J5RW50cnkgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoSGlzdG9yeUVudHJ5RXhjZXB0aW9uID0gTm9TdWNoSGlzdG9yeUVudHJ5RXhjZXB0aW9uO1xuY2xhc3MgTm9TdWNoSW50ZXJjZXB0RXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBpbnRlcmNlcHRcIiAvKiBFcnJvckNvZGUuTm9TdWNoSW50ZXJjZXB0ICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbiA9IE5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaE5vZGVFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIG5vZGVcIiAvKiBFcnJvckNvZGUuTm9TdWNoTm9kZSAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hOb2RlRXhjZXB0aW9uID0gTm9TdWNoTm9kZUV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFJlcXVlc3RFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIHJlcXVlc3RcIiAvKiBFcnJvckNvZGUuTm9TdWNoUmVxdWVzdCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hSZXF1ZXN0RXhjZXB0aW9uID0gTm9TdWNoUmVxdWVzdEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFNjcmlwdEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggc2NyaXB0XCIgLyogRXJyb3JDb2RlLk5vU3VjaFNjcmlwdCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hTY3JpcHRFeGNlcHRpb24gPSBOb1N1Y2hTY3JpcHRFeGNlcHRpb247XG5jbGFzcyBOb1N1Y2hVc2VyQ29udGV4dEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggdXNlciBjb250ZXh0XCIgLyogRXJyb3JDb2RlLk5vU3VjaFVzZXJDb250ZXh0ICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uID0gTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb247XG5jbGFzcyBTZXNzaW9uTm90Q3JlYXRlZEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInNlc3Npb24gbm90IGNyZWF0ZWRcIiAvKiBFcnJvckNvZGUuU2Vzc2lvbk5vdENyZWF0ZWQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2Vzc2lvbk5vdENyZWF0ZWRFeGNlcHRpb24gPSBTZXNzaW9uTm90Q3JlYXRlZEV4Y2VwdGlvbjtcbmNsYXNzIFVua25vd25Db21tYW5kRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwidW5rbm93biBjb21tYW5kXCIgLyogRXJyb3JDb2RlLlVua25vd25Db21tYW5kICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25Db21tYW5kRXhjZXB0aW9uID0gVW5rbm93bkNvbW1hbmRFeGNlcHRpb247XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaykge1xuICAgICAgICBzdXBlcihcInVua25vd24gZXJyb3JcIiAvKiBFcnJvckNvZGUuVW5rbm93bkVycm9yICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcbmNsYXNzIFVuYWJsZVRvQ2FwdHVyZVNjcmVlbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBjYXB0dXJlIHNjcmVlblwiIC8qIEVycm9yQ29kZS5VbmFibGVUb0NhcHR1cmVTY3JlZW4gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXhjZXB0aW9uID0gVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXhjZXB0aW9uO1xuY2xhc3MgVW5hYmxlVG9DbG9zZUJyb3dzZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJ1bmFibGUgdG8gY2xvc2UgYnJvd3NlclwiIC8qIEVycm9yQ29kZS5VbmFibGVUb0Nsb3NlQnJvd3NlciAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmFibGVUb0Nsb3NlQnJvd3NlckV4Y2VwdGlvbiA9IFVuYWJsZVRvQ2xvc2VCcm93c2VyRXhjZXB0aW9uO1xuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiAvKiBFcnJvckNvZGUuVW5zdXBwb3J0ZWRPcGVyYXRpb24gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFN0b3JhZ2VQYXJ0aXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIHN0b3JhZ2UgcGFydGl0aW9uXCIgLyogRXJyb3JDb2RlLk5vU3VjaFN0b3JhZ2VQYXJ0aXRpb24gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbiA9IE5vU3VjaFN0b3JhZ2VQYXJ0aXRpb25FeGNlcHRpb247XG5jbGFzcyBVbmFibGVUb1NldENvb2tpZUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBzZXQgY29va2llXCIgLyogRXJyb3JDb2RlLlVuYWJsZVRvU2V0Q29va2llICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVuYWJsZVRvU2V0Q29va2llRXhjZXB0aW9uID0gVW5hYmxlVG9TZXRDb29raWVFeGNlcHRpb247XG5jbGFzcyBVbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBzZXQgZmlsZSBpbnB1dFwiIC8qIEVycm9yQ29kZS5VbmFibGVUb1NldEZpbGVJbnB1dCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbiA9IFVuYWJsZVRvU2V0RmlsZUlucHV0RXhjZXB0aW9uO1xuY2xhc3MgVW5kZXJzcGVjaWZpZWRTdG9yYWdlUGFydGl0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwidW5kZXJzcGVjaWZpZWQgc3RvcmFnZSBwYXJ0aXRpb25cIiAvKiBFcnJvckNvZGUuVW5kZXJzcGVjaWZpZWRTdG9yYWdlUGFydGl0aW9uICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVuZGVyc3BlY2lmaWVkU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbiA9IFVuZGVyc3BlY2lmaWVkU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yUmVzcG9uc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVZFTlRfTkFNRVMgPSBleHBvcnRzLk5ldHdvcmsgPSBleHBvcnRzLkJyb3dzaW5nQ29udGV4dCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5TY3JpcHQgPSBleHBvcnRzLkJpRGlNb2R1bGUgPSB2b2lkIDA7XG4vLyBrZWVwLXNvcnRlZCBlbmRcbnZhciBCaURpTW9kdWxlO1xuKGZ1bmN0aW9uIChCaURpTW9kdWxlKSB7XG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICBCaURpTW9kdWxlW1wiQnJvd3NlclwiXSA9IFwiYnJvd3NlclwiO1xuICAgIEJpRGlNb2R1bGVbXCJCcm93c2luZ0NvbnRleHRcIl0gPSBcImJyb3dzaW5nQ29udGV4dFwiO1xuICAgIEJpRGlNb2R1bGVbXCJDZHBcIl0gPSBcImNkcFwiO1xuICAgIEJpRGlNb2R1bGVbXCJJbnB1dFwiXSA9IFwiaW5wdXRcIjtcbiAgICBCaURpTW9kdWxlW1wiTG9nXCJdID0gXCJsb2dcIjtcbiAgICBCaURpTW9kdWxlW1wiTmV0d29ya1wiXSA9IFwibmV0d29ya1wiO1xuICAgIEJpRGlNb2R1bGVbXCJTY3JpcHRcIl0gPSBcInNjcmlwdFwiO1xuICAgIEJpRGlNb2R1bGVbXCJTZXNzaW9uXCJdID0gXCJzZXNzaW9uXCI7XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG59KShCaURpTW9kdWxlIHx8IChleHBvcnRzLkJpRGlNb2R1bGUgPSBCaURpTW9kdWxlID0ge30pKTtcbnZhciBTY3JpcHQ7XG4oZnVuY3Rpb24gKFNjcmlwdCkge1xuICAgIGxldCBFdmVudE5hbWVzO1xuICAgIChmdW5jdGlvbiAoRXZlbnROYW1lcykge1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydFxuICAgICAgICBFdmVudE5hbWVzW1wiTWVzc2FnZVwiXSA9IFwic2NyaXB0Lm1lc3NhZ2VcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIlJlYWxtQ3JlYXRlZFwiXSA9IFwic2NyaXB0LnJlYWxtQ3JlYXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiUmVhbG1EZXN0cm95ZWRcIl0gPSBcInNjcmlwdC5yZWFsbURlc3Ryb3llZFwiO1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICB9KShFdmVudE5hbWVzID0gU2NyaXB0LkV2ZW50TmFtZXMgfHwgKFNjcmlwdC5FdmVudE5hbWVzID0ge30pKTtcbn0pKFNjcmlwdCB8fCAoZXhwb3J0cy5TY3JpcHQgPSBTY3JpcHQgPSB7fSkpO1xudmFyIExvZztcbihmdW5jdGlvbiAoTG9nKSB7XG4gICAgbGV0IEV2ZW50TmFtZXM7XG4gICAgKGZ1bmN0aW9uIChFdmVudE5hbWVzKSB7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJMb2dFbnRyeUFkZGVkXCJdID0gXCJsb2cuZW50cnlBZGRlZFwiO1xuICAgIH0pKEV2ZW50TmFtZXMgPSBMb2cuRXZlbnROYW1lcyB8fCAoTG9nLkV2ZW50TmFtZXMgPSB7fSkpO1xufSkoTG9nIHx8IChleHBvcnRzLkxvZyA9IExvZyA9IHt9KSk7XG52YXIgQnJvd3NpbmdDb250ZXh0O1xuKGZ1bmN0aW9uIChCcm93c2luZ0NvbnRleHQpIHtcbiAgICBsZXQgRXZlbnROYW1lcztcbiAgICAoZnVuY3Rpb24gKEV2ZW50TmFtZXMpIHtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICAgICAgRXZlbnROYW1lc1tcIkNvbnRleHRDcmVhdGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQuY29udGV4dENyZWF0ZWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIkNvbnRleHREZXN0cm95ZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5jb250ZXh0RGVzdHJveWVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJEb21Db250ZW50TG9hZGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQuZG9tQ29udGVudExvYWRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRG93bmxvYWRXaWxsQmVnaW5cIl0gPSBcImJyb3dzaW5nQ29udGV4dC5kb3dubG9hZFdpbGxCZWdpblwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRnJhZ21lbnROYXZpZ2F0ZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5mcmFnbWVudE5hdmlnYXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiTG9hZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0LmxvYWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIk5hdmlnYXRpb25BYm9ydGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQubmF2aWdhdGlvbkFib3J0ZWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIk5hdmlnYXRpb25GYWlsZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uRmFpbGVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJOYXZpZ2F0aW9uU3RhcnRlZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25TdGFydGVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJVc2VyUHJvbXB0Q2xvc2VkXCJdID0gXCJicm93c2luZ0NvbnRleHQudXNlclByb21wdENsb3NlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiVXNlclByb21wdE9wZW5lZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0LnVzZXJQcm9tcHRPcGVuZWRcIjtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgfSkoRXZlbnROYW1lcyA9IEJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzIHx8IChCcm93c2luZ0NvbnRleHQuRXZlbnROYW1lcyA9IHt9KSk7XG59KShCcm93c2luZ0NvbnRleHQgfHwgKGV4cG9ydHMuQnJvd3NpbmdDb250ZXh0ID0gQnJvd3NpbmdDb250ZXh0ID0ge30pKTtcbnZhciBOZXR3b3JrO1xuKGZ1bmN0aW9uIChOZXR3b3JrKSB7XG4gICAgbGV0IEV2ZW50TmFtZXM7XG4gICAgKGZ1bmN0aW9uIChFdmVudE5hbWVzKSB7XG4gICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0XG4gICAgICAgIEV2ZW50TmFtZXNbXCJBdXRoUmVxdWlyZWRcIl0gPSBcIm5ldHdvcmsuYXV0aFJlcXVpcmVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJCZWZvcmVSZXF1ZXN0U2VudFwiXSA9IFwibmV0d29yay5iZWZvcmVSZXF1ZXN0U2VudFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRmV0Y2hFcnJvclwiXSA9IFwibmV0d29yay5mZXRjaEVycm9yXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJSZXNwb25zZUNvbXBsZXRlZFwiXSA9IFwibmV0d29yay5yZXNwb25zZUNvbXBsZXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiUmVzcG9uc2VTdGFydGVkXCJdID0gXCJuZXR3b3JrLnJlc3BvbnNlU3RhcnRlZFwiO1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICB9KShFdmVudE5hbWVzID0gTmV0d29yay5FdmVudE5hbWVzIHx8IChOZXR3b3JrLkV2ZW50TmFtZXMgPSB7fSkpO1xufSkoTmV0d29yayB8fCAoZXhwb3J0cy5OZXR3b3JrID0gTmV0d29yayA9IHt9KSk7XG5leHBvcnRzLkVWRU5UX05BTUVTID0gbmV3IFNldChbXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICAuLi5PYmplY3QudmFsdWVzKEJpRGlNb2R1bGUpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoTG9nLkV2ZW50TmFtZXMpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoTmV0d29yay5FdmVudE5hbWVzKSxcbiAgICAuLi5PYmplY3QudmFsdWVzKFNjcmlwdC5FdmVudE5hbWVzKSxcbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hyb21pdW0tYmlkaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZHJpdmVyLWJpZGktcGVybWlzc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmRyaXZlci1iaWRpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWl1bUJpZGkgPSBleHBvcnRzLkNkcCA9IHZvaWQgMDtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0cy5DZHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY2RwLmpzXCIpKTtcbmV4cG9ydHMuQ2hyb21pdW1CaWRpID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nocm9taXVtLWJpZGkuanNcIikpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dlbmVyYXRlZC93ZWJkcml2ZXItYmlkaS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRXJyb3JSZXNwb25zZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ2VuZXJhdGVkL3dlYmRyaXZlci1iaWRpLXBlcm1pc3Npb25zLmpzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvY29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NFRvU3RyaW5nID0gYmFzZTY0VG9TdHJpbmc7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gYmFzZTY0LlxuICpcbiAqIFVzZXMgdGhlIG5hdGl2ZSBXZWIgQVBJIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gYSBOb2RlSlMgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBiYXNlNjRUb1N0cmluZyhiYXNlNjRTdHIpIHtcbiAgICAvLyBBdmFpbGFibGUgb25seSBpZiBydW4gaW4gYSBicm93c2VyIGNvbnRleHQuXG4gICAgaWYgKCdhdG9iJyBpbiBnbG9iYWxUaGlzKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmF0b2IoYmFzZTY0U3RyKTtcbiAgICB9XG4gICAgLy8gQXZhaWxhYmxlIG9ubHkgaWYgcnVuIGluIGEgTm9kZUpTIGNvbnRleHQuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NFN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlciA9IHZvaWQgMDtcbi8qKiBJbXBsZW1lbnRzIGEgRklGTyBidWZmZXIgd2l0aCBhIGZpeGVkIHNpemUuICovXG5jbGFzcyBCdWZmZXIge1xuICAgICNjYXBhY2l0eTtcbiAgICAjZW50cmllcyA9IFtdO1xuICAgICNvbkl0ZW1SZW1vdmVkO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYXBhY2l0eSBUaGUgYnVmZmVyIGNhcGFjaXR5LlxuICAgICAqIEBwYXJhbSBvbkl0ZW1SZW1vdmVkIERlbGVnYXRlIGNhbGxlZCBmb3IgZWFjaCByZW1vdmVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FwYWNpdHksIG9uSXRlbVJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy4jY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy4jb25JdGVtUmVtb3ZlZCA9IG9uSXRlbVJlbW92ZWQ7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2VudHJpZXM7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNlbnRyaWVzLnB1c2godmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy4jZW50cmllcy5sZW5ndGggPiB0aGlzLiNjYXBhY2l0eSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuI2VudHJpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvbkl0ZW1SZW1vdmVkPy4oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0TWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIE1hcCB3aG9zZSBmdW5jdGlvbmFsaXR5IGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBpdHMgcGFyZW50XG4gKiBleGNlcHQgZm9yIHRoZSBmYWN0IHRoYXQgRGVmYXVsdE1hcCBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gSXQgcHJvdmlkZXMgYVxuICogZGVmYXVsdCB2YWx1ZSBmb3Iga2V5cyB0aGF0IGRvIG5vdCBleGlzdC5cbiAqL1xuY2xhc3MgRGVmYXVsdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgLyoqIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiB3aGVuZXZlciBhIGtleSBpcyBub3QgcHJlc2VudCBpbiB0aGUgbWFwLiAqL1xuICAgICNnZXREZWZhdWx0VmFsdWU7XG4gICAgY29uc3RydWN0b3IoZ2V0RGVmYXVsdFZhbHVlLCBlbnRyaWVzKSB7XG4gICAgICAgIHN1cGVyKGVudHJpZXMpO1xuICAgICAgICB0aGlzLiNnZXREZWZhdWx0VmFsdWUgPSBnZXREZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRoaXMuI2dldERlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0TWFwID0gRGVmYXVsdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmF1bHRNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmZXJyZWQgPSB2b2lkIDA7XG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgI2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAjcHJvbWlzZTtcbiAgICAjcmVzdWx0O1xuICAgICNyZXNvbHZlO1xuICAgICNyZWplY3Q7XG4gICAgZ2V0IGlzRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0ZpbmlzaGVkO1xuICAgIH1cbiAgICBnZXQgcmVzdWx0KCkge1xuICAgICAgICBpZiAoIXRoaXMuI2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmZXJyZWQgaXMgbm90IGZpbmlzaGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLiNyZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOZWVkZWQgdG8gYXZvaWQgYFVuY2F1Z2h0IChpbiBwcm9taXNlKWAuIFRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBgdGhlbmBcbiAgICAgICAgLy8gYW5kIGBjYXRjaGAgd2lsbCBiZSByZWplY3RlZCBhbnl3YXkuXG4gICAgICAgIHRoaXMuI3Byb21pc2UuY2F0Y2goKF9lcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfVxuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy4jaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy4jaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNyZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWplY3QocmVhc29uKSB7XG4gICAgICAgIGlmICghdGhpcy4jaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy4jaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNyZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvbWlzZS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ1Byb21pc2UnO1xufVxuZXhwb3J0cy5EZWZlcnJlZCA9IERlZmVycmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kaXN0aW5jdFZhbHVlcyA9IGRpc3RpbmN0VmFsdWVzO1xuZXhwb3J0cy5kZXRlcm1pbmlzdGljSlNPTlN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNKU09OU3RyaW5naWZ5O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpc3RpbmN0IHZhbHVlcy4gT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBmaWx0ZXIuIFNob3VsZCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbiAqIEByZXR1cm4gLSBBbiBhcnJheSBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBtYXAuc2V0KGRldGVybWluaXN0aWNKU09OU3RyaW5naWZ5KHZhbHVlKSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgb2JqZWN0IHdpdGgga2V5cyBzb3J0ZWQuIFRoaXMgaXMgcmVxdWlyZWQgdG9cbiAqIGVuc3VyZSB0aGF0IHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIGFuIG9iamVjdCBpcyBkZXRlcm1pbmlzdGljIGluZGVwZW5kZW50IG9mIHRoZVxuICogb3JkZXIgb2Yga2V5cy5cbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0pTT05TdHJpbmdpZnkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZU9iamVjdChvYmopKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgb2JqID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBDb3B5IHRoZSBvcmlnaW5hbCBvYmplY3Qga2V5IGFuZCB2YWx1ZXMgdG8gYSBuZXcgb2JqZWN0IGluIHNvcnRlZCBvcmRlci5cbiAgICBjb25zdCBuZXdPYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBuZXdPYmpba2V5XSA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZSk7IC8vIFJlY3Vyc2l2ZWx5IHNvcnQgbmVzdGVkIG9iamVjdHNcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3RpbmN0VmFsdWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG1pdHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWl0dFwiKSk7XG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICAgICNlbWl0dGVyID0gKDAsIG1pdHRfMS5kZWZhdWx0KSgpO1xuICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy4jZW1pdHRlci5vbih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2UgYG9uYCBidXQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBmaXJlZCBvbmNlIGFuZCB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHlvdSdkIGxpa2UgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIGV2ZW50IG9jY3Vyc1xuICAgICAqIEByZXR1cm4gYHRoaXNgIHRvIGVuYWJsZSBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgb25jZShldmVudCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBvbmNlSGFuZGxlciA9IChldmVudERhdGEpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIoZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIub2ZmKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYW5kIGNhbGwgYW55IGFzc29jaWF0ZWQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBlbWl0LlxuICAgICAqIEBwYXJhbSBldmVudERhdGEgQW55IGRhdGEgdG8gZW1pdCB3aXRoIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGVyZSBhcmUgYW55IGxpc3RlbmVycywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZW1pdChldmVudCwgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIuZW1pdChldmVudCwgZXZlbnREYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJZiBnaXZlbiBhbiBldmVudCBhcmd1bWVudCwgaXQgd2lsbCByZW1vdmUgb25seVxuICAgICAqIGxpc3RlbmVycyBmb3IgdGhhdCBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHJldHVybnMgYHRoaXNgIHRvIGVuYWJsZSB5b3UgdG8gY2hhaW4gbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXR0ZXIuYWxsLmRlbGV0ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNlbWl0dGVyLmFsbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRFbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNTaW5nbGVDb21wbGV4R3JhcGhlbWUgPSBpc1NpbmdsZUNvbXBsZXhHcmFwaGVtZTtcbmV4cG9ydHMuaXNTaW5nbGVHcmFwaGVtZSA9IGlzU2luZ2xlR3JhcGhlbWU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzaW5nbGUgY29tcGxleCBncmFwaGVtZS4gQSBjb21wbGV4IGdyYXBoZW1lIGlzIG9uZSB0aGF0XG4gKiBpcyBtYWRlIHVwIG9mIG11bHRpcGxlIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlQ29tcGxleEdyYXBoZW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU2luZ2xlR3JhcGhlbWUodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDE7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlR3JhcGhlbWUodmFsdWUpIHtcbiAgICAvLyBUaGVvcmV0aWNhbGx5IHRoZXJlIGNhbiBiZSBzb21lIHN0cmluZ3MgY29uc2lkZXJlZCBhIGdyYXBoZW1lIGluIHNvbWUgbG9jYWxlcywgbGlrZVxuICAgIC8vIHNsb3ZhayBcImNoXCIgZGlncmFwaC4gVXNlIGVuZ2xpc2ggbG9jYWxlIGZvciBjb25zaXN0ZW5jeS5cbiAgICAvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0dyYXBoZW1lX0NsdXN0ZXJfQm91bmRhcmllc1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcignZW4nLCB7IGdyYW51bGFyaXR5OiAnZ3JhcGhlbWUnIH0pO1xuICAgIHJldHVybiBbLi4uc2VnbWVudGVyLnNlZ21lbnQodmFsdWUpXS5sZW5ndGggPT09IDE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGVtZVRvb2xzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkV3JhcHBlciA9IHZvaWQgMDtcbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCBhIHBvc2l0aXZlIHVuaXF1ZSBpbmNyZW1lbnRpbmcgaWQuXG4gKi9cbmNsYXNzIElkV3JhcHBlciB7XG4gICAgc3RhdGljICNjb3VudGVyID0gMDtcbiAgICAjaWQ7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2lkID0gKytJZFdyYXBwZXIuI2NvdW50ZXI7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbn1cbmV4cG9ydHMuSWRXcmFwcGVyID0gSWRXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWRXcmFwcGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKiBDb3B5cmlnaHQgMjAyMiBUaGUgQ2hyb21pdW0gQXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXV0ZXggPSB2b2lkIDA7XG4vKipcbiAqIFVzZSBNdXRleCBjbGFzcyB0byBjb29yZGluYXRlIGxvY2FsIGNvbmN1cnJlbnQgb3BlcmF0aW9ucy5cbiAqIE9uY2UgYGFjcXVpcmVgIHByb21pc2UgcmVzb2x2ZXMsIHlvdSBob2xkIHRoZSBsb2NrIGFuZCBtdXN0XG4gKiBjYWxsIGByZWxlYXNlYCBmdW5jdGlvbiByZXR1cm5lZCBieSBgYWNxdWlyZWAgdG8gcmVsZWFzZSB0aGVcbiAqIGxvY2suIEZhaWxpbmcgdG8gYHJlbGVhc2VgIHRoZSBsb2NrIG1heSBsZWFkIHRvIGRlYWRsb2Nrcy5cbiAqL1xuY2xhc3MgTXV0ZXgge1xuICAgICNsb2NrZWQgPSBmYWxzZTtcbiAgICAjYWNxdWlyZXJzID0gW107XG4gICAgLy8gVGhpcyBpcyBGSUZPLlxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyByZXNvbHZlZDogZmFsc2UgfTtcbiAgICAgICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYWNxdWlyZXJzLnB1c2goKCkgPT4gcmVzb2x2ZSh0aGlzLiNyZWxlYXNlLmJpbmQodGhpcywgc3RhdGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuI3JlbGVhc2UuYmluZCh0aGlzLCBzdGF0ZSkpO1xuICAgIH1cbiAgICAjcmVsZWFzZShzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbGVhc2UgbW9yZSB0aGFuIG9uY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy4jYWNxdWlyZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghcmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBydW4oYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5vdGUgd2UgbmVlZCB0byBhd2FpdCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYXdhaXQgdG8gcmVsZWFzZSBBRlRFUlxuICAgICAgICAgICAgLy8gdGhhdCBhd2FpdCBoYXBwZW5zLiBSZXR1cm5pbmcgYWN0aW9uKCkgd2lsbCB0cmlnZ2VyIHRoZSByZWxlYXNlXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSB3aGljaCBpcyBjb3VudGVyIHRvIHdoYXQgd2Ugd2FudC5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTXV0ZXggPSBNdXRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11dGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4vbG9nLmpzXCIpO1xuY2xhc3MgUHJvY2Vzc2luZ1F1ZXVlIHtcbiAgICBzdGF0aWMgTE9HR0VSX1BSRUZJWCA9IGAke2xvZ19qc18xLkxvZ1R5cGUuZGVidWd9OnF1ZXVlYDtcbiAgICAjbG9nZ2VyO1xuICAgICNwcm9jZXNzb3I7XG4gICAgI3F1ZXVlID0gW107XG4gICAgLy8gRmxhZyB0byBrZWVwIG9ubHkgMSBhY3RpdmUgcHJvY2Vzc29yLlxuICAgICNpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNwcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgYWRkKGVudHJ5LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuI3F1ZXVlLnB1c2goW2VudHJ5LCBuYW1lXSk7XG4gICAgICAgIC8vIE5vIG5lZWQgaW4gd2FpdGluZy4gSnVzdCBpbml0aWFsaXplIHByb2Nlc3NvciBpZiBuZWVkZWQuXG4gICAgICAgIHZvaWQgdGhpcy4jcHJvY2Vzc0lmTmVlZGVkKCk7XG4gICAgfVxuICAgIGFzeW5jICNwcm9jZXNzSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy4jcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlFbnRyeSA9IHRoaXMuI3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWFycmF5RW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtlbnRyeVByb21pc2UsIG5hbWVdID0gYXJyYXlFbnRyeTtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKFByb2Nlc3NpbmdRdWV1ZS5MT0dHRVJfUFJFRklYLCAnUHJvY2Vzc2luZyBldmVudDonLCBuYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGVudHJ5UHJvbWlzZVxuICAgICAgICAgICAgICAgIC50aGVuKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5raW5kID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ0V2ZW50IHRocmV3IGJlZm9yZSBzZW5kaW5nOicsIGVudHJ5LmVycm9yLm1lc3NhZ2UsIGVudHJ5LmVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jcHJvY2Vzc29yKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ0V2ZW50IHdhcyBub3QgcHJvY2Vzc2VkOicsIGVycm9yPy5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2lzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvY2Vzc2luZ1F1ZXVlID0gUHJvY2Vzc2luZ1F1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvY2Vzc2luZ1F1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUkxQYXR0ZXJuID0gdm9pZCAwO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCB1cmxwYXR0ZXJuX3BvbHlmaWxsXzEgPSByZXF1aXJlKFwidXJscGF0dGVybi1wb2x5ZmlsbFwiKTtcbi8vIFhYWDogU3dpdGNoIHRvIG5hdGl2ZSBVUkxQYXR0ZXJuIHdoZW4gYXZhaWxhYmxlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MDg0NFxubGV0IFVSTFBhdHRlcm4gPSB1cmxwYXR0ZXJuX3BvbHlmaWxsXzEuVVJMUGF0dGVybjtcbmV4cG9ydHMuVVJMUGF0dGVybiA9IFVSTFBhdHRlcm47XG5pZiAoJ1VSTFBhdHRlcm4nIGluIGdsb2JhbFRoaXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZ2xvYmFsLWFzc2lnblxuICAgIGV4cG9ydHMuVVJMUGF0dGVybiA9IFVSTFBhdHRlcm4gPSBnbG9iYWxUaGlzLlVSTFBhdHRlcm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VcmxQYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/PyAnSW50ZXJuYWwgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nVHlwZSA9IHZvaWQgMDtcbnZhciBMb2dUeXBlO1xuKGZ1bmN0aW9uIChMb2dUeXBlKSB7XG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICBMb2dUeXBlW1wiYmlkaVwiXSA9IFwiYmlkaVwiO1xuICAgIExvZ1R5cGVbXCJjZHBcIl0gPSBcImNkcFwiO1xuICAgIExvZ1R5cGVbXCJkZWJ1Z1wiXSA9IFwiZGVidWdcIjtcbiAgICBMb2dUeXBlW1wiZGVidWdFcnJvclwiXSA9IFwiZGVidWc6ZXJyb3JcIjtcbiAgICBMb2dUeXBlW1wiZGVidWdJbmZvXCJdID0gXCJkZWJ1ZzppbmZvXCI7XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG59KShMb2dUeXBlIHx8IChleHBvcnRzLkxvZ1R5cGUgPSBMb2dUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmNoZXNGcm9tQ20gPSBpbmNoZXNGcm9tQ207XG4vKiogQHJldHVybiBHaXZlbiBhbiBpbnB1dCBpbiBjbSwgY29udmVydCBpdCB0byBpbmNoZXMuICovXG5mdW5jdGlvbiBpbmNoZXNGcm9tQ20oY20pIHtcbiAgICByZXR1cm4gY20gLyAyLjU0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pdENvbnZlcnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV1aWR2NCA9IHV1aWR2NDtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHY0IFVVSUQsIGFzIHNwZWNpZmllZCBpbiBSRkM0MTIyLlxuICpcbiAqIFVzZXMgdGhlIG5hdGl2ZSBXZWIgQ3J5cHRvIEFQSSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxscyBiYWNrIHRvIGFcbiAqIHBvbHlmaWxsLlxuICpcbiAqIEV4YW1wbGU6ICc5YjFkZWI0ZC0zYjdkLTRiYWQtOWJkZC0yYjBkN2IzZGNiNmQnXG4gKi9cbmZ1bmN0aW9uIHV1aWR2NCgpIHtcbiAgICAvLyBBdmFpbGFibGUgb25seSBpbiBzZWN1cmUgY29udGV4dHNcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0NyeXB0b19BUElcbiAgICBpZiAoJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyAmJiAncmFuZG9tVVVJRCcgaW4gZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICAgICAgLy8gTm9kZSB3aXRoXG4gICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MjAueC9kb2NzL2FwaS9nbG9iYWxzLmh0bWwjY3J5cHRvXzEgb3JcbiAgICAgICAgLy8gc2VjdXJlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZG9tVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGlmICgnY3J5cHRvJyBpbiBnbG9iYWxUaGlzICYmICdnZXRSYW5kb21WYWx1ZXMnIGluIGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgICAgIC8vIE5vZGUgKD49MTgpIHdpdGhcbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYyMC54L2RvY3MvYXBpL2dsb2JhbHMuaHRtbCNjcnlwdG9fMSBvclxuICAgICAgICAvLyBicm93c2VyLlxuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tVmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgKDw9MTYpIHdpdGhvdXRcbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYyMC54L2RvY3MvYXBpL2dsb2JhbHMuaHRtbCNjcnlwdG9fMS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICByZXF1aXJlKCdjcnlwdG8nKS53ZWJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbVZhbHVlcyk7XG4gICAgfVxuICAgIC8vIFNldCB2ZXJzaW9uICg0KSBhbmQgdmFyaWFudCAoUkZDNDEyMikgYml0cy5cbiAgICByYW5kb21WYWx1ZXNbNl0gPSAocmFuZG9tVmFsdWVzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJhbmRvbVZhbHVlc1s4XSA9IChyYW5kb21WYWx1ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYnl0ZXNUb0hleChyYW5kb21WYWx1ZXMuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgICBieXRlc1RvSGV4KHJhbmRvbVZhbHVlcy5zdWJhcnJheSg0LCA2KSksXG4gICAgICAgIGJ5dGVzVG9IZXgocmFuZG9tVmFsdWVzLnN1YmFycmF5KDYsIDgpKSxcbiAgICAgICAgYnl0ZXNUb0hleChyYW5kb21WYWx1ZXMuc3ViYXJyYXkoOCwgMTApKSxcbiAgICAgICAgYnl0ZXNUb0hleChyYW5kb21WYWx1ZXMuc3ViYXJyYXkoMTAsIDE2KSksXG4gICAgXS5qb2luKCctJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO3ZhciBNPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgUGU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgUmU9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIEVlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIE9lPShlLHQpPT57Zm9yKHZhciByIGluIHQpTShlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sa2U9KGUsdCxyLG4pPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBhIG9mIFJlKHQpKSFFZS5jYWxsKGUsYSkmJmEhPT1yJiZNKGUsYSx7Z2V0OigpPT50W2FdLGVudW1lcmFibGU6IShuPVBlKHQsYSkpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIFRlPWU9PmtlKE0oe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSk7dmFyIE5lPXt9O09lKE5lLHtVUkxQYXR0ZXJuOigpPT5ZfSk7bW9kdWxlLmV4cG9ydHM9VGUoTmUpO3ZhciBSPWNsYXNze3R5cGU9MztuYW1lPVwiXCI7cHJlZml4PVwiXCI7dmFsdWU9XCJcIjtzdWZmaXg9XCJcIjttb2RpZmllcj0zO2NvbnN0cnVjdG9yKHQscixuLGEsYyxsKXt0aGlzLnR5cGU9dCx0aGlzLm5hbWU9cix0aGlzLnByZWZpeD1uLHRoaXMudmFsdWU9YSx0aGlzLnN1ZmZpeD1jLHRoaXMubW9kaWZpZXI9bH1oYXNDdXN0b21OYW1lKCl7cmV0dXJuIHRoaXMubmFtZSE9PVwiXCImJnR5cGVvZiB0aGlzLm5hbWUhPVwibnVtYmVyXCJ9fSxBZT0vWyRfXFxwe0lEX1N0YXJ0fV0vdSx5ZT0vWyRfXFx1MjAwQ1xcdTIwMERcXHB7SURfQ29udGludWV9XS91LHY9XCIuKlwiO2Z1bmN0aW9uIHdlKGUsdCl7cmV0dXJuKHQ/L15bXFx4MDAtXFx4RkZdKiQvOi9eW1xceDAwLVxceDdGXSokLykudGVzdChlKX1mdW5jdGlvbiBEKGUsdD0hMSl7bGV0IHI9W10sbj0wO2Zvcig7bjxlLmxlbmd0aDspe2xldCBhPWVbbl0sYz1mdW5jdGlvbihsKXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKGwpO3IucHVzaCh7dHlwZTpcIklOVkFMSURfQ0hBUlwiLGluZGV4Om4sdmFsdWU6ZVtuKytdfSl9O2lmKGE9PT1cIipcIil7ci5wdXNoKHt0eXBlOlwiQVNURVJJU0tcIixpbmRleDpuLHZhbHVlOmVbbisrXX0pO2NvbnRpbnVlfWlmKGE9PT1cIitcInx8YT09PVwiP1wiKXtyLnB1c2goe3R5cGU6XCJPVEhFUl9NT0RJRklFUlwiLGluZGV4Om4sdmFsdWU6ZVtuKytdfSk7Y29udGludWV9aWYoYT09PVwiXFxcXFwiKXtyLnB1c2goe3R5cGU6XCJFU0NBUEVEX0NIQVJcIixpbmRleDpuKyssdmFsdWU6ZVtuKytdfSk7Y29udGludWV9aWYoYT09PVwie1wiKXtyLnB1c2goe3R5cGU6XCJPUEVOXCIsaW5kZXg6bix2YWx1ZTplW24rK119KTtjb250aW51ZX1pZihhPT09XCJ9XCIpe3IucHVzaCh7dHlwZTpcIkNMT1NFXCIsaW5kZXg6bix2YWx1ZTplW24rK119KTtjb250aW51ZX1pZihhPT09XCI6XCIpe2xldCBsPVwiXCIscz1uKzE7Zm9yKDtzPGUubGVuZ3RoOyl7bGV0IGk9ZS5zdWJzdHIocywxKTtpZihzPT09bisxJiZBZS50ZXN0KGkpfHxzIT09bisxJiZ5ZS50ZXN0KGkpKXtsKz1lW3MrK107Y29udGludWV9YnJlYWt9aWYoIWwpe2MoYE1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgJHtufWApO2NvbnRpbnVlfXIucHVzaCh7dHlwZTpcIk5BTUVcIixpbmRleDpuLHZhbHVlOmx9KSxuPXM7Y29udGludWV9aWYoYT09PVwiKFwiKXtsZXQgbD0xLHM9XCJcIixpPW4rMSxvPSExO2lmKGVbaV09PT1cIj9cIil7YyhgUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcIj9cIiBhdCAke2l9YCk7Y29udGludWV9Zm9yKDtpPGUubGVuZ3RoOyl7aWYoIXdlKGVbaV0sITEpKXtjKGBJbnZhbGlkIGNoYXJhY3RlciAnJHtlW2ldfScgYXQgJHtpfS5gKSxvPSEwO2JyZWFrfWlmKGVbaV09PT1cIlxcXFxcIil7cys9ZVtpKytdK2VbaSsrXTtjb250aW51ZX1pZihlW2ldPT09XCIpXCIpe2lmKGwtLSxsPT09MCl7aSsrO2JyZWFrfX1lbHNlIGlmKGVbaV09PT1cIihcIiYmKGwrKyxlW2krMV0hPT1cIj9cIikpe2MoYENhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0ICR7aX1gKSxvPSEwO2JyZWFrfXMrPWVbaSsrXX1pZihvKWNvbnRpbnVlO2lmKGwpe2MoYFVuYmFsYW5jZWQgcGF0dGVybiBhdCAke259YCk7Y29udGludWV9aWYoIXMpe2MoYE1pc3NpbmcgcGF0dGVybiBhdCAke259YCk7Y29udGludWV9ci5wdXNoKHt0eXBlOlwiUkVHRVhcIixpbmRleDpuLHZhbHVlOnN9KSxuPWk7Y29udGludWV9ci5wdXNoKHt0eXBlOlwiQ0hBUlwiLGluZGV4Om4sdmFsdWU6ZVtuKytdfSl9cmV0dXJuIHIucHVzaCh7dHlwZTpcIkVORFwiLGluZGV4Om4sdmFsdWU6XCJcIn0pLHJ9ZnVuY3Rpb24gRihlLHQ9e30pe2xldCByPUQoZSk7dC5kZWxpbWl0ZXI/Pz1cIi8jP1wiLHQucHJlZml4ZXM/Pz1cIi4vXCI7bGV0IG49YFteJHtTKHQuZGVsaW1pdGVyKX1dKz9gLGE9W10sYz0wLGw9MCxzPVwiXCIsaT1uZXcgU2V0LG89aD0+e2lmKGw8ci5sZW5ndGgmJnJbbF0udHlwZT09PWgpcmV0dXJuIHJbbCsrXS52YWx1ZX0sZj0oKT0+byhcIk9USEVSX01PRElGSUVSXCIpPz9vKFwiQVNURVJJU0tcIiksZD1oPT57bGV0IHU9byhoKTtpZih1IT09dm9pZCAwKXJldHVybiB1O2xldHt0eXBlOnAsaW5kZXg6QX09cltsXTt0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmV4cGVjdGVkICR7cH0gYXQgJHtBfSwgZXhwZWN0ZWQgJHtofWApfSxUPSgpPT57bGV0IGg9XCJcIix1O2Zvcig7dT1vKFwiQ0hBUlwiKT8/byhcIkVTQ0FQRURfQ0hBUlwiKTspaCs9dTtyZXR1cm4gaH0seGU9aD0+aCxMPXQuZW5jb2RlUGFydHx8eGUsST1cIlwiLFU9aD0+e0krPWh9LCQ9KCk9PntJLmxlbmd0aCYmKGEucHVzaChuZXcgUigzLFwiXCIsXCJcIixMKEkpLFwiXCIsMykpLEk9XCJcIil9LFg9KGgsdSxwLEEsWik9PntsZXQgZz0zO3N3aXRjaChaKXtjYXNlXCI/XCI6Zz0xO2JyZWFrO2Nhc2VcIipcIjpnPTA7YnJlYWs7Y2FzZVwiK1wiOmc9MjticmVha31pZighdSYmIXAmJmc9PT0zKXtVKGgpO3JldHVybn1pZigkKCksIXUmJiFwKXtpZighaClyZXR1cm47YS5wdXNoKG5ldyBSKDMsXCJcIixcIlwiLEwoaCksXCJcIixnKSk7cmV0dXJufWxldCBtO3A/cD09PVwiKlwiP209djptPXA6bT1uO2xldCBPPTI7bT09PW4/KE89MSxtPVwiXCIpOm09PT12JiYoTz0wLG09XCJcIik7bGV0IFA7aWYodT9QPXU6cCYmKFA9YysrKSxpLmhhcyhQKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBEdXBsaWNhdGUgbmFtZSAnJHtQfScuYCk7aS5hZGQoUCksYS5wdXNoKG5ldyBSKE8sUCxMKGgpLG0sTChBKSxnKSl9O2Zvcig7bDxyLmxlbmd0aDspe2xldCBoPW8oXCJDSEFSXCIpLHU9byhcIk5BTUVcIikscD1vKFwiUkVHRVhcIik7aWYoIXUmJiFwJiYocD1vKFwiQVNURVJJU0tcIikpLHV8fHApe2xldCBnPWg/P1wiXCI7dC5wcmVmaXhlcy5pbmRleE9mKGcpPT09LTEmJihVKGcpLGc9XCJcIiksJCgpO2xldCBtPWYoKTtYKGcsdSxwLFwiXCIsbSk7Y29udGludWV9bGV0IEE9aD8/byhcIkVTQ0FQRURfQ0hBUlwiKTtpZihBKXtVKEEpO2NvbnRpbnVlfWlmKG8oXCJPUEVOXCIpKXtsZXQgZz1UKCksbT1vKFwiTkFNRVwiKSxPPW8oXCJSRUdFWFwiKTshbSYmIU8mJihPPW8oXCJBU1RFUklTS1wiKSk7bGV0IFA9VCgpO2QoXCJDTE9TRVwiKTtsZXQgYmU9ZigpO1goZyxtLE8sUCxiZSk7Y29udGludWV9JCgpLGQoXCJFTkRcIil9cmV0dXJuIGF9ZnVuY3Rpb24gUyhlKXtyZXR1cm4gZS5yZXBsYWNlKC8oWy4rKj9eJHt9KClbXFxdfC9cXFxcXSkvZyxcIlxcXFwkMVwiKX1mdW5jdGlvbiBCKGUpe3JldHVybiBlJiZlLmlnbm9yZUNhc2U/XCJ1aVwiOlwidVwifWZ1bmN0aW9uIHEoZSx0LHIpe3JldHVybiBXKEYoZSxyKSx0LHIpfWZ1bmN0aW9uIGsoZSl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm5cIipcIjtjYXNlIDE6cmV0dXJuXCI/XCI7Y2FzZSAyOnJldHVyblwiK1wiO2Nhc2UgMzpyZXR1cm5cIlwifX1mdW5jdGlvbiBXKGUsdCxyPXt9KXtyLmRlbGltaXRlcj8/PVwiLyM/XCIsci5wcmVmaXhlcz8/PVwiLi9cIixyLnNlbnNpdGl2ZT8/PSExLHIuc3RyaWN0Pz89ITEsci5lbmQ/Pz0hMCxyLnN0YXJ0Pz89ITAsci5lbmRzV2l0aD1cIlwiO2xldCBuPXIuc3RhcnQ/XCJeXCI6XCJcIjtmb3IobGV0IHMgb2YgZSl7aWYocy50eXBlPT09Myl7cy5tb2RpZmllcj09PTM/bis9UyhzLnZhbHVlKTpuKz1gKD86JHtTKHMudmFsdWUpfSkke2socy5tb2RpZmllcil9YDtjb250aW51ZX10JiZ0LnB1c2gocy5uYW1lKTtsZXQgaT1gW14ke1Moci5kZWxpbWl0ZXIpfV0rP2Asbz1zLnZhbHVlO2lmKHMudHlwZT09PTE/bz1pOnMudHlwZT09PTAmJihvPXYpLCFzLnByZWZpeC5sZW5ndGgmJiFzLnN1ZmZpeC5sZW5ndGgpe3MubW9kaWZpZXI9PT0zfHxzLm1vZGlmaWVyPT09MT9uKz1gKCR7b30pJHtrKHMubW9kaWZpZXIpfWA6bis9YCgoPzoke299KSR7ayhzLm1vZGlmaWVyKX0pYDtjb250aW51ZX1pZihzLm1vZGlmaWVyPT09M3x8cy5tb2RpZmllcj09PTEpe24rPWAoPzoke1Mocy5wcmVmaXgpfSgke299KSR7UyhzLnN1ZmZpeCl9KWAsbis9ayhzLm1vZGlmaWVyKTtjb250aW51ZX1uKz1gKD86JHtTKHMucHJlZml4KX1gLG4rPWAoKD86JHtvfSkoPzpgLG4rPVMocy5zdWZmaXgpLG4rPVMocy5wcmVmaXgpLG4rPWAoPzoke299KSkqKSR7UyhzLnN1ZmZpeCl9KWAscy5tb2RpZmllcj09PTAmJihuKz1cIj9cIil9bGV0IGE9YFske1Moci5lbmRzV2l0aCl9XXwkYCxjPWBbJHtTKHIuZGVsaW1pdGVyKX1dYDtpZihyLmVuZClyZXR1cm4gci5zdHJpY3R8fChuKz1gJHtjfT9gKSxyLmVuZHNXaXRoLmxlbmd0aD9uKz1gKD89JHthfSlgOm4rPVwiJFwiLG5ldyBSZWdFeHAobixCKHIpKTtyLnN0cmljdHx8KG4rPWAoPzoke2N9KD89JHthfSkpP2ApO2xldCBsPSExO2lmKGUubGVuZ3RoKXtsZXQgcz1lW2UubGVuZ3RoLTFdO3MudHlwZT09PTMmJnMubW9kaWZpZXI9PT0zJiYobD1yLmRlbGltaXRlci5pbmRleE9mKHMpPi0xKX1yZXR1cm4gbHx8KG4rPWAoPz0ke2N9fCR7YX0pYCksbmV3IFJlZ0V4cChuLEIocikpfXZhciB4PXtkZWxpbWl0ZXI6XCJcIixwcmVmaXhlczpcIlwiLHNlbnNpdGl2ZTohMCxzdHJpY3Q6ITB9LEo9e2RlbGltaXRlcjpcIi5cIixwcmVmaXhlczpcIlwiLHNlbnNpdGl2ZTohMCxzdHJpY3Q6ITB9LFE9e2RlbGltaXRlcjpcIi9cIixwcmVmaXhlczpcIi9cIixzZW5zaXRpdmU6ITAsc3RyaWN0OiEwfTtmdW5jdGlvbiBlZShlLHQpe3JldHVybiBlLmxlbmd0aD9lWzBdPT09XCIvXCI/ITA6IXR8fGUubGVuZ3RoPDI/ITE6KGVbMF09PVwiXFxcXFwifHxlWzBdPT1cIntcIikmJmVbMV09PVwiL1wiOiExfWZ1bmN0aW9uIHRlKGUsdCl7cmV0dXJuIGUuc3RhcnRzV2l0aCh0KT9lLnN1YnN0cmluZyh0Lmxlbmd0aCxlLmxlbmd0aCk6ZX1mdW5jdGlvbiBDZShlLHQpe3JldHVybiBlLmVuZHNXaXRoKHQpP2Uuc3Vic3RyKDAsZS5sZW5ndGgtdC5sZW5ndGgpOmV9ZnVuY3Rpb24gXyhlKXtyZXR1cm4hZXx8ZS5sZW5ndGg8Mj8hMTplWzBdPT09XCJbXCJ8fChlWzBdPT09XCJcXFxcXCJ8fGVbMF09PT1cIntcIikmJmVbMV09PT1cIltcIn12YXIgcmU9W1wiZnRwXCIsXCJmaWxlXCIsXCJodHRwXCIsXCJodHRwc1wiLFwid3NcIixcIndzc1wiXTtmdW5jdGlvbiBOKGUpe2lmKCFlKXJldHVybiEwO2ZvcihsZXQgdCBvZiByZSlpZihlLnRlc3QodCkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gbmUoZSx0KXtpZihlPXRlKGUsXCIjXCIpLHR8fGU9PT1cIlwiKXJldHVybiBlO2xldCByPW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiByLmhhc2g9ZSxyLmhhc2g/ci5oYXNoLnN1YnN0cmluZygxLHIuaGFzaC5sZW5ndGgpOlwiXCJ9ZnVuY3Rpb24gc2UoZSx0KXtpZihlPXRlKGUsXCI/XCIpLHR8fGU9PT1cIlwiKXJldHVybiBlO2xldCByPW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiByLnNlYXJjaD1lLHIuc2VhcmNoP3Iuc2VhcmNoLnN1YnN0cmluZygxLHIuc2VhcmNoLmxlbmd0aCk6XCJcIn1mdW5jdGlvbiBpZShlLHQpe3JldHVybiB0fHxlPT09XCJcIj9lOl8oZSk/SyhlKTpqKGUpfWZ1bmN0aW9uIGFlKGUsdCl7aWYodHx8ZT09PVwiXCIpcmV0dXJuIGU7bGV0IHI9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHIucGFzc3dvcmQ9ZSxyLnBhc3N3b3JkfWZ1bmN0aW9uIG9lKGUsdCl7aWYodHx8ZT09PVwiXCIpcmV0dXJuIGU7bGV0IHI9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHIudXNlcm5hbWU9ZSxyLnVzZXJuYW1lfWZ1bmN0aW9uIGNlKGUsdCxyKXtpZihyfHxlPT09XCJcIilyZXR1cm4gZTtpZih0JiYhcmUuaW5jbHVkZXModCkpcmV0dXJuIG5ldyBVUkwoYCR7dH06JHtlfWApLnBhdGhuYW1lO2xldCBuPWVbMF09PVwiL1wiO3JldHVybiBlPW5ldyBVUkwobj9lOlwiLy1cIitlLFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKS5wYXRobmFtZSxufHwoZT1lLnN1YnN0cmluZygyLGUubGVuZ3RoKSksZX1mdW5jdGlvbiBsZShlLHQscil7cmV0dXJuIHoodCk9PT1lJiYoZT1cIlwiKSxyfHxlPT09XCJcIj9lOkcoZSl9ZnVuY3Rpb24gZmUoZSx0KXtyZXR1cm4gZT1DZShlLFwiOlwiKSx0fHxlPT09XCJcIj9lOnkoZSl9ZnVuY3Rpb24geihlKXtzd2l0Y2goZSl7Y2FzZVwid3NcIjpjYXNlXCJodHRwXCI6cmV0dXJuXCI4MFwiO2Nhc2VcInd3c1wiOmNhc2VcImh0dHBzXCI6cmV0dXJuXCI0NDNcIjtjYXNlXCJmdHBcIjpyZXR1cm5cIjIxXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX1mdW5jdGlvbiB5KGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2lmKC9eWy0rLkEtWmEtejAtOV0qJC8udGVzdChlKSlyZXR1cm4gZS50b0xvd2VyQ2FzZSgpO3Rocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJvdG9jb2wgJyR7ZX0nLmApfWZ1bmN0aW9uIGhlKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0LnVzZXJuYW1lPWUsdC51c2VybmFtZX1mdW5jdGlvbiB1ZShlKXtpZihlPT09XCJcIilyZXR1cm4gZTtsZXQgdD1uZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtyZXR1cm4gdC5wYXNzd29yZD1lLHQucGFzc3dvcmR9ZnVuY3Rpb24gaihlKXtpZihlPT09XCJcIilyZXR1cm4gZTtpZigvW1xcdFxcblxcciAjJS86PD4/QFtcXF1eXFxcXHxdL2cudGVzdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGhvc3RuYW1lICcke2V9J2ApO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0Lmhvc3RuYW1lPWUsdC5ob3N0bmFtZX1mdW5jdGlvbiBLKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2lmKC9bXjAtOWEtZkEtRltcXF06XS9nLnRlc3QoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBJUHY2IGhvc3RuYW1lICcke2V9J2ApO3JldHVybiBlLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gRyhlKXtpZihlPT09XCJcInx8L15bMC05XSokLy50ZXN0KGUpJiZwYXJzZUludChlKTw9NjU1MzUpcmV0dXJuIGU7dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwb3J0ICcke2V9Jy5gKX1mdW5jdGlvbiBkZShlKXtpZihlPT09XCJcIilyZXR1cm4gZTtsZXQgdD1uZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtyZXR1cm4gdC5wYXRobmFtZT1lWzBdIT09XCIvXCI/XCIvLVwiK2U6ZSxlWzBdIT09XCIvXCI/dC5wYXRobmFtZS5zdWJzdHJpbmcoMix0LnBhdGhuYW1lLmxlbmd0aCk6dC5wYXRobmFtZX1mdW5jdGlvbiBwZShlKXtyZXR1cm4gZT09PVwiXCI/ZTpuZXcgVVJMKGBkYXRhOiR7ZX1gKS5wYXRobmFtZX1mdW5jdGlvbiBnZShlKXtpZihlPT09XCJcIilyZXR1cm4gZTtsZXQgdD1uZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtyZXR1cm4gdC5zZWFyY2g9ZSx0LnNlYXJjaC5zdWJzdHJpbmcoMSx0LnNlYXJjaC5sZW5ndGgpfWZ1bmN0aW9uIG1lKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0Lmhhc2g9ZSx0Lmhhc2guc3Vic3RyaW5nKDEsdC5oYXNoLmxlbmd0aCl9dmFyIEg9Y2xhc3N7I2k7I249W107I3Q9e307I2U9MDsjcz0xOyNsPTA7I289MDsjZD0wOyNwPTA7I2c9ITE7Y29uc3RydWN0b3IodCl7dGhpcy4jaT10fWdldCByZXN1bHQoKXtyZXR1cm4gdGhpcy4jdH1wYXJzZSgpe2Zvcih0aGlzLiNuPUQodGhpcy4jaSwhMCk7dGhpcy4jZTx0aGlzLiNuLmxlbmd0aDt0aGlzLiNlKz10aGlzLiNzKXtpZih0aGlzLiNzPTEsdGhpcy4jblt0aGlzLiNlXS50eXBlPT09XCJFTkRcIil7aWYodGhpcy4jbz09PTApe3RoaXMuI2IoKSx0aGlzLiNmKCk/dGhpcy4jcig5LDEpOnRoaXMuI2goKT90aGlzLiNyKDgsMSk6dGhpcy4jcig3LDApO2NvbnRpbnVlfWVsc2UgaWYodGhpcy4jbz09PTIpe3RoaXMuI3UoNSk7Y29udGludWV9dGhpcy4jcigxMCwwKTticmVha31pZih0aGlzLiNkPjApaWYodGhpcy4jQSgpKXRoaXMuI2QtPTE7ZWxzZSBjb250aW51ZTtpZih0aGlzLiNUKCkpe3RoaXMuI2QrPTE7Y29udGludWV9c3dpdGNoKHRoaXMuI28pe2Nhc2UgMDp0aGlzLiNQKCkmJnRoaXMuI3UoMSk7YnJlYWs7Y2FzZSAxOmlmKHRoaXMuI1AoKSl7dGhpcy4jQygpO2xldCB0PTcscj0xO3RoaXMuI0UoKT8odD0yLHI9Myk6dGhpcy4jZyYmKHQ9MiksdGhpcy4jcih0LHIpfWJyZWFrO2Nhc2UgMjp0aGlzLiNTKCk/dGhpcy4jdSgzKToodGhpcy4jeCgpfHx0aGlzLiNoKCl8fHRoaXMuI2YoKSkmJnRoaXMuI3UoNSk7YnJlYWs7Y2FzZSAzOnRoaXMuI08oKT90aGlzLiNyKDQsMSk6dGhpcy4jUygpJiZ0aGlzLiNyKDUsMSk7YnJlYWs7Y2FzZSA0OnRoaXMuI1MoKSYmdGhpcy4jcig1LDEpO2JyZWFrO2Nhc2UgNTp0aGlzLiN5KCk/dGhpcy4jcCs9MTp0aGlzLiN3KCkmJih0aGlzLiNwLT0xKSx0aGlzLiNrKCkmJiF0aGlzLiNwP3RoaXMuI3IoNiwxKTp0aGlzLiN4KCk/dGhpcy4jcig3LDApOnRoaXMuI2goKT90aGlzLiNyKDgsMSk6dGhpcy4jZigpJiZ0aGlzLiNyKDksMSk7YnJlYWs7Y2FzZSA2OnRoaXMuI3goKT90aGlzLiNyKDcsMCk6dGhpcy4jaCgpP3RoaXMuI3IoOCwxKTp0aGlzLiNmKCkmJnRoaXMuI3IoOSwxKTticmVhaztjYXNlIDc6dGhpcy4jaCgpP3RoaXMuI3IoOCwxKTp0aGlzLiNmKCkmJnRoaXMuI3IoOSwxKTticmVhaztjYXNlIDg6dGhpcy4jZigpJiZ0aGlzLiNyKDksMSk7YnJlYWs7Y2FzZSA5OmJyZWFrO2Nhc2UgMTA6YnJlYWt9fXRoaXMuI3QuaG9zdG5hbWUhPT12b2lkIDAmJnRoaXMuI3QucG9ydD09PXZvaWQgMCYmKHRoaXMuI3QucG9ydD1cIlwiKX0jcih0LHIpe3N3aXRjaCh0aGlzLiNvKXtjYXNlIDA6YnJlYWs7Y2FzZSAxOnRoaXMuI3QucHJvdG9jb2w9dGhpcy4jYygpO2JyZWFrO2Nhc2UgMjpicmVhaztjYXNlIDM6dGhpcy4jdC51c2VybmFtZT10aGlzLiNjKCk7YnJlYWs7Y2FzZSA0OnRoaXMuI3QucGFzc3dvcmQ9dGhpcy4jYygpO2JyZWFrO2Nhc2UgNTp0aGlzLiN0Lmhvc3RuYW1lPXRoaXMuI2MoKTticmVhaztjYXNlIDY6dGhpcy4jdC5wb3J0PXRoaXMuI2MoKTticmVhaztjYXNlIDc6dGhpcy4jdC5wYXRobmFtZT10aGlzLiNjKCk7YnJlYWs7Y2FzZSA4OnRoaXMuI3Quc2VhcmNoPXRoaXMuI2MoKTticmVhaztjYXNlIDk6dGhpcy4jdC5oYXNoPXRoaXMuI2MoKTticmVhaztjYXNlIDEwOmJyZWFrfXRoaXMuI28hPT0wJiZ0IT09MTAmJihbMSwyLDMsNF0uaW5jbHVkZXModGhpcy4jbykmJls2LDcsOCw5XS5pbmNsdWRlcyh0KSYmKHRoaXMuI3QuaG9zdG5hbWU/Pz1cIlwiKSxbMSwyLDMsNCw1LDZdLmluY2x1ZGVzKHRoaXMuI28pJiZbOCw5XS5pbmNsdWRlcyh0KSYmKHRoaXMuI3QucGF0aG5hbWU/Pz10aGlzLiNnP1wiL1wiOlwiXCIpLFsxLDIsMyw0LDUsNiw3XS5pbmNsdWRlcyh0aGlzLiNvKSYmdD09PTkmJih0aGlzLiN0LnNlYXJjaD8/PVwiXCIpKSx0aGlzLiNSKHQscil9I1IodCxyKXt0aGlzLiNvPXQsdGhpcy4jbD10aGlzLiNlK3IsdGhpcy4jZSs9cix0aGlzLiNzPTB9I2IoKXt0aGlzLiNlPXRoaXMuI2wsdGhpcy4jcz0wfSN1KHQpe3RoaXMuI2IoKSx0aGlzLiNvPXR9I20odCl7cmV0dXJuIHQ8MCYmKHQ9dGhpcy4jbi5sZW5ndGgtdCksdDx0aGlzLiNuLmxlbmd0aD90aGlzLiNuW3RdOnRoaXMuI25bdGhpcy4jbi5sZW5ndGgtMV19I2EodCxyKXtsZXQgbj10aGlzLiNtKHQpO3JldHVybiBuLnZhbHVlPT09ciYmKG4udHlwZT09PVwiQ0hBUlwifHxuLnR5cGU9PT1cIkVTQ0FQRURfQ0hBUlwifHxuLnR5cGU9PT1cIklOVkFMSURfQ0hBUlwiKX0jUCgpe3JldHVybiB0aGlzLiNhKHRoaXMuI2UsXCI6XCIpfSNFKCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSsxLFwiL1wiKSYmdGhpcy4jYSh0aGlzLiNlKzIsXCIvXCIpfSNTKCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIkBcIil9I08oKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlLFwiOlwiKX0jaygpe3JldHVybiB0aGlzLiNhKHRoaXMuI2UsXCI6XCIpfSN4KCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIi9cIil9I2goKXtpZih0aGlzLiNhKHRoaXMuI2UsXCI/XCIpKXJldHVybiEwO2lmKHRoaXMuI25bdGhpcy4jZV0udmFsdWUhPT1cIj9cIilyZXR1cm4hMTtsZXQgdD10aGlzLiNtKHRoaXMuI2UtMSk7cmV0dXJuIHQudHlwZSE9PVwiTkFNRVwiJiZ0LnR5cGUhPT1cIlJFR0VYXCImJnQudHlwZSE9PVwiQ0xPU0VcIiYmdC50eXBlIT09XCJBU1RFUklTS1wifSNmKCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIiNcIil9I1QoKXtyZXR1cm4gdGhpcy4jblt0aGlzLiNlXS50eXBlPT1cIk9QRU5cIn0jQSgpe3JldHVybiB0aGlzLiNuW3RoaXMuI2VdLnR5cGU9PVwiQ0xPU0VcIn0jeSgpe3JldHVybiB0aGlzLiNhKHRoaXMuI2UsXCJbXCIpfSN3KCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIl1cIil9I2MoKXtsZXQgdD10aGlzLiNuW3RoaXMuI2VdLHI9dGhpcy4jbSh0aGlzLiNsKS5pbmRleDtyZXR1cm4gdGhpcy4jaS5zdWJzdHJpbmcocix0LmluZGV4KX0jQygpe2xldCB0PXt9O09iamVjdC5hc3NpZ24odCx4KSx0LmVuY29kZVBhcnQ9eTtsZXQgcj1xKHRoaXMuI2MoKSx2b2lkIDAsdCk7dGhpcy4jZz1OKHIpfX07dmFyIFY9W1wicHJvdG9jb2xcIixcInVzZXJuYW1lXCIsXCJwYXNzd29yZFwiLFwiaG9zdG5hbWVcIixcInBvcnRcIixcInBhdGhuYW1lXCIsXCJzZWFyY2hcIixcImhhc2hcIl0sRT1cIipcIjtmdW5jdGlvbiBTZShlLHQpe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJy5cIik7bGV0IHI9bmV3IFVSTChlLHQpO3JldHVybntwcm90b2NvbDpyLnByb3RvY29sLnN1YnN0cmluZygwLHIucHJvdG9jb2wubGVuZ3RoLTEpLHVzZXJuYW1lOnIudXNlcm5hbWUscGFzc3dvcmQ6ci5wYXNzd29yZCxob3N0bmFtZTpyLmhvc3RuYW1lLHBvcnQ6ci5wb3J0LHBhdGhuYW1lOnIucGF0aG5hbWUsc2VhcmNoOnIuc2VhcmNoIT09XCJcIj9yLnNlYXJjaC5zdWJzdHJpbmcoMSxyLnNlYXJjaC5sZW5ndGgpOnZvaWQgMCxoYXNoOnIuaGFzaCE9PVwiXCI/ci5oYXNoLnN1YnN0cmluZygxLHIuaGFzaC5sZW5ndGgpOnZvaWQgMH19ZnVuY3Rpb24gYihlLHQpe3JldHVybiB0P0MoZSk6ZX1mdW5jdGlvbiB3KGUsdCxyKXtsZXQgbjtpZih0eXBlb2YgdC5iYXNlVVJMPT1cInN0cmluZ1wiKXRyeXtuPW5ldyBVUkwodC5iYXNlVVJMKSx0LnByb3RvY29sPT09dm9pZCAwJiYoZS5wcm90b2NvbD1iKG4ucHJvdG9jb2wuc3Vic3RyaW5nKDAsbi5wcm90b2NvbC5sZW5ndGgtMSkscikpLCFyJiZ0LnByb3RvY29sPT09dm9pZCAwJiZ0Lmhvc3RuYW1lPT09dm9pZCAwJiZ0LnBvcnQ9PT12b2lkIDAmJnQudXNlcm5hbWU9PT12b2lkIDAmJihlLnVzZXJuYW1lPWIobi51c2VybmFtZSxyKSksIXImJnQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJnQucG9ydD09PXZvaWQgMCYmdC51c2VybmFtZT09PXZvaWQgMCYmdC5wYXNzd29yZD09PXZvaWQgMCYmKGUucGFzc3dvcmQ9YihuLnBhc3N3b3JkLHIpKSx0LnByb3RvY29sPT09dm9pZCAwJiZ0Lmhvc3RuYW1lPT09dm9pZCAwJiYoZS5ob3N0bmFtZT1iKG4uaG9zdG5hbWUscikpLHQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJnQucG9ydD09PXZvaWQgMCYmKGUucG9ydD1iKG4ucG9ydCxyKSksdC5wcm90b2NvbD09PXZvaWQgMCYmdC5ob3N0bmFtZT09PXZvaWQgMCYmdC5wb3J0PT09dm9pZCAwJiZ0LnBhdGhuYW1lPT09dm9pZCAwJiYoZS5wYXRobmFtZT1iKG4ucGF0aG5hbWUscikpLHQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJnQucG9ydD09PXZvaWQgMCYmdC5wYXRobmFtZT09PXZvaWQgMCYmdC5zZWFyY2g9PT12b2lkIDAmJihlLnNlYXJjaD1iKG4uc2VhcmNoLnN1YnN0cmluZygxLG4uc2VhcmNoLmxlbmd0aCkscikpLHQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJnQucG9ydD09PXZvaWQgMCYmdC5wYXRobmFtZT09PXZvaWQgMCYmdC5zZWFyY2g9PT12b2lkIDAmJnQuaGFzaD09PXZvaWQgMCYmKGUuaGFzaD1iKG4uaGFzaC5zdWJzdHJpbmcoMSxuLmhhc2gubGVuZ3RoKSxyKSl9Y2F0Y2h7dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBiYXNlVVJMICcke3QuYmFzZVVSTH0nLmApfWlmKHR5cGVvZiB0LnByb3RvY29sPT1cInN0cmluZ1wiJiYoZS5wcm90b2NvbD1mZSh0LnByb3RvY29sLHIpKSx0eXBlb2YgdC51c2VybmFtZT09XCJzdHJpbmdcIiYmKGUudXNlcm5hbWU9b2UodC51c2VybmFtZSxyKSksdHlwZW9mIHQucGFzc3dvcmQ9PVwic3RyaW5nXCImJihlLnBhc3N3b3JkPWFlKHQucGFzc3dvcmQscikpLHR5cGVvZiB0Lmhvc3RuYW1lPT1cInN0cmluZ1wiJiYoZS5ob3N0bmFtZT1pZSh0Lmhvc3RuYW1lLHIpKSx0eXBlb2YgdC5wb3J0PT1cInN0cmluZ1wiJiYoZS5wb3J0PWxlKHQucG9ydCxlLnByb3RvY29sLHIpKSx0eXBlb2YgdC5wYXRobmFtZT09XCJzdHJpbmdcIil7aWYoZS5wYXRobmFtZT10LnBhdGhuYW1lLG4mJiFlZShlLnBhdGhuYW1lLHIpKXtsZXQgYT1uLnBhdGhuYW1lLmxhc3RJbmRleE9mKFwiL1wiKTthPj0wJiYoZS5wYXRobmFtZT1iKG4ucGF0aG5hbWUuc3Vic3RyaW5nKDAsYSsxKSxyKStlLnBhdGhuYW1lKX1lLnBhdGhuYW1lPWNlKGUucGF0aG5hbWUsZS5wcm90b2NvbCxyKX1yZXR1cm4gdHlwZW9mIHQuc2VhcmNoPT1cInN0cmluZ1wiJiYoZS5zZWFyY2g9c2UodC5zZWFyY2gscikpLHR5cGVvZiB0Lmhhc2g9PVwic3RyaW5nXCImJihlLmhhc2g9bmUodC5oYXNoLHIpKSxlfWZ1bmN0aW9uIEMoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFsrKj86e30oKVxcXFxdKS9nLFwiXFxcXCQxXCIpfWZ1bmN0aW9uIExlKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbLisqP14ke30oKVtcXF18L1xcXFxdKS9nLFwiXFxcXCQxXCIpfWZ1bmN0aW9uIEllKGUsdCl7dC5kZWxpbWl0ZXI/Pz1cIi8jP1wiLHQucHJlZml4ZXM/Pz1cIi4vXCIsdC5zZW5zaXRpdmU/Pz0hMSx0LnN0cmljdD8/PSExLHQuZW5kPz89ITAsdC5zdGFydD8/PSEwLHQuZW5kc1dpdGg9XCJcIjtsZXQgcj1cIi4qXCIsbj1gW14ke0xlKHQuZGVsaW1pdGVyKX1dKz9gLGE9L1skX1xcdTIwMENcXHUyMDBEXFxwe0lEX0NvbnRpbnVlfV0vdSxjPVwiXCI7Zm9yKGxldCBsPTA7bDxlLmxlbmd0aDsrK2wpe2xldCBzPWVbbF07aWYocy50eXBlPT09Myl7aWYocy5tb2RpZmllcj09PTMpe2MrPUMocy52YWx1ZSk7Y29udGludWV9Yys9YHske0Mocy52YWx1ZSl9fSR7ayhzLm1vZGlmaWVyKX1gO2NvbnRpbnVlfWxldCBpPXMuaGFzQ3VzdG9tTmFtZSgpLG89ISFzLnN1ZmZpeC5sZW5ndGh8fCEhcy5wcmVmaXgubGVuZ3RoJiYocy5wcmVmaXgubGVuZ3RoIT09MXx8IXQucHJlZml4ZXMuaW5jbHVkZXMocy5wcmVmaXgpKSxmPWw+MD9lW2wtMV06bnVsbCxkPWw8ZS5sZW5ndGgtMT9lW2wrMV06bnVsbDtpZighbyYmaSYmcy50eXBlPT09MSYmcy5tb2RpZmllcj09PTMmJmQmJiFkLnByZWZpeC5sZW5ndGgmJiFkLnN1ZmZpeC5sZW5ndGgpaWYoZC50eXBlPT09Myl7bGV0IFQ9ZC52YWx1ZS5sZW5ndGg+MD9kLnZhbHVlWzBdOlwiXCI7bz1hLnRlc3QoVCl9ZWxzZSBvPSFkLmhhc0N1c3RvbU5hbWUoKTtpZighbyYmIXMucHJlZml4Lmxlbmd0aCYmZiYmZi50eXBlPT09Myl7bGV0IFQ9Zi52YWx1ZVtmLnZhbHVlLmxlbmd0aC0xXTtvPXQucHJlZml4ZXMuaW5jbHVkZXMoVCl9byYmKGMrPVwie1wiKSxjKz1DKHMucHJlZml4KSxpJiYoYys9YDoke3MubmFtZX1gKSxzLnR5cGU9PT0yP2MrPWAoJHtzLnZhbHVlfSlgOnMudHlwZT09PTE/aXx8KGMrPWAoJHtufSlgKTpzLnR5cGU9PT0wJiYoIWkmJighZnx8Zi50eXBlPT09M3x8Zi5tb2RpZmllciE9PTN8fG98fHMucHJlZml4IT09XCJcIik/Yys9XCIqXCI6Yys9YCgke3J9KWApLHMudHlwZT09PTEmJmkmJnMuc3VmZml4Lmxlbmd0aCYmYS50ZXN0KHMuc3VmZml4WzBdKSYmKGMrPVwiXFxcXFwiKSxjKz1DKHMuc3VmZml4KSxvJiYoYys9XCJ9XCIpLHMubW9kaWZpZXIhPT0zJiYoYys9ayhzLm1vZGlmaWVyKSl9cmV0dXJuIGN9dmFyIFk9Y2xhc3N7I2k7I249e307I3Q9e307I2U9e307I3M9e307I2w9ITE7Y29uc3RydWN0b3IodD17fSxyLG4pe3RyeXtsZXQgYTtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIj9hPXI6bj1yLHR5cGVvZiB0PT1cInN0cmluZ1wiKXtsZXQgaT1uZXcgSCh0KTtpZihpLnBhcnNlKCksdD1pLnJlc3VsdCxhPT09dm9pZCAwJiZ0eXBlb2YgdC5wcm90b2NvbCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBiYXNlIFVSTCBtdXN0IGJlIHByb3ZpZGVkIGZvciBhIHJlbGF0aXZlIGNvbnN0cnVjdG9yIHN0cmluZy5cIik7dC5iYXNlVVJMPWF9ZWxzZXtpZighdHx8dHlwZW9mIHQhPVwib2JqZWN0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcInBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnIGFuZCBjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LlwiKTtpZihhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJy5cIil9dHlwZW9mIG4+XCJ1XCImJihuPXtpZ25vcmVDYXNlOiExfSk7bGV0IGM9e2lnbm9yZUNhc2U6bi5pZ25vcmVDYXNlPT09ITB9LGw9e3BhdGhuYW1lOkUscHJvdG9jb2w6RSx1c2VybmFtZTpFLHBhc3N3b3JkOkUsaG9zdG5hbWU6RSxwb3J0OkUsc2VhcmNoOkUsaGFzaDpFfTt0aGlzLiNpPXcobCx0LCEwKSx6KHRoaXMuI2kucHJvdG9jb2wpPT09dGhpcy4jaS5wb3J0JiYodGhpcy4jaS5wb3J0PVwiXCIpO2xldCBzO2ZvcihzIG9mIFYpe2lmKCEocyBpbiB0aGlzLiNpKSljb250aW51ZTtsZXQgaT17fSxvPXRoaXMuI2lbc107c3dpdGNoKHRoaXMuI3Rbc109W10scyl7Y2FzZVwicHJvdG9jb2xcIjpPYmplY3QuYXNzaWduKGkseCksaS5lbmNvZGVQYXJ0PXk7YnJlYWs7Y2FzZVwidXNlcm5hbWVcIjpPYmplY3QuYXNzaWduKGkseCksaS5lbmNvZGVQYXJ0PWhlO2JyZWFrO2Nhc2VcInBhc3N3b3JkXCI6T2JqZWN0LmFzc2lnbihpLHgpLGkuZW5jb2RlUGFydD11ZTticmVhaztjYXNlXCJob3N0bmFtZVwiOk9iamVjdC5hc3NpZ24oaSxKKSxfKG8pP2kuZW5jb2RlUGFydD1LOmkuZW5jb2RlUGFydD1qO2JyZWFrO2Nhc2VcInBvcnRcIjpPYmplY3QuYXNzaWduKGkseCksaS5lbmNvZGVQYXJ0PUc7YnJlYWs7Y2FzZVwicGF0aG5hbWVcIjpOKHRoaXMuI24ucHJvdG9jb2wpPyhPYmplY3QuYXNzaWduKGksUSxjKSxpLmVuY29kZVBhcnQ9ZGUpOihPYmplY3QuYXNzaWduKGkseCxjKSxpLmVuY29kZVBhcnQ9cGUpO2JyZWFrO2Nhc2VcInNlYXJjaFwiOk9iamVjdC5hc3NpZ24oaSx4LGMpLGkuZW5jb2RlUGFydD1nZTticmVhaztjYXNlXCJoYXNoXCI6T2JqZWN0LmFzc2lnbihpLHgsYyksaS5lbmNvZGVQYXJ0PW1lO2JyZWFrfXRyeXt0aGlzLiNzW3NdPUYobyxpKSx0aGlzLiNuW3NdPVcodGhpcy4jc1tzXSx0aGlzLiN0W3NdLGkpLHRoaXMuI2Vbc109SWUodGhpcy4jc1tzXSxpKSx0aGlzLiNsPXRoaXMuI2x8fHRoaXMuI3Nbc10uc29tZShmPT5mLnR5cGU9PT0yKX1jYXRjaHt0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkICR7c30gcGF0dGVybiAnJHt0aGlzLiNpW3NdfScuYCl9fX1jYXRjaChhKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdVUkxQYXR0ZXJuJzogJHthLm1lc3NhZ2V9YCl9fXRlc3QodD17fSxyKXtsZXQgbj17cGF0aG5hbWU6XCJcIixwcm90b2NvbDpcIlwiLHVzZXJuYW1lOlwiXCIscGFzc3dvcmQ6XCJcIixob3N0bmFtZTpcIlwiLHBvcnQ6XCJcIixzZWFyY2g6XCJcIixoYXNoOlwiXCJ9O2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiJiZyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJy5cIik7aWYodHlwZW9mIHQ+XCJ1XCIpcmV0dXJuITE7dHJ5e3R5cGVvZiB0PT1cIm9iamVjdFwiP249dyhuLHQsITEpOm49dyhuLFNlKHQsciksITEpfWNhdGNoe3JldHVybiExfWxldCBhO2ZvcihhIG9mIFYpaWYoIXRoaXMuI25bYV0uZXhlYyhuW2FdKSlyZXR1cm4hMTtyZXR1cm4hMH1leGVjKHQ9e30scil7bGV0IG49e3BhdGhuYW1lOlwiXCIscHJvdG9jb2w6XCJcIix1c2VybmFtZTpcIlwiLHBhc3N3b3JkOlwiXCIsaG9zdG5hbWU6XCJcIixwb3J0OlwiXCIsc2VhcmNoOlwiXCIsaGFzaDpcIlwifTtpZih0eXBlb2YgdCE9XCJzdHJpbmdcIiYmcil0aHJvdyBuZXcgVHlwZUVycm9yKFwicGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ3N0cmluZycuXCIpO2lmKHR5cGVvZiB0PlwidVwiKXJldHVybjt0cnl7dHlwZW9mIHQ9PVwib2JqZWN0XCI/bj13KG4sdCwhMSk6bj13KG4sU2UodCxyKSwhMSl9Y2F0Y2h7cmV0dXJuIG51bGx9bGV0IGE9e307cj9hLmlucHV0cz1bdCxyXTphLmlucHV0cz1bdF07bGV0IGM7Zm9yKGMgb2YgVil7bGV0IGw9dGhpcy4jbltjXS5leGVjKG5bY10pO2lmKCFsKXJldHVybiBudWxsO2xldCBzPXt9O2ZvcihsZXRbaSxvXW9mIHRoaXMuI3RbY10uZW50cmllcygpKWlmKHR5cGVvZiBvPT1cInN0cmluZ1wifHx0eXBlb2Ygbz09XCJudW1iZXJcIil7bGV0IGY9bFtpKzFdO3Nbb109Zn1hW2NdPXtpbnB1dDpuW2NdPz9cIlwiLGdyb3VwczpzfX1yZXR1cm4gYX1zdGF0aWMgY29tcGFyZUNvbXBvbmVudCh0LHIsbil7bGV0IGE9KGksbyk9Pntmb3IobGV0IGYgb2ZbXCJ0eXBlXCIsXCJtb2RpZmllclwiLFwicHJlZml4XCIsXCJ2YWx1ZVwiLFwic3VmZml4XCJdKXtpZihpW2ZdPG9bZl0pcmV0dXJuLTE7aWYoaVtmXT09PW9bZl0pY29udGludWU7cmV0dXJuIDF9cmV0dXJuIDB9LGM9bmV3IFIoMyxcIlwiLFwiXCIsXCJcIixcIlwiLDMpLGw9bmV3IFIoMCxcIlwiLFwiXCIsXCJcIixcIlwiLDMpLHM9KGksbyk9PntsZXQgZj0wO2Zvcig7ZjxNYXRoLm1pbihpLmxlbmd0aCxvLmxlbmd0aCk7KytmKXtsZXQgZD1hKGlbZl0sb1tmXSk7aWYoZClyZXR1cm4gZH1yZXR1cm4gaS5sZW5ndGg9PT1vLmxlbmd0aD8wOmEoaVtmXT8/YyxvW2ZdPz9jKX07cmV0dXJuIXIuI2VbdF0mJiFuLiNlW3RdPzA6ci4jZVt0XSYmIW4uI2VbdF0/cyhyLiNzW3RdLFtsXSk6IXIuI2VbdF0mJm4uI2VbdF0/cyhbbF0sbi4jc1t0XSk6cyhyLiNzW3RdLG4uI3NbdF0pfWdldCBwcm90b2NvbCgpe3JldHVybiB0aGlzLiNlLnByb3RvY29sfWdldCB1c2VybmFtZSgpe3JldHVybiB0aGlzLiNlLnVzZXJuYW1lfWdldCBwYXNzd29yZCgpe3JldHVybiB0aGlzLiNlLnBhc3N3b3JkfWdldCBob3N0bmFtZSgpe3JldHVybiB0aGlzLiNlLmhvc3RuYW1lfWdldCBwb3J0KCl7cmV0dXJuIHRoaXMuI2UucG9ydH1nZXQgcGF0aG5hbWUoKXtyZXR1cm4gdGhpcy4jZS5wYXRobmFtZX1nZXQgc2VhcmNoKCl7cmV0dXJuIHRoaXMuI2Uuc2VhcmNofWdldCBoYXNoKCl7cmV0dXJuIHRoaXMuI2UuaGFzaH1nZXQgaGFzUmVnRXhwR3JvdXBzKCl7cmV0dXJuIHRoaXMuI2x9fTtcbiIsImNvbnN0IHsgVVJMUGF0dGVybiB9ID0gcmVxdWlyZShcIi4vZGlzdC91cmxwYXR0ZXJuLmNqc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFVSTFBhdHRlcm4gfTtcblxuaWYgKCFnbG9iYWxUaGlzLlVSTFBhdHRlcm4pIHtcbiAgZ2xvYmFsVGhpcy5VUkxQYXR0ZXJuID0gVVJMUGF0dGVybjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4pe3JldHVybnthbGw6bj1ufHxuZXcgTWFwLG9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aT9pLnB1c2goZSk6bi5zZXQodCxbZV0pfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpJiYoZT9pLnNwbGljZShpLmluZGV4T2YoZSk+Pj4wLDEpOm4uc2V0KHQsW10pKX0sZW1pdDpmdW5jdGlvbih0LGUpe3ZhciBpPW4uZ2V0KHQpO2kmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bihlKX0pLChpPW4uZ2V0KFwiKlwiKSkmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bih0LGUpfSl9fX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQubWpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCAqIGFzIEJpZGlNYXBwZXIgZnJvbSAnY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvQmlkaU1hcHBlci5qcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2NvbW1vbi9EZWJ1Zy5qcyc7XG5pbXBvcnQgeyBUYXJnZXRDbG9zZUVycm9yIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBCaWRpQ29ubmVjdGlvbiB9IGZyb20gJy4vQ29ubmVjdGlvbi5qcyc7XG5jb25zdCBiaWRpU2VydmVyTG9nZ2VyID0gKHByZWZpeCwgLi4uYXJncykgPT4ge1xuICAgIGRlYnVnKGBiaWRpOiR7cHJlZml4fWApKGFyZ3MpO1xufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0QmlkaU92ZXJDZHAoY2RwKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0QmlEaSA9IG5ldyBOb09wVHJhbnNwb3J0KCk7XG4gICAgY29uc3QgY2RwQ29ubmVjdGlvbkFkYXB0ZXIgPSBuZXcgQ2RwQ29ubmVjdGlvbkFkYXB0ZXIoY2RwKTtcbiAgICBjb25zdCBwcHRyVHJhbnNwb3J0ID0ge1xuICAgICAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmRzIGEgQmlEaSBjb21tYW5kIHNlbnQgYnkgUHVwcGV0ZWVyIHRvIHRoZSBpbnB1dCBvZiB0aGUgQmlkaVNlcnZlci5cbiAgICAgICAgICAgIHRyYW5zcG9ydEJpRGkuZW1pdE1lc3NhZ2UoSlNPTi5wYXJzZShtZXNzYWdlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgYmlkaVNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgY2RwQ29ubmVjdGlvbkFkYXB0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIGNkcC5kaXNwb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ubWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gVGhlIG1ldGhvZCBpcyBvdmVycmlkZGVuIGJ5IHRoZSBDb25uZWN0aW9uLlxuICAgICAgICB9LFxuICAgIH07XG4gICAgdHJhbnNwb3J0QmlEaS5vbignYmlkaVJlc3BvbnNlJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgLy8gRm9yd2FyZHMgYSBCaURpIGV2ZW50IHNlbnQgYnkgQmlkaVNlcnZlciB0byBQdXBwZXRlZXIuXG4gICAgICAgIHBwdHJUcmFuc3BvcnQub25tZXNzYWdlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcHRyQmlEaUNvbm5lY3Rpb24gPSBuZXcgQmlkaUNvbm5lY3Rpb24oY2RwLnVybCgpLCBwcHRyVHJhbnNwb3J0LCBjZHAuZGVsYXksIGNkcC50aW1lb3V0KTtcbiAgICBjb25zdCBiaWRpU2VydmVyID0gYXdhaXQgQmlkaU1hcHBlci5CaWRpU2VydmVyLmNyZWF0ZUFuZFN0YXJ0KHRyYW5zcG9ydEJpRGksIGNkcENvbm5lY3Rpb25BZGFwdGVyLCBjZHBDb25uZWN0aW9uQWRhcHRlci5icm93c2VyQ2xpZW50KCksIFxuICAgIC8qIHNlbGZUYXJnZXRJZD0gKi8gJycsIHVuZGVmaW5lZCwgYmlkaVNlcnZlckxvZ2dlcik7XG4gICAgcmV0dXJuIHBwdHJCaURpQ29ubmVjdGlvbjtcbn1cbi8qKlxuICogTWFuYWdlcyBDRFBTZXNzaW9ucyBmb3IgQmlkaVNlcnZlci5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBDZHBDb25uZWN0aW9uQWRhcHRlciB7XG4gICAgI2NkcDtcbiAgICAjYWRhcHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgI2Jyb3dzZXJDZHBDb25uZWN0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGNkcCkge1xuICAgICAgICB0aGlzLiNjZHAgPSBjZHA7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDb25uZWN0aW9uID0gbmV3IENEUENsaWVudEFkYXB0ZXIoY2RwKTtcbiAgICB9XG4gICAgYnJvd3NlckNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXJDZHBDb25uZWN0aW9uO1xuICAgIH1cbiAgICBnZXRDZHBDbGllbnQoaWQpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuI2NkcC5zZXNzaW9uKGlkKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQ0RQIHNlc3Npb24gd2l0aCBpZCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy4jYWRhcHRlcnMuaGFzKHNlc3Npb24pKSB7XG4gICAgICAgICAgICBjb25zdCBhZGFwdGVyID0gbmV3IENEUENsaWVudEFkYXB0ZXIoc2Vzc2lvbiwgaWQsIHRoaXMuI2Jyb3dzZXJDZHBDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuI2FkYXB0ZXJzLnNldChzZXNzaW9uLCBhZGFwdGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNhZGFwdGVycy5nZXQoc2Vzc2lvbik7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGFkYXB0ZXIgb2YgdGhpcy4jYWRhcHRlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogV3JhcHBlciBvbiB0b3Agb2YgQ0RQU2Vzc2lvbi9DRFBDb25uZWN0aW9uIHRvIHNhdGlzZnkgQ0RQIGludGVyZmFjZSB0aGF0XG4gKiBCaWRpU2VydmVyIG5lZWRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBDRFBDbGllbnRBZGFwdGVyIGV4dGVuZHMgQmlkaU1hcHBlci5FdmVudEVtaXR0ZXIge1xuICAgICNjbG9zZWQgPSBmYWxzZTtcbiAgICAjY2xpZW50O1xuICAgIHNlc3Npb25JZCA9IHVuZGVmaW5lZDtcbiAgICAjYnJvd3NlckNsaWVudDtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHNlc3Npb25JZCwgYnJvd3NlckNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgICB0aGlzLiNicm93c2VyQ2xpZW50ID0gYnJvd3NlckNsaWVudDtcbiAgICAgICAgdGhpcy4jY2xpZW50Lm9uKCcqJywgdGhpcy4jZm9yd2FyZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBicm93c2VyQ2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNsaWVudDtcbiAgICB9XG4gICAgI2ZvcndhcmRNZXNzYWdlID0gKG1ldGhvZCwgZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KG1ldGhvZCwgZXZlbnQpO1xuICAgIH07XG4gICAgYXN5bmMgc2VuZENvbW1hbmQobWV0aG9kLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2xpZW50LnNlbmQobWV0aG9kLCAuLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuI2NsaWVudC5vZmYoJyonLCB0aGlzLiNmb3J3YXJkTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuI2Nsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIGlzQ2xvc2VFcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUYXJnZXRDbG9zZUVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyB0cmFuc3BvcnQgaXMgZ2l2ZW4gdG8gdGhlIEJpRGkgc2VydmVyIGluc3RhbmNlIGFuZCBhbGxvd3MgUHVwcGV0ZWVyXG4gKiB0byBzZW5kIGFuZCByZWNlaXZlIGNvbW1hbmRzIHRvIHRoZSBCaURpU2VydmVyLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE5vT3BUcmFuc3BvcnQgZXh0ZW5kcyBCaWRpTWFwcGVyLkV2ZW50RW1pdHRlciB7XG4gICAgI29uTWVzc2FnZSA9IGFzeW5jIChfbSkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBlbWl0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZvaWQgdGhpcy4jb25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzZXRPbk1lc3NhZ2Uob25NZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI29uTWVzc2FnZSA9IG9uTWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2JpZGlSZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy4jb25NZXNzYWdlID0gYXN5bmMgKF9tKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmlkaU92ZXJDZHAuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX3NldEZ1bmN0aW9uTmFtZSA9ICh0aGlzICYmIHRoaXMuX19zZXRGdW5jdGlvbk5hbWUpIHx8IGZ1bmN0aW9uIChmLCBuYW1lLCBwcmVmaXgpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuaW1wb3J0IHsgQnJvd3NlciwgfSBmcm9tICcuLi9hcGkvQnJvd3Nlci5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBidWJibGUgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgQmlkaUJyb3dzZXJDb250ZXh0IH0gZnJvbSAnLi9Ccm93c2VyQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSAnLi9jb3JlL1Nlc3Npb24uanMnO1xuaW1wb3J0IHsgQmlkaUJyb3dzZXJUYXJnZXQgfSBmcm9tICcuL1RhcmdldC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgQmlkaUJyb3dzZXIgPSAoKCkgPT4ge1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEJyb3dzZXI7XG4gICAgbGV0IF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnM7XG4gICAgbGV0IF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZXNjcmlwdG9yO1xuICAgIHJldHVybiBjbGFzcyBCaWRpQnJvd3NlciBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzID0gW2J1YmJsZSgpXTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZXNjcmlwdG9yID0geyBnZXQ6IF9fc2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuI3RydXN0ZWRFbWl0dGVyX2FjY2Vzc29yX3N0b3JhZ2U7IH0sIFwiI3RydXN0ZWRFbWl0dGVyXCIsIFwiZ2V0XCIpLCBzZXQ6IF9fc2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLiN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gdmFsdWU7IH0sIFwiI3RydXN0ZWRFbWl0dGVyXCIsIFwic2V0XCIpIH0sIF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnMsIHsga2luZDogXCJhY2Nlc3NvclwiLCBuYW1lOiBcIiN0cnVzdGVkRW1pdHRlclwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiB0cnVlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gI3RydXN0ZWRFbWl0dGVyIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLiN0cnVzdGVkRW1pdHRlciwgc2V0OiAob2JqLCB2YWx1ZSkgPT4geyBvYmouI3RydXN0ZWRFbWl0dGVyID0gdmFsdWU7IH0gfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9pbml0aWFsaXplcnMsIF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm90b2NvbCA9ICd3ZWJEcml2ZXJCaURpJztcbiAgICAgICAgc3RhdGljIHN1YnNjcmliZU1vZHVsZXMgPSBbXG4gICAgICAgICAgICAnYnJvd3NpbmdDb250ZXh0JyxcbiAgICAgICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgICAgICdsb2cnLFxuICAgICAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgIF07XG4gICAgICAgIHN0YXRpYyBzdWJzY3JpYmVDZHBFdmVudHMgPSBbXG4gICAgICAgICAgICAvLyBDb3ZlcmFnZVxuICAgICAgICAgICAgJ2NkcC5EZWJ1Z2dlci5zY3JpcHRQYXJzZWQnLFxuICAgICAgICAgICAgJ2NkcC5DU1Muc3R5bGVTaGVldEFkZGVkJyxcbiAgICAgICAgICAgICdjZHAuUnVudGltZS5leGVjdXRpb25Db250ZXh0c0NsZWFyZWQnLFxuICAgICAgICAgICAgLy8gVHJhY2luZ1xuICAgICAgICAgICAgJ2NkcC5UcmFjaW5nLnRyYWNpbmdDb21wbGV0ZScsXG4gICAgICAgICAgICAvLyBUT0RPOiBzdWJzY3JpYmUgdG8gYWxsIENEUCBldmVudHMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgICdjZHAuTmV0d29yay5yZXF1ZXN0V2lsbEJlU2VudCcsXG4gICAgICAgICAgICAnY2RwLkRlYnVnZ2VyLnNjcmlwdFBhcnNlZCcsXG4gICAgICAgICAgICAnY2RwLlBhZ2Uuc2NyZWVuY2FzdEZyYW1lJyxcbiAgICAgICAgXTtcbiAgICAgICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgU2Vzc2lvbi5mcm9tKG9wdHMuY29ubmVjdGlvbiwge1xuICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2g6IG9wdHMuY2FwYWJpbGl0aWVzPy5maXJzdE1hdGNoLFxuICAgICAgICAgICAgICAgIGFsd2F5c01hdGNoOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdHMuY2FwYWJpbGl0aWVzPy5hbHdheXNNYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwYWJpbGl0aWVzIHRoYXQgY29tZSBmcm9tIFB1cHBldGVlcidzIEFQSSB0YWtlIHByZWNlZGVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEluc2VjdXJlQ2VydHM6IG9wdHMuYWNjZXB0SW5zZWN1cmVDZXJ0cyxcbiAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiaWdub3JlXCIgLyogQmlkaS5TZXNzaW9uLlVzZXJQcm9tcHRIYW5kbGVyVHlwZS5JZ25vcmUgKi8sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldFVybDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBzZXNzaW9uLnN1YnNjcmliZShzZXNzaW9uLmNhcGFiaWxpdGllcy5icm93c2VyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmaXJlZm94JylcbiAgICAgICAgICAgICAgICA/IEJpZGlCcm93c2VyLnN1YnNjcmliZU1vZHVsZXNcbiAgICAgICAgICAgICAgICA6IFsuLi5CaWRpQnJvd3Nlci5zdWJzY3JpYmVNb2R1bGVzLCAuLi5CaWRpQnJvd3Nlci5zdWJzY3JpYmVDZHBFdmVudHNdKTtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBuZXcgQmlkaUJyb3dzZXIoc2Vzc2lvbi5icm93c2VyLCBvcHRzKTtcbiAgICAgICAgICAgIGJyb3dzZXIuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyO1xuICAgICAgICB9XG4gICAgICAgICN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzLCBuZXcgRXZlbnRFbWl0dGVyKCkpO1xuICAgICAgICBnZXQgI3RydXN0ZWRFbWl0dGVyKCkgeyByZXR1cm4gX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTsgfVxuICAgICAgICBzZXQgI3RydXN0ZWRFbWl0dGVyKHZhbHVlKSB7IHJldHVybiBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIHZhbHVlKTsgfVxuICAgICAgICAjcHJvY2VzcyA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI2Nsb3NlQ2FsbGJhY2s7XG4gICAgICAgICNicm93c2VyQ29yZTtcbiAgICAgICAgI2RlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgI2Jyb3dzZXJDb250ZXh0cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICN0YXJnZXQgPSBuZXcgQmlkaUJyb3dzZXJUYXJnZXQodGhpcyk7XG4gICAgICAgICNjZHBDb25uZWN0aW9uO1xuICAgICAgICBjb25zdHJ1Y3Rvcihicm93c2VyQ29yZSwgb3B0cykge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBvcHRzLnByb2Nlc3M7XG4gICAgICAgICAgICB0aGlzLiNjbG9zZUNhbGxiYWNrID0gb3B0cy5jbG9zZUNhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy4jYnJvd3NlckNvcmUgPSBicm93c2VyQ29yZTtcbiAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRWaWV3cG9ydCA9IG9wdHMuZGVmYXVsdFZpZXdwb3J0O1xuICAgICAgICAgICAgdGhpcy4jY2RwQ29ubmVjdGlvbiA9IG9wdHMuY2RwQ29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemluZyBleGlzdGluZyBjb250ZXh0cy5cbiAgICAgICAgICAgIGZvciAoY29uc3QgdXNlckNvbnRleHQgb2YgdGhpcy4jYnJvd3NlckNvcmUudXNlckNvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY3JlYXRlQnJvd3NlckNvbnRleHQodXNlckNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jYnJvd3NlckNvcmUub25jZSgnZGlzY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3RydXN0ZWRFbWl0dGVyLmVtaXQoXCJkaXNjb25uZWN0ZWRcIiAvKiBCcm93c2VyRXZlbnQuRGlzY29ubmVjdGVkICovLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3RydXN0ZWRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNwcm9jZXNzPy5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2VyQ29yZS5kaXNwb3NlKCdCcm93c2VyIHByb2Nlc3MgZXhpdGVkLicsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgI2Jyb3dzZXJOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXJDb3JlLnNlc3Npb24uY2FwYWJpbGl0aWVzLmJyb3dzZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGdldCAjYnJvd3NlclZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNvcmUuc2Vzc2lvbi5jYXBhYmlsaXRpZXMuYnJvd3NlclZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNkcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjZHBDb25uZWN0aW9uICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNkcENvbm5lY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY2RwQ29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB1c2VyQWdlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNvcmUuc2Vzc2lvbi5jYXBhYmlsaXRpZXMudXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgICNjcmVhdGVCcm93c2VyQ29udGV4dCh1c2VyQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlckNvbnRleHQgPSBCaWRpQnJvd3NlckNvbnRleHQuZnJvbSh0aGlzLCB1c2VyQ29udGV4dCwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWaWV3cG9ydDogdGhpcy4jZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyQ29udGV4dHMuc2V0KHVzZXJDb250ZXh0LCBicm93c2VyQ29udGV4dCk7XG4gICAgICAgICAgICBicm93c2VyQ29udGV4dC50cnVzdGVkRW1pdHRlci5vbihcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jdHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyRXZlbnQuVGFyZ2V0Q3JlYXRlZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJvd3NlckNvbnRleHQudHJ1c3RlZEVtaXR0ZXIub24oXCJ0YXJnZXRjaGFuZ2VkXCIgLyogQnJvd3NlckNvbnRleHRFdmVudC5UYXJnZXRDaGFuZ2VkICovLCB0YXJnZXQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3RydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRjaGFuZ2VkXCIgLyogQnJvd3NlckV2ZW50LlRhcmdldENoYW5nZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0LnRydXN0ZWRFbWl0dGVyLm9uKFwidGFyZ2V0ZGVzdHJveWVkXCIgLyogQnJvd3NlckNvbnRleHRFdmVudC5UYXJnZXREZXN0cm95ZWQgKi8sIHRhcmdldCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jdHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGRlc3Ryb3llZFwiIC8qIEJyb3dzZXJFdmVudC5UYXJnZXREZXN0cm95ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY29ubmVjdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNBRkVUWTogV2Ugb25seSBoYXZlIG9uZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29yZS5zZXNzaW9uLmNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgd3NFbmRwb2ludCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24udXJsO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDb3JlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY2xvc2VDYWxsYmFjaz8uY2FsbChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuI2Jyb3dzZXJDb3JlLmRpc2Nvbm5lY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjcmVhdGVCcm93c2VyQ29udGV4dChfb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdXNlckNvbnRleHQgPSBhd2FpdCB0aGlzLiNicm93c2VyQ29yZS5jcmVhdGVVc2VyQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWF0ZUJyb3dzZXJDb250ZXh0KHVzZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuI2Jyb3dzZXJOYW1lfS8ke3RoaXMuI2Jyb3dzZXJWZXJzaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJvd3NlckNvbnRleHRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLiNicm93c2VyQ29yZS51c2VyQ29udGV4dHNdLm1hcChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNvbnRleHRzLmdldChjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRCcm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29udGV4dHMuZ2V0KHRoaXMuI2Jyb3dzZXJDb3JlLmRlZmF1bHRVc2VyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UGFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRCcm93c2VyQ29udGV4dCgpLm5ld1BhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLiN0YXJnZXQsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5icm93c2VyQ29udGV4dHMoKS5mbGF0TWFwKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC50YXJnZXRzKCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jYnJvd3NlckNvcmUuc2Vzc2lvbi5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBkZWJ1Z0luZm8oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQcm90b2NvbEVycm9yczogdGhpcy5jb25uZWN0aW9uLmdldFBlbmRpbmdQcm90b2NvbEVycm9ycygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQmlkaUJyb3dzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBXRUJfUEVSTUlTU0lPTl9UT19QUk9UT0NPTF9QRVJNSVNTSU9OIH0gZnJvbSAnLi4vYXBpL0Jyb3dzZXIuanMnO1xuaW1wb3J0IHsgQnJvd3NlckNvbnRleHQgfSBmcm9tICcuLi9hcGkvQnJvd3NlckNvbnRleHQuanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQuanMnO1xuaW1wb3J0IHsgYnViYmxlIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IFVzZXJDb250ZXh0IH0gZnJvbSAnLi9jb3JlL1VzZXJDb250ZXh0LmpzJztcbmltcG9ydCB7IEJpZGlQYWdlIH0gZnJvbSAnLi9QYWdlLmpzJztcbmltcG9ydCB7IEJpZGlXb3JrZXJUYXJnZXQgfSBmcm9tICcuL1RhcmdldC5qcyc7XG5pbXBvcnQgeyBCaWRpRnJhbWVUYXJnZXQsIEJpZGlQYWdlVGFyZ2V0IH0gZnJvbSAnLi9UYXJnZXQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlCcm93c2VyQ29udGV4dCA9ICgoKSA9PiB7XG4gICAgbGV0IF9jbGFzc1N1cGVyID0gQnJvd3NlckNvbnRleHQ7XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIHJldHVybiBjbGFzcyBCaWRpQnJvd3NlckNvbnRleHQgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnMgPSBbYnViYmxlKCldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwiYWNjZXNzb3JcIiwgbmFtZTogXCJ0cnVzdGVkRW1pdHRlclwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwidHJ1c3RlZEVtaXR0ZXJcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai50cnVzdGVkRW1pdHRlciwgc2V0OiAob2JqLCB2YWx1ZSkgPT4geyBvYmoudHJ1c3RlZEVtaXR0ZXIgPSB2YWx1ZTsgfSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIF90cnVzdGVkRW1pdHRlcl9pbml0aWFsaXplcnMsIF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oYnJvd3NlciwgdXNlckNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQmlkaUJyb3dzZXJDb250ZXh0KGJyb3dzZXIsIHVzZXJDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycywgbmV3IEV2ZW50RW1pdHRlcigpKTtcbiAgICAgICAgZ2V0IHRydXN0ZWRFbWl0dGVyKCkgeyByZXR1cm4gdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZTsgfVxuICAgICAgICBzZXQgdHJ1c3RlZEVtaXR0ZXIodmFsdWUpIHsgdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9XG4gICAgICAgICNicm93c2VyID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI2RlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgLy8gVGhpcyBpcyBwdWJsaWMgYmVjYXVzZSBvZiBjb29raWVzLlxuICAgICAgICB1c2VyQ29udGV4dDtcbiAgICAgICAgI3BhZ2VzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgI3RhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICNvdmVycmlkZXMgPSBbXTtcbiAgICAgICAgY29uc3RydWN0b3IoYnJvd3NlciwgdXNlckNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyID0gYnJvd3NlcjtcbiAgICAgICAgICAgIHRoaXMudXNlckNvbnRleHQgPSB1c2VyQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRWaWV3cG9ydCA9IG9wdGlvbnMuZGVmYXVsdFZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRhcmdldHMgZm9yIGV4aXN0aW5nIGJyb3dzaW5nIGNvbnRleHRzLlxuICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2luZ0NvbnRleHQgb2YgdGhpcy51c2VyQ29udGV4dC5icm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51c2VyQ29udGV4dC5vbignYnJvd3Npbmdjb250ZXh0JywgKHsgYnJvd3NpbmdDb250ZXh0IH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy4jY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTUNvbnRlbnRMb2FkZWQgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NpbmdDb250ZXh0IHN0aWxsIG1heSBiZSBuYXZpZ2F0aW5nIGZyb20gdGhlIGFib3V0OmJsYW5rXG4gICAgICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0Lm9uY2UoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2luZ0NvbnRleHQub3JpZ2luYWxPcGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGV4dCBvZiB0aGlzLnVzZXJDb250ZXh0LmJyb3dzaW5nQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pZCA9PT0gYnJvd3NpbmdDb250ZXh0Lm9yaWdpbmFsT3BlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3BhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInBvcHVwXCIgLyogUGFnZUV2ZW50LlBvcHVwICovLCBwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51c2VyQ29udGV4dC5vbignY2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAjY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBCaWRpUGFnZS5mcm9tKHRoaXMsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLiNwYWdlcy5zZXQoYnJvd3NpbmdDb250ZXh0LCBwYWdlKTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJjbG9zZVwiIC8qIFBhZ2VFdmVudC5DbG9zZSAqLywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhZ2VzLmRlbGV0ZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAtLSBUYXJnZXQgc3R1ZmYgc3RhcnRzIGhlcmUgLS1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VUYXJnZXQgPSBuZXcgQmlkaVBhZ2VUYXJnZXQocGFnZSk7XG4gICAgICAgICAgICBjb25zdCBwYWdlVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuI3RhcmdldHMuc2V0KHBhZ2UsIFtwYWdlVGFyZ2V0LCBwYWdlVGFyZ2V0c10pO1xuICAgICAgICAgICAgcGFnZS50cnVzdGVkRW1pdHRlci5vbihcImZyYW1lYXR0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVBdHRhY2hlZCAqLywgZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBCaWRpRnJhbWVUYXJnZXQoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICBwYWdlVGFyZ2V0cy5zZXQoYmlkaUZyYW1lLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJmcmFtZW5hdmlnYXRlZFwiIC8qIFBhZ2VFdmVudC5GcmFtZU5hdmlnYXRlZCAqLywgZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHBhZ2VUYXJnZXRzLmdldChiaWRpRnJhbWUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRhcmdldCwgdGhlbiB0aGlzIGlzIHRoZSBwYWdlJ3MgZnJhbWUuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNoYW5nZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENoYW5nZWQgKi8sIHBhZ2VUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnVzdGVkRW1pdHRlci5lbWl0KFwidGFyZ2V0Y2hhbmdlZFwiIC8qIEJyb3dzZXJDb250ZXh0RXZlbnQuVGFyZ2V0Q2hhbmdlZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJmcmFtZWRldGFjaGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lRGV0YWNoZWQgKi8sIGZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWRpRnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBwYWdlVGFyZ2V0cy5nZXQoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYWdlVGFyZ2V0cy5kZWxldGUoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRkZXN0cm95ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldERlc3Ryb3llZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFnZS50cnVzdGVkRW1pdHRlci5vbihcIndvcmtlcmNyZWF0ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyQ3JlYXRlZCAqLywgd29ya2VyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWRpV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBCaWRpV29ya2VyVGFyZ2V0KGJpZGlXb3JrZXIpO1xuICAgICAgICAgICAgICAgIHBhZ2VUYXJnZXRzLnNldChiaWRpV29ya2VyLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJ3b3JrZXJkZXN0cm95ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyRGVzdHJveWVkICovLCB3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFnZVRhcmdldHMuZ2V0KGJpZGlXb3JrZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhZ2VUYXJnZXRzLmRlbGV0ZSh3b3JrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGRlc3Ryb3llZFwiIC8qIEJyb3dzZXJDb250ZXh0RXZlbnQuVGFyZ2V0RGVzdHJveWVkICovLCB0YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYWdlLnRydXN0ZWRFbWl0dGVyLm9uKFwiY2xvc2VcIiAvKiBQYWdlRXZlbnQuQ2xvc2UgKi8sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiN0YXJnZXRzLmRlbGV0ZShwYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRkZXN0cm95ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldERlc3Ryb3llZCAqLywgcGFnZVRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHBhZ2VUYXJnZXQpO1xuICAgICAgICAgICAgLy8gLS0gVGFyZ2V0IHN0dWZmIGVuZHMgaGVyZSAtLVxuICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy4jdGFyZ2V0cy52YWx1ZXMoKV0uZmxhdE1hcCgoW3RhcmdldCwgZnJhbWVzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCAuLi5mcmFtZXMudmFsdWVzKCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgbmV3UGFnZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZ3VhcmQgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMSwgYXdhaXQgdGhpcy53YWl0Rm9yU2NyZWVuc2hvdE9wZXJhdGlvbnMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLnVzZXJDb250ZXh0LmNyZWF0ZUJyb3dzaW5nQ29udGV4dChcInRhYlwiIC8qIEJpZGkuQnJvd3NpbmdDb250ZXh0LkNyZWF0ZVR5cGUuVGFiICovKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZXMuZ2V0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgaXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNkZWZhdWx0Vmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHBhZ2Uuc2V0Vmlld3BvcnQodGhpcy4jZGVmYXVsdFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzdXBwb3J0IGZvciBzZXRWaWV3cG9ydCBpbiBGaXJlZm94LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy51c2VyQ29udGV4dC5pZCAhPT0gVXNlckNvbnRleHQuREVGQVVMVCwgJ0RlZmF1bHQgQnJvd3NlckNvbnRleHQgY2Fubm90IGJlIGNsb3NlZCEnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyQ29udGV4dC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jdGFyZ2V0cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGJyb3dzZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlcjtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwYWdlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy51c2VyQ29udGV4dC5icm93c2luZ0NvbnRleHRzXS5tYXAoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhZ2VzLmdldChjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIG92ZXJyaWRlUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnNTZXQgPSBuZXcgU2V0KHBlcm1pc3Npb25zLm1hcChwZXJtaXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90b2NvbFBlcm1pc3Npb24gPSBXRUJfUEVSTUlTU0lPTl9UT19QUk9UT0NPTF9QRVJNSVNTSU9OLmdldChwZXJtaXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3RvY29sUGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGVybWlzc2lvbjogJyArIHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGVybWlzc2lvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oV0VCX1BFUk1JU1NJT05fVE9fUFJPVE9DT0xfUEVSTUlTU0lPTi5rZXlzKCkpLm1hcChwZXJtaXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVzZXJDb250ZXh0LnNldFBlcm1pc3Npb25zKG9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwZXJtaXNzaW9uLFxuICAgICAgICAgICAgICAgIH0sIHBlcm1pc3Npb25zU2V0LmhhcyhwZXJtaXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFwiZ3JhbnRlZFwiIC8qIEJpZGkuUGVybWlzc2lvbnMuUGVybWlzc2lvblN0YXRlLkdyYW50ZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBcImRlbmllZFwiIC8qIEJpZGkuUGVybWlzc2lvbnMuUGVybWlzc2lvblN0YXRlLkRlbmllZCAqLyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jb3ZlcnJpZGVzLnB1c2goeyBvcmlnaW4sIHBlcm1pc3Npb24gfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZSBwZXJtaXNzaW9ucyBhcmUgb3V0ZGF0ZWQgYW5kIHNldHRpbmcgdGhlbSB0byBkZW5pZWQgZG9lc1xuICAgICAgICAgICAgICAgIC8vIG5vdCB3b3JrLlxuICAgICAgICAgICAgICAgIGlmICghcGVybWlzc2lvbnNTZXQuaGFzKHBlcm1pc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xlYXJQZXJtaXNzaW9uT3ZlcnJpZGVzKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLiNvdmVycmlkZXMubWFwKCh7IHBlcm1pc3Npb24sIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBlcm1pc3Npb25zKG9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwZXJtaXNzaW9uLFxuICAgICAgICAgICAgICAgIH0sIFwicHJvbXB0XCIgLyogQmlkaS5QZXJtaXNzaW9ucy5QZXJtaXNzaW9uU3RhdGUuUHJvbXB0ICovKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI292ZXJyaWRlcyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJDb250ZXh0LmlkID09PSBVc2VyQ29udGV4dC5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJDb250ZXh0LmlkO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpQnJvd3NlckNvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJDb250ZXh0LmpzLm1hcCIsImltcG9ydCB7IENEUFNlc3Npb24gfSBmcm9tICcuLi9hcGkvQ0RQU2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBUYXJnZXRDbG9zZUVycm9yLCBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICcuLi91dGlsL0RlZmVycmVkLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpQ2RwU2Vzc2lvbiBleHRlbmRzIENEUFNlc3Npb24ge1xuICAgIHN0YXRpYyBzZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAjZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAjY29ubmVjdGlvbjtcbiAgICAjc2Vzc2lvbklkID0gRGVmZXJyZWQuY3JlYXRlKCk7XG4gICAgZnJhbWU7XG4gICAgY29uc3RydWN0b3IoZnJhbWUsIHNlc3Npb25JZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgICAgIGlmICghdGhpcy5mcmFtZS5wYWdlKCkuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmZyYW1lLnBhZ2UoKS5icm93c2VyKCkuY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy4jY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGlmIChzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3Nlc3Npb25JZC5yZXNvbHZlKHNlc3Npb25JZCk7XG4gICAgICAgICAgICBCaWRpQ2RwU2Vzc2lvbi5zZXNzaW9ucy5zZXQoc2Vzc2lvbklkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZCgnY2RwLmdldFNlc3Npb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBmcmFtZS5faWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZXNzaW9uSWQucmVzb2x2ZShyZXN1bHQuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIEJpZGlDZHBTZXNzaW9uLnNlc3Npb25zLnNldChyZXN1bHQuc2Vzc2lvbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZXNzaW9uSWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNBRkVUWTogV2UgbmV2ZXIgdGhyb3cgI3Nlc3Npb25JZC5cbiAgICAgICAgQmlkaUNkcFNlc3Npb24uc2Vzc2lvbnMuc2V0KHRoaXMuI3Nlc3Npb25JZC52YWx1ZSgpLCB0aGlzKTtcbiAgICB9XG4gICAgY29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy4jY29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oJ0NEUCBzdXBwb3J0IGlzIHJlcXVpcmVkIGZvciB0aGlzIGZlYXR1cmUuIFRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDRFAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2RldGFjaGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGFyZ2V0Q2xvc2VFcnJvcihgUHJvdG9jb2wgZXJyb3IgKCR7bWV0aG9kfSk6IFNlc3Npb24gY2xvc2VkLiBNb3N0IGxpa2VseSB0aGUgcGFnZSBoYXMgYmVlbiBjbG9zZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuI3Nlc3Npb25JZC52YWx1ZU9yVGhyb3coKTtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuI2Nvbm5lY3Rpb24uc2VuZCgnY2RwLnNlbmRDb21tYW5kJywge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgIH0sIG9wdGlvbnM/LnRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGV0YWNoKCkge1xuICAgICAgICBpZiAodGhpcy4jY29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0aW9uLmNsb3NlZCB8fFxuICAgICAgICAgICAgdGhpcy4jZGV0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmFtZS5jbGllbnQuc2VuZCgnVGFyZ2V0LmRldGFjaEZyb21UYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLmlkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIEJpZGlDZHBTZXNzaW9uLnNlc3Npb25zLmRlbGV0ZSh0aGlzLmlkKCkpO1xuICAgICAgICB0aGlzLiNkZXRhY2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzZXNzaW9uSWQudmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6ICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNEUFNlc3Npb24uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IENhbGxiYWNrUmVnaXN0cnkgfSBmcm9tICcuLi9jb21tb24vQ2FsbGJhY2tSZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2NvbW1vbi9EZWJ1Zy5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBCaWRpQ2RwU2Vzc2lvbiB9IGZyb20gJy4vQ0RQU2Vzc2lvbi5qcyc7XG5jb25zdCBkZWJ1Z1Byb3RvY29sU2VuZCA9IGRlYnVnKCdwdXBwZXRlZXI6d2ViRHJpdmVyQmlEaTpTRU5EIOKWuicpO1xuY29uc3QgZGVidWdQcm90b2NvbFJlY2VpdmUgPSBkZWJ1ZygncHVwcGV0ZWVyOndlYkRyaXZlckJpRGk6UkVDViDil4AnKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgI3VybDtcbiAgICAjdHJhbnNwb3J0O1xuICAgICNkZWxheTtcbiAgICAjdGltZW91dCA9IDA7XG4gICAgI2Nsb3NlZCA9IGZhbHNlO1xuICAgICNjYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tSZWdpc3RyeSgpO1xuICAgICNlbWl0dGVycyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKHVybCwgdHJhbnNwb3J0LCBkZWxheSA9IDAsIHRpbWVvdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICB0aGlzLiNkZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dCA/PyAxODBfMDAwO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuI3RyYW5zcG9ydC5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQub25jbG9zZSA9IHRoaXMudW5iaW5kLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjbG9zZWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN1cmw7XG4gICAgfVxuICAgIHBpcGVUbyhlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXJzLnB1c2goZW1pdHRlcik7XG4gICAgfVxuICAgIGVtaXQodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbWl0dGVyIG9mIHRoaXMuI2VtaXR0ZXJzKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQodHlwZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICB9XG4gICAgc2VuZChtZXRob2QsIHBhcmFtcywgdGltZW91dCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuI2Nsb3NlZCwgJ1Byb3RvY29sIGVycm9yOiBDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NhbGxiYWNrcy5jcmVhdGUobWV0aG9kLCB0aW1lb3V0ID8/IHRoaXMuI3RpbWVvdXQsIGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWJ1Z1Byb3RvY29sU2VuZChzdHJpbmdpZmllZE1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNwb3J0LnNlbmQoc3RyaW5naWZpZWRNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIG9uTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLiNkZWxheSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgdGhpcy4jZGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdQcm90b2NvbFJlY2VpdmUobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIGlmICgndHlwZScgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5yZXNvbHZlKG9iamVjdC5pZCwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2FsbGJhY2tzLnJlamVjdChvYmplY3QuaWQsIGNyZWF0ZVByb3RvY29sRXJyb3Iob2JqZWN0KSwgYCR7b2JqZWN0LmVycm9yfTogJHtvYmplY3QubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2RwRXZlbnQob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQmlkaUNkcFNlc3Npb24uc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KG9iamVjdC5wYXJhbXMuc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LmVtaXQob2JqZWN0LnBhcmFtcy5ldmVudCwgb2JqZWN0LnBhcmFtcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogV2Uga25vdyB0aGUgbWV0aG9kIGFuZCBwYXJhbWV0ZXIgc3RpbGwgbWF0Y2ggaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KG9iamVjdC5tZXRob2QsIG9iamVjdC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlbiBpZiB0aGUgcmVzcG9uc2UgaW4gbm90IGluIEJpRGkgcHJvdG9jb2wgZm9ybWF0IGJ1dCBgaWRgIGlzIHByb3ZpZGVkLCByZWplY3RcbiAgICAgICAgLy8gdGhlIGNhbGxiYWNrLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGVuZHBvaW50IHN1cHBvcnRzIENEUCBpbnN0ZWFkIG9mIEJpRGkuXG4gICAgICAgIGlmICgnaWQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy4jY2FsbGJhY2tzLnJlamVjdChvYmplY3QuaWQsIGBQcm90b2NvbCBFcnJvci4gTWVzc2FnZSBpcyBub3QgaW4gQmlEaSBwcm90b2NvbCBmb3JtYXQ6ICcke21lc3NhZ2V9J2AsIG9iamVjdC5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0Vycm9yKG9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgdGhlIGNvbm5lY3Rpb24sIGJ1dCBrZWVwcyB0aGUgdHJhbnNwb3J0IG9wZW4uIFVzZWZ1bCB3aGVuIHRoZSB0cmFuc3BvcnQgd2lsbFxuICAgICAqIGJlIHJldXNlZCBieSBvdGhlciBjb25uZWN0aW9uIGUuZy4gd2l0aCBkaWZmZXJlbnQgcHJvdG9jb2wuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5iaW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gQm90aCBtYXkgc3RpbGwgYmUgaW52b2tlZCBhbmQgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgdGhpcy4jdHJhbnNwb3J0Lm9ubWVzc2FnZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy4jdHJhbnNwb3J0Lm9uY2xvc2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuI2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHRoZSBjb25uZWN0aW9uIGFuZCBjbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0UGVuZGluZ1Byb3RvY29sRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsbGJhY2tzLmdldFBlbmRpbmdQcm90b2NvbEVycm9ycygpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sRXJyb3Iob2JqZWN0KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHtvYmplY3QuZXJyb3J9ICR7b2JqZWN0Lm1lc3NhZ2V9YDtcbiAgICBpZiAob2JqZWN0LnN0YWNrdHJhY2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgICR7b2JqZWN0LnN0YWNrdHJhY2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpc0NkcEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lm1ldGhvZC5zdGFydHNXaXRoKCdjZHAuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlEZXNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlYnVnRXJyb3IoJ1NlcnZpY2UgZGlkIG5vdCBwcm9kdWNlIGEgcmVzdWx0LicpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZT8ubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlPy5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5hZGQodGhpcy5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU/LnJlZHVjZSgoYWNjLCB0dXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHRoaXMuI2Rlc2VyaWFsaXplVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZT8ucmVkdWNlKChhY2MsIHR1cGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gdGhpcy4jZGVzZXJpYWxpemVUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Muc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBjYXNlICdwcm9taXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlc3VsdC52YWx1ZS5wYXR0ZXJuLCByZXN1bHQudmFsdWUuZmxhZ3MpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Rlc2VyaWFsaXplTnVtYmVyKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdFcnJvcihgRGVzZXJpYWxpemF0aW9uIG9mIHR5cGUgJHtyZXN1bHQudHlwZX0gbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhdGljICNkZXNlcmlhbGl6ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICctMCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wO1xuICAgICAgICAgICAgY2FzZSAnTmFOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgY2FzZSAnSW5maW5pdHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIGNhc2UgJy1JbmZpbml0eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyAjZGVzZXJpYWxpemVUdXBsZShbc2VyaWFsaXplZEtleSwgc2VyaWFsaXplZFZhbHVlXSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2Ygc2VyaWFsaXplZEtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc2VyaWFsaXplZEtleVxuICAgICAgICAgICAgOiB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRLZXkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVzZXJpYWxpemUoc2VyaWFsaXplZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlc2VyaWFsaXplci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSAnLi4vYXBpL0RpYWxvZy5qcyc7XG5leHBvcnQgY2xhc3MgQmlkaURpYWxvZyBleHRlbmRzIERpYWxvZyB7XG4gICAgc3RhdGljIGZyb20ocHJvbXB0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlkaURpYWxvZyhwcm9tcHQpO1xuICAgIH1cbiAgICAjcHJvbXB0O1xuICAgIGNvbnN0cnVjdG9yKHByb21wdCkge1xuICAgICAgICBzdXBlcihwcm9tcHQuaW5mby50eXBlLCBwcm9tcHQuaW5mby5tZXNzYWdlLCBwcm9tcHQuaW5mby5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLiNwcm9tcHQgPSBwcm9tcHQ7XG4gICAgICAgIHRoaXMuaGFuZGxlZCA9IHByb21wdC5oYW5kbGVkO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGUob3B0aW9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLiNwcm9tcHQuaGFuZGxlKHtcbiAgICAgICAgICAgIGFjY2VwdDogb3B0aW9ucy5hY2NlcHQsXG4gICAgICAgICAgICB1c2VyVGV4dDogb3B0aW9ucy50ZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaWFsb2cuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBFbGVtZW50SGFuZGxlIH0gZnJvbSAnLi4vYXBpL0VsZW1lbnRIYW5kbGUuanMnO1xuaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tICcuLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlVXRpbCB9IGZyb20gJy4uL3V0aWwvQXN5bmNJdGVyYWJsZVV0aWwuanMnO1xuaW1wb3J0IHsgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IEJpZGlKU0hhbmRsZSB9IGZyb20gJy4vSlNIYW5kbGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlFbGVtZW50SGFuZGxlID0gKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IF9jbGFzc1N1cGVyID0gRWxlbWVudEhhbmRsZTtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2F1dG9maWxsX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jb250ZW50RnJhbWVfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgQmlkaUVsZW1lbnRIYW5kbGUgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX2F1dG9maWxsX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKCldO1xuICAgICAgICAgICAgX2NvbnRlbnRGcmFtZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZCgpLCAoX2EgPSBFbGVtZW50SGFuZGxlKS5iaW5kSXNvbGF0ZWRIYW5kbGUuYmluZChfYSldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9hdXRvZmlsbF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYXV0b2ZpbGxcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImF1dG9maWxsXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouYXV0b2ZpbGwgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2NvbnRlbnRGcmFtZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY29udGVudEZyYW1lXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJjb250ZW50RnJhbWVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jb250ZW50RnJhbWUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20odmFsdWUsIHJlYWxtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZGlFbGVtZW50SGFuZGxlKHZhbHVlLCByZWFsbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIHJlYWxtKSB7XG4gICAgICAgICAgICBzdXBlcihCaWRpSlNIYW5kbGUuZnJvbSh2YWx1ZSwgcmVhbG0pKTtcbiAgICAgICAgICAgIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVhbG0oKSB7XG4gICAgICAgICAgICAvLyBTQUZFVFk6IFNlZSB0aGUgc3VwZXIgY2FsbCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUucmVhbG07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhbG0uZW52aXJvbm1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3RlVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUucmVtb3RlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhdXRvZmlsbChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmZyYW1lLmNsaWVudDtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmZvID0gYXdhaXQgY2xpZW50LnNlbmQoJ0RPTS5kZXNjcmliZU5vZGUnLCB7XG4gICAgICAgICAgICAgICAgb2JqZWN0SWQ6IHRoaXMuaGFuZGxlLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZElkID0gbm9kZUluZm8ubm9kZS5iYWNrZW5kTm9kZUlkO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IHRoaXMuZnJhbWUuX2lkO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnNlbmQoJ0F1dG9maWxsLnRyaWdnZXInLCB7XG4gICAgICAgICAgICAgICAgZmllbGRJZCxcbiAgICAgICAgICAgICAgICBmcmFtZUlkLFxuICAgICAgICAgICAgICAgIGNhcmQ6IGRhdGEuY3JlZGl0Q2FyZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvbnRlbnRGcmFtZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMSwgKGF3YWl0IHRoaXMuZXZhbHVhdGVIYW5kbGUoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9KSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZS5yZW1vdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYWdlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcmFtZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLl9pZCA9PT0gdmFsdWUudmFsdWUuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSkgPz8gbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgdXBsb2FkRmlsZSguLi5maWxlcykge1xuICAgICAgICAgICAgLy8gTG9jYXRlIGFsbCBmaWxlcyBhbmQgY29uZmlybSB0aGF0IHRoZXkgZXhpc3QuXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZW52aXJvbm1lbnQudmFsdWUucGF0aDtcbiAgICAgICAgICAgIGZpbGVzID0gZmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLndpbjMyLmlzQWJzb2x1dGUoZmlsZSkgfHwgcGF0aC5wb3NpeC5pc0Fic29sdXRlKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZnJhbWUuc2V0RmlsZXModGhpcywgZmlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jICpxdWVyeUFYVHJlZShuYW1lLCByb2xlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5mcmFtZS5sb2NhdGVOb2Rlcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FjY2Vzc2liaWxpdHknLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBBc3luY0l0ZXJhYmxlVXRpbC5tYXAocmVzdWx0cywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hhbmdlIG93bmVyc2hpcCBzaW5jZSB0aGUgZGVmYXVsdCBvd25lcnNoaXAgaXMgcHJvYmFibHkgbm9uZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEJpZGlFbGVtZW50SGFuZGxlLmZyb20obm9kZSwgdGhpcy5yZWFsbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmV4cG9ydCB7IEJpZGlFbGVtZW50SGFuZGxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGVtZW50SGFuZGxlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UgPSAodGhpcyAmJiB0aGlzLl9fYWRkRGlzcG9zYWJsZVJlc291cmNlKSB8fCBmdW5jdGlvbiAoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICAgICAgdmFyIGRpc3Bvc2U7XG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3luYykge1xuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fZGlzcG9zZVJlc291cmNlcyA9ICh0aGlzICYmIHRoaXMuX19kaXNwb3NlUmVzb3VyY2VzKSB8fCAoZnVuY3Rpb24gKFN1cHByZXNzZWRFcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgICAgICAgICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IFN1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgICAgICAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYy5kaXNwb3NlICYmIHJlYy5kaXNwb3NlLmNhbGwocmVjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYy5hc3luYykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9O1xufSkodHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn0pO1xuaW1wb3J0ICogYXMgQmlkaSBmcm9tICdjaHJvbWl1bS1iaWRpL2xpYi9janMvcHJvdG9jb2wvcHJvdG9jb2wuanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0YWNrIH0gZnJvbSAnLi4vdXRpbC9kaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7IGludGVycG9sYXRlRnVuY3Rpb24sIHN0cmluZ2lmeUZ1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5qcyc7XG5pbXBvcnQgeyBCaWRpRWxlbWVudEhhbmRsZSB9IGZyb20gJy4vRWxlbWVudEhhbmRsZS5qcyc7XG5pbXBvcnQgeyBCaWRpSlNIYW5kbGUgfSBmcm9tICcuL0pTSGFuZGxlLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBvc2VhYmxlRnVuY3Rpb24ge1xuICAgIHN0YXRpYyBhc3luYyBmcm9tKGZyYW1lLCBuYW1lLCBhcHBseSwgaXNvbGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBuZXcgRXhwb3NlYWJsZUZ1bmN0aW9uKGZyYW1lLCBuYW1lLCBhcHBseSwgaXNvbGF0ZSk7XG4gICAgICAgIGF3YWl0IGZ1bmMuI2luaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgICNmcmFtZTtcbiAgICBuYW1lO1xuICAgICNhcHBseTtcbiAgICAjaXNvbGF0ZTtcbiAgICAjY2hhbm5lbDtcbiAgICAjc2NyaXB0cyA9IFtdO1xuICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICBjb25zdHJ1Y3RvcihmcmFtZSwgbmFtZSwgYXBwbHksIGlzb2xhdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiNhcHBseSA9IGFwcGx5O1xuICAgICAgICB0aGlzLiNpc29sYXRlID0gaXNvbGF0ZTtcbiAgICAgICAgdGhpcy4jY2hhbm5lbCA9IGBfX3B1cHBldGVlcl9fJHt0aGlzLiNmcmFtZS5faWR9X3BhZ2VfZXhwb3NlRnVuY3Rpb25fJHt0aGlzLm5hbWV9YDtcbiAgICB9XG4gICAgYXN5bmMgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLiNjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBjaGFubmVsID0ge1xuICAgICAgICAgICAgdHlwZTogJ2NoYW5uZWwnLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjaGFubmVsOiB0aGlzLiNjaGFubmVsLFxuICAgICAgICAgICAgICAgIG93bmVyc2hpcDogXCJyb290XCIgLyogQmlkaS5TY3JpcHQuUmVzdWx0T3duZXJzaGlwLlJvb3QgKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKGNvbm5lY3Rpb24pKTtcbiAgICAgICAgY29ubmVjdGlvbkVtaXR0ZXIub24oQmlkaS5DaHJvbWl1bUJpZGkuU2NyaXB0LkV2ZW50TmFtZXMuTWVzc2FnZSwgdGhpcy4jaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gPSBzdHJpbmdpZnlGdW5jdGlvbihpbnRlcnBvbGF0ZUZ1bmN0aW9uKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gICAgICAgICAgICAgICAgW1BMQUNFSE9MREVSKCduYW1lJyldOiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soW3Jlc29sdmUsIHJlamVjdCwgYXJnc10pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHsgbmFtZTogSlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKSB9KSk7XG4gICAgICAgIGNvbnN0IGZyYW1lcyA9IFt0aGlzLiNmcmFtZV07XG4gICAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICAgICAgICBmcmFtZXMucHVzaCguLi5mcmFtZS5jaGlsZEZyYW1lcygpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChmcmFtZXMubWFwKGFzeW5jIChmcmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhbG0gPSB0aGlzLiNpc29sYXRlID8gZnJhbWUuaXNvbGF0ZWRSZWFsbSgpIDogZnJhbWUubWFpblJlYWxtKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzY3JpcHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5icm93c2luZ0NvbnRleHQuYWRkUHJlbG9hZFNjcmlwdChmdW5jdGlvbkRlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtjaGFubmVsXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbmRib3g6IHJlYWxtLnNhbmRib3gsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICByZWFsbS5yZWFsbS5jYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgZmFsc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2NoYW5uZWxdLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNzY3JpcHRzLnB1c2goW2ZyYW1lLCBzY3JpcHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGVycm9ycywgdGhlIGZyYW1lIHByb2JhYmx5IGRvZXNuJ3Qgc3VwcG9ydCBjYWxsIGZ1bmN0aW9uLiBXZVxuICAgICAgICAgICAgICAgIC8vIGZhaWwgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXQgI2Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZS5wYWdlKCkuYnJvd3NlcigpLmNvbm5lY3Rpb247XG4gICAgfVxuICAgICNoYW5kbGVNZXNzYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBlbnZfMSA9IHsgc3RhY2s6IFtdLCBlcnJvcjogdm9pZCAwLCBoYXNFcnJvcjogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2hhbm5lbCAhPT0gdGhpcy4jY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jZ2V0UmVhbG0ocGFyYW1zLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXJlYWxtKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5yZWxhdGVkIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUhhbmRsZSA9IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudl8xLCBCaWRpSlNIYW5kbGUuZnJvbShwYXJhbXMuZGF0YSwgcmVhbG0pLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzSGFuZGxlID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIGF3YWl0IGRhdGFIYW5kbGUuZXZhbHVhdGVIYW5kbGUoKFssICwgYXJnc10pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH0pLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudl8xLCBuZXcgRGlzcG9zYWJsZVN0YWNrKCksIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBoYW5kbGVdIG9mIGF3YWl0IGFyZ3NIYW5kbGUuZ2V0UHJvcGVydGllcygpKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sudXNlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBoYW5kbGVzIGFyZSBwYXNzZWQgYXMgaXMuXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSBpbnN0YW5jZW9mIEJpZGlFbGVtZW50SGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbK2luZGV4XSA9IGhhbmRsZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgcGFzc2VkIGFzIHRoZSBKUyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBhcmdzWytpbmRleF0gPSBoYW5kbGUuanNvblZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLiNhcHBseSguLi4oYXdhaXQgUHJvbWlzZS5hbGwoYXJncykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkYXRhSGFuZGxlLmV2YWx1YXRlKChbLCByZWplY3RdLCBuYW1lLCBtZXNzYWdlLCBzdGFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGF0YUhhbmRsZS5ldmFsdWF0ZSgoWywgcmVqZWN0XSwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYXRhSGFuZGxlLmV2YWx1YXRlKChbcmVzb2x2ZV0sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzEpIHtcbiAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgZW52XzEuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgX19kaXNwb3NlUmVzb3VyY2VzKGVudl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgI2dldFJlYWxtKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuI2ZpbmRGcmFtZShzb3VyY2UuY29udGV4dCk7XG4gICAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgICAgIC8vIFVucmVsYXRlZCBtZXNzYWdlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFtZS5yZWFsbShzb3VyY2UucmVhbG0pO1xuICAgIH1cbiAgICAjZmluZEZyYW1lKGlkKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lcyA9IFt0aGlzLiNmcmFtZV07XG4gICAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICAgICAgICBpZiAoZnJhbWUuX2lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lcy5wdXNoKC4uLmZyYW1lLmNoaWxkRnJhbWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICAgICAgdm9pZCB0aGlzW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgfVxuICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLiNzY3JpcHRzLm1hcChhc3luYyAoW2ZyYW1lLCBzY3JpcHRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IHRoaXMuI2lzb2xhdGUgPyBmcmFtZS5pc29sYXRlZFJlYWxtKCkgOiBmcmFtZS5tYWluUmVhbG0oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICByZWFsbS5ldmFsdWF0ZShuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAuLi5mcmFtZS5jaGlsZEZyYW1lcygpLm1hcChjaGlsZEZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEZyYW1lLmV2YWx1YXRlKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmJyb3dzaW5nQ29udGV4dC5yZW1vdmVQcmVsb2FkU2NyaXB0KHNjcmlwdCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4cG9zZWRGdW5jdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fc2V0RnVuY3Rpb25OYW1lID0gKHRoaXMgJiYgdGhpcy5fX3NldEZ1bmN0aW9uTmFtZSkgfHwgZnVuY3Rpb24gKGYsIG5hbWUsIHByZWZpeCkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBkZWZlciwgZGVsYXlXaGVuLCBmaWx0ZXIsIGZpcnN0LCBmaXJzdFZhbHVlRnJvbSwgbWFwLCBvZiwgcmFjZVdpdGgsIHN3aXRjaE1hcCwgfSBmcm9tICcuLi8uLi90aGlyZF9wYXJ0eS9yeGpzL3J4anMuanMnO1xuaW1wb3J0IHsgRnJhbWUsIHRocm93SWZEZXRhY2hlZCwgfSBmcm9tICcuLi9hcGkvRnJhbWUuanMnO1xuaW1wb3J0IHsgQWNjZXNzaWJpbGl0eSB9IGZyb20gJy4uL2NkcC9BY2Nlc3NpYmlsaXR5LmpzJztcbmltcG9ydCB7IENvbnNvbGVNZXNzYWdlLCB9IGZyb20gJy4uL2NvbW1vbi9Db25zb2xlTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBUYXJnZXRDbG9zZUVycm9yLCBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgZGVidWdFcnJvciwgZnJvbUFib3J0U2lnbmFsLCBmcm9tRW1pdHRlckV2ZW50LCB0aW1lb3V0LCB9IGZyb20gJy4uL2NvbW1vbi91dGlsLmpzJztcbmltcG9ydCB7IGlzRXJyb3JMaWtlIH0gZnJvbSAnLi4vdXRpbC9FcnJvckxpa2UuanMnO1xuaW1wb3J0IHsgQmlkaUNkcFNlc3Npb24gfSBmcm9tICcuL0NEUFNlc3Npb24uanMnO1xuaW1wb3J0IHsgQmlkaURlc2VyaWFsaXplciB9IGZyb20gJy4vRGVzZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IEJpZGlEaWFsb2cgfSBmcm9tICcuL0RpYWxvZy5qcyc7XG5pbXBvcnQgeyBFeHBvc2VhYmxlRnVuY3Rpb24gfSBmcm9tICcuL0V4cG9zZWRGdW5jdGlvbi5qcyc7XG5pbXBvcnQgeyBCaWRpSFRUUFJlcXVlc3QsIHJlcXVlc3RzIH0gZnJvbSAnLi9IVFRQUmVxdWVzdC5qcyc7XG5pbXBvcnQgeyBCaWRpSlNIYW5kbGUgfSBmcm9tICcuL0pTSGFuZGxlLmpzJztcbmltcG9ydCB7IEJpZGlGcmFtZVJlYWxtIH0gZnJvbSAnLi9SZWFsbS5qcyc7XG5pbXBvcnQgeyByZXdyaXRlTmF2aWdhdGlvbkVycm9yIH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7IEJpZGlXZWJXb3JrZXIgfSBmcm9tICcuL1dlYldvcmtlci5qcyc7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgbWFwIENEUCB0aGUgY29ycmVjdCBtZXRob2QuXG4vLyBSZXF1aXJlcyBicmVha2luZyBjaGFuZ2UuXG5mdW5jdGlvbiBjb252ZXJ0Q29uc29sZU1lc3NhZ2VMZXZlbChtZXRob2QpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdncm91cCc6XG4gICAgICAgICAgICByZXR1cm4gJ3N0YXJ0R3JvdXAnO1xuICAgICAgICBjYXNlICdncm91cENvbGxhcHNlZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3N0YXJ0R3JvdXBDb2xsYXBzZWQnO1xuICAgICAgICBjYXNlICdncm91cEVuZCc6XG4gICAgICAgICAgICByZXR1cm4gJ2VuZEdyb3VwJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxufVxubGV0IEJpZGlGcmFtZSA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEZyYW1lO1xuICAgIGxldCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfZ290b19kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0Q29udGVudF9kZWNvcmF0b3JzO1xuICAgIGxldCBfd2FpdEZvck5hdmlnYXRpb25fZGVjb3JhdG9ycztcbiAgICBsZXQgX3ByaXZhdGVfd2FpdEZvckxvYWQkX2RlY29yYXRvcnM7XG4gICAgbGV0IF9wcml2YXRlX3dhaXRGb3JMb2FkJF9kZXNjcmlwdG9yO1xuICAgIGxldCBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2RlY29yYXRvcnM7XG4gICAgbGV0IF9wcml2YXRlX3dhaXRGb3JOZXR3b3JrSWRsZSRfZGVzY3JpcHRvcjtcbiAgICBsZXQgX3NldEZpbGVzX2RlY29yYXRvcnM7XG4gICAgbGV0IF9sb2NhdGVOb2Rlc19kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBCaWRpRnJhbWUgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX2dvdG9fZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGV0YWNoZWRdO1xuICAgICAgICAgICAgX3NldENvbnRlbnRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGV0YWNoZWRdO1xuICAgICAgICAgICAgX3dhaXRGb3JOYXZpZ2F0aW9uX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRldGFjaGVkXTtcbiAgICAgICAgICAgIF9wcml2YXRlX3dhaXRGb3JMb2FkJF9kZWNvcmF0b3JzID0gW3Rocm93SWZEZXRhY2hlZF07XG4gICAgICAgICAgICBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRldGFjaGVkXTtcbiAgICAgICAgICAgIF9zZXRGaWxlc19kZWNvcmF0b3JzID0gW3Rocm93SWZEZXRhY2hlZF07XG4gICAgICAgICAgICBfbG9jYXRlTm9kZXNfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGV0YWNoZWRdO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9nb3RvX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJnb3RvXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJnb3RvXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZ290byB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0Q29udGVudF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic2V0Q29udGVudFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwic2V0Q29udGVudFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldENvbnRlbnQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3dhaXRGb3JOYXZpZ2F0aW9uX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJ3YWl0Rm9yTmF2aWdhdGlvblwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwid2FpdEZvck5hdmlnYXRpb25cIiBpbiBvYmosIGdldDogb2JqID0+IG9iai53YWl0Rm9yTmF2aWdhdGlvbiB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBfcHJpdmF0ZV93YWl0Rm9yTG9hZCRfZGVzY3JpcHRvciA9IHsgdmFsdWU6IF9fc2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgd2FpdFVudGlsID0gJ2xvYWQnIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQ6IG1zID0gdGhpcy50aW1lb3V0U2V0dGluZ3MubmF2aWdhdGlvblRpbWVvdXQoKSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhaXRVbnRpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRVbnRpbCA9IFt3YWl0VW50aWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaWZlY3ljbGVFdmVudCBvZiB3YWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGlmZWN5Y2xlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkb21jb250ZW50bG9hZGVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKCdET01Db250ZW50TG9hZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFsuLi5ldmVudHNdLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUVtaXR0ZXJFdmVudCh0aGlzLmJyb3dzaW5nQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KSkucGlwZShtYXAoKCkgPT4geyB9KSwgZmlyc3QoKSwgcmFjZVdpdGgodGltZW91dChtcyksIHRoaXMuI2RldGFjaGVkJCgpLnBpcGUobWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWUgZGV0YWNoZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSkpO1xuICAgICAgICAgICAgICAgIH0sIFwiI3dhaXRGb3JMb2FkJFwiKSB9LCBfcHJpdmF0ZV93YWl0Rm9yTG9hZCRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcIiN3YWl0Rm9yTG9hZCRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogdHJ1ZSwgYWNjZXNzOiB7IGhhczogb2JqID0+ICN3YWl0Rm9yTG9hZCQgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouI3dhaXRGb3JMb2FkJCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2Rlc2NyaXB0b3IgPSB7IHZhbHVlOiBfX3NldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHdhaXRVbnRpbCA9ICdsb2FkJyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhaXRVbnRpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRVbnRpbCA9IFt3YWl0VW50aWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25jdXJyZW5jeSA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHdhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ldHdvcmtpZGxlMCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY3VycmVuY3kgPSBNYXRoLm1pbigwLCBjb25jdXJyZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXR3b3JraWRsZTInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gTWF0aC5taW4oMiwgY29uY3VycmVuY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZSgpLndhaXRGb3JOZXR3b3JrSWRsZSQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWU6IDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCA/PyB0aGlzLnRpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgXCIjd2FpdEZvck5ldHdvcmtJZGxlJFwiKSB9LCBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCIjd2FpdEZvck5ldHdvcmtJZGxlJFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiB0cnVlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gI3dhaXRGb3JOZXR3b3JrSWRsZSQgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouI3dhaXRGb3JOZXR3b3JrSWRsZSQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3NldEZpbGVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZXRGaWxlc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwic2V0RmlsZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5zZXRGaWxlcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfbG9jYXRlTm9kZXNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImxvY2F0ZU5vZGVzXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJsb2NhdGVOb2Rlc1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmxvY2F0ZU5vZGVzIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKHBhcmVudCwgYnJvd3NpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBCaWRpRnJhbWUocGFyZW50LCBicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgZnJhbWUuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICAjcGFyZW50ID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICBicm93c2luZ0NvbnRleHQ7XG4gICAgICAgICNmcmFtZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICByZWFsbXM7XG4gICAgICAgIF9pZDtcbiAgICAgICAgY2xpZW50O1xuICAgICAgICBhY2Nlc3NpYmlsaXR5O1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJyb3dzaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0ID0gYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5faWQgPSBicm93c2luZ0NvbnRleHQuaWQ7XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBCaWRpQ2RwU2Vzc2lvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVhbG1zID0ge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IEJpZGlGcmFtZVJlYWxtLmZyb20odGhpcy5icm93c2luZ0NvbnRleHQuZGVmYXVsdFJlYWxtLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogQmlkaUZyYW1lUmVhbG0uZnJvbSh0aGlzLmJyb3dzaW5nQ29udGV4dC5jcmVhdGVXaW5kb3dSZWFsbShgX19wdXBwZXRlZXJfaW50ZXJuYWxfJHtNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gKSwgdGhpcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NpYmlsaXR5ID0gbmV3IEFjY2Vzc2liaWxpdHkodGhpcy5yZWFsbXMuZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzaW5nQ29udGV4dCBvZiB0aGlzLmJyb3dzaW5nQ29udGV4dC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NyZWF0ZUZyYW1lVGFyZ2V0KGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dC5vbignYnJvd3Npbmdjb250ZXh0JywgKHsgYnJvd3NpbmdDb250ZXh0IH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNjcmVhdGVGcmFtZVRhcmdldChicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dC5vbignY2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vzc2lvbiBvZiBCaWRpQ2RwU2Vzc2lvbi5zZXNzaW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5mcmFtZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImZyYW1lZGV0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVEZXRhY2hlZCAqLywgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCdyZXF1ZXN0JywgKHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHR0cFJlcXVlc3QgPSBCaWRpSFRUUFJlcXVlc3QuZnJvbShyZXF1ZXN0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uY2UoJ3N1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXF1ZXN0ZmluaXNoZWRcIiAvKiBQYWdlRXZlbnQuUmVxdWVzdEZpbmlzaGVkICovLCBodHRwUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInJlcXVlc3RmYWlsZWRcIiAvKiBQYWdlRXZlbnQuUmVxdWVzdEZhaWxlZCAqLywgaHR0cFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZvaWQgaHR0cFJlcXVlc3QuZmluYWxpemVJbnRlcmNlcHRpb25zKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCduYXZpZ2F0aW9uJywgKHsgbmF2aWdhdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbi5vbmNlKCdmcmFnbWVudCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImZyYW1lbmF2aWdhdGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lTmF2aWdhdGVkICovLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImxvYWRcIiAvKiBQYWdlRXZlbnQuTG9hZCAqLywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzU3RhcnRlZExvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJkb21jb250ZW50bG9hZGVkXCIgLyogUGFnZUV2ZW50LkRPTUNvbnRlbnRMb2FkZWQgKi8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImZyYW1lbmF2aWdhdGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lTmF2aWdhdGVkICovLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ3VzZXJwcm9tcHQnLCAoeyB1c2VyUHJvbXB0IH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2UoKS50cnVzdGVkRW1pdHRlci5lbWl0KFwiZGlhbG9nXCIgLyogUGFnZUV2ZW50LkRpYWxvZyAqLywgQmlkaURpYWxvZy5mcm9tKHVzZXJQcm9tcHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ2xvZycsICh7IGVudHJ5IH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faWQgIT09IGVudHJ5LnNvdXJjZS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29uc29sZUxvZ0VudHJ5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZW50cnkuYXJncy5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5SZWFsbSgpLmNyZWF0ZUhhbmRsZShhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKHZhbHVlLCBhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gYXJnIGluc3RhbmNlb2YgQmlkaUpTSGFuZGxlICYmIGFyZy5pc1ByaW1pdGl2ZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBCaWRpRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKGFyZy5yZW1vdGVWYWx1ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dmFsdWV9ICR7cGFyc2VkVmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgfSwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJjb25zb2xlXCIgLyogUGFnZUV2ZW50LkNvbnNvbGUgKi8sIG5ldyBDb25zb2xlTWVzc2FnZShjb252ZXJ0Q29uc29sZU1lc3NhZ2VMZXZlbChlbnRyeS5tZXRob2QpLCB0ZXh0LCBhcmdzLCBnZXRTdGFja1RyYWNlTG9jYXRpb25zKGVudHJ5LnN0YWNrVHJhY2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSmF2YVNjcmlwdExvZ0VudHJ5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlbnRyeS50ZXh0ID8/ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUhlaWdodCA9IGVycm9yLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUxpbmVzID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLnNwbGljZSgwLCBtZXNzYWdlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBlbnRyeS5zdGFja1RyYWNlLmNhbGxGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHdlIG5lZWQgdG8gYWRkIGAxYCBiZWNhdXNlIHRoZSB2YWx1ZXMgYXJlIDAtaW5kZXhlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0xpbmVzLnB1c2goYCAgICBhdCAke2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnPGFub255bW91cz4nfSAoJHtmcmFtZS51cmx9OiR7ZnJhbWUubGluZU51bWJlciArIDF9OiR7ZnJhbWUuY29sdW1uTnVtYmVyICsgMX0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID49IEVycm9yLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBbLi4ubWVzc2FnZUxpbmVzLCAuLi5zdGFja0xpbmVzXS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInBhZ2VlcnJvclwiIC8qIFBhZ2VFdmVudC5QYWdlRXJyb3IgKi8sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoYFVuaGFuZGxlZCBMb2dFbnRyeSB3aXRoIHR5cGUgXCIke2VudHJ5LnR5cGV9XCIsIHRleHQgXCIke2VudHJ5LnRleHR9XCIgYW5kIGxldmVsIFwiJHtlbnRyeS5sZXZlbH1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ3dvcmtlcicsICh7IHJlYWxtIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXIgPSBCaWRpV2ViV29ya2VyLmZyb20odGhpcywgcmVhbG0pO1xuICAgICAgICAgICAgICAgIHJlYWxtLm9uKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ3b3JrZXJkZXN0cm95ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyRGVzdHJveWVkICovLCB3b3JrZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ3b3JrZXJjcmVhdGVkXCIgLyogUGFnZUV2ZW50LldvcmtlckNyZWF0ZWQgKi8sIHdvcmtlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAjY3JlYXRlRnJhbWVUYXJnZXQoYnJvd3NpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IEJpZGlGcmFtZS5mcm9tKHRoaXMsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZXMuc2V0KGJyb3dzaW5nQ29udGV4dCwgZnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImZyYW1lYXR0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVBdHRhY2hlZCAqLywgZnJhbWUpO1xuICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0Lm9uKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZnJhbWVzLmRlbGV0ZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHRpbWVvdXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2UoKS5fdGltZW91dFNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIG1haW5SZWFsbSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWxtcy5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlzb2xhdGVkUmVhbG0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFsbXMuaW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmVhbG0oaWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhbG0gb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnJlYWxtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhbG0ucmVhbG0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFsbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFnZSgpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgQmlkaUZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHVybCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyb3dzaW5nQ29udGV4dC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50RnJhbWUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGFyZW50IGluc3RhbmNlb2YgQmlkaUZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkRnJhbWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLmJyb3dzaW5nQ29udGV4dC5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWVzLmdldChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAjZGV0YWNoZWQkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRW1pdHRlckV2ZW50KHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLCBcImZyYW1lZGV0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVEZXRhY2hlZCAqLykucGlwZShmaWx0ZXIoZGV0YWNoZWRGcmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXRhY2hlZEZyYW1lID09PSB0aGlzO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGdvdG8odXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IFtyZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0Rm9yTmF2aWdhdGlvbihvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAvLyBTb21lIGltcGxlbWVudGF0aW9ucyBjdXJyZW50bHkgb25seSByZXBvcnQgZXJyb3JzIHdoZW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVhZGluZXNzPWludGVyYWN0aXZlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUmVsYXRlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0NjYwMVxuICAgICAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5uYXZpZ2F0ZSh1cmwsIFwiaW50ZXJhY3RpdmVcIiAvKiBCaWRpLkJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5JbnRlcmFjdGl2ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3JMaWtlKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbmV0OjpFUlJfSFRUUF9SRVNQT05TRV9DT0RFX0ZBSUxVUkUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkuY2F0Y2gocmV3cml0ZU5hdmlnYXRpb25FcnJvcih1cmwsIG9wdGlvbnMudGltZW91dCA/PyB0aGlzLnRpbWVvdXRTZXR0aW5ncy5uYXZpZ2F0aW9uVGltZW91dCgpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Q29udGVudChodG1sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyYW1lQ29udGVudChodG1sKSxcbiAgICAgICAgICAgICAgICBmaXJzdFZhbHVlRnJvbShjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jd2FpdEZvckxvYWQkKG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiN3YWl0Rm9yTmV0d29ya0lkbGUkKG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHdhaXRGb3JOYXZpZ2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0OiBtcyA9IHRoaXMudGltZW91dFNldHRpbmdzLm5hdmlnYXRpb25UaW1lb3V0KCksIHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lcyA9IHRoaXMuY2hpbGRGcmFtZXMoKS5tYXAoZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZS4jZGV0YWNoZWQkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmaXJzdFZhbHVlRnJvbShjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgICAgICBmcm9tRW1pdHRlckV2ZW50KHRoaXMuYnJvd3NpbmdDb250ZXh0LCAnbmF2aWdhdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKHN3aXRjaE1hcCgoeyBuYXZpZ2F0aW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3dhaXRGb3JMb2FkJChvcHRpb25zKS5waXBlKGRlbGF5V2hlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoZnJhbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIHJhY2VXaXRoKGZyb21FbWl0dGVyRXZlbnQobmF2aWdhdGlvbiwgJ2ZyYWdtZW50JyksIGZyb21FbWl0dGVyRXZlbnQobmF2aWdhdGlvbiwgJ2ZhaWxlZCcpLCBmcm9tRW1pdHRlckV2ZW50KG5hdmlnYXRpb24sICdhYm9ydGVkJykucGlwZShtYXAoKHsgdXJsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmF2aWdhdGlvbiBhYm9ydGVkOiAke3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpKSwgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXF1ZXN0RmluaXNoZWQkKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkdWNlcyBmbGFraW5lc3MgaWYgdGhlIHJlc3BvbnNlIGV2ZW50cyBhcnJpdmUgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxvYWQgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHksIHRoZSByZXNwb25zZSBvciBlcnJvciBpcyBhbHJlYWR5IHRoZXJlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlIHx8IHJlcXVlc3QuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihuYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RGaW5pc2hlZCQocmVxdWVzdC5yZWRpcmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21FbWl0dGVyRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUocmFjZVdpdGgoZnJvbUVtaXR0ZXJFdmVudChyZXF1ZXN0LCAnZXJyb3InKSksIHJhY2VXaXRoKGZyb21FbWl0dGVyRXZlbnQocmVxdWVzdCwgJ3JlZGlyZWN0JykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUoc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0RmluaXNoZWQkKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0RmluaXNoZWQkKG5hdmlnYXRpb24ucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YobmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgdGhpcy4jd2FpdEZvck5ldHdvcmtJZGxlJChvcHRpb25zKSxcbiAgICAgICAgICAgIF0pLnBpcGUobWFwKChbbmF2aWdhdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmF2aWdhdGlvbi5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFJlcXVlc3QgPSByZXF1ZXN0Lmxhc3RSZWRpcmVjdCA/PyByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBSZXF1ZXN0ID0gcmVxdWVzdHMuZ2V0KGxhc3RSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlcXVlc3QucmVzcG9uc2UoKTtcbiAgICAgICAgICAgIH0pLCByYWNlV2l0aCh0aW1lb3V0KG1zKSwgZnJvbUFib3J0U2lnbmFsKHNpZ25hbCksIHRoaXMuI2RldGFjaGVkJCgpLnBpcGUobWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGFyZ2V0Q2xvc2VFcnJvcignRnJhbWUgZGV0YWNoZWQuJyk7XG4gICAgICAgICAgICB9KSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FpdEZvckRldmljZVByb21wdCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZXRhY2hlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyb3dzaW5nQ29udGV4dC5jbG9zZWQ7XG4gICAgICAgIH1cbiAgICAgICAgI2V4cG9zZWRGdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGFzeW5jIGV4cG9zZUZ1bmN0aW9uKG5hbWUsIGFwcGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jZXhwb3NlZEZ1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgcGFnZSBiaW5kaW5nIHdpdGggbmFtZSAke25hbWV9OiBnbG9iYWxUaGlzWycke25hbWV9J10gYWxyZWFkeSBleGlzdHMhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHBvc2VhYmxlID0gYXdhaXQgRXhwb3NlYWJsZUZ1bmN0aW9uLmZyb20odGhpcywgbmFtZSwgYXBwbHkpO1xuICAgICAgICAgICAgdGhpcy4jZXhwb3NlZEZ1bmN0aW9ucy5zZXQobmFtZSwgZXhwb3NlYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlRXhwb3NlZEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWRGdW5jdGlvbiA9IHRoaXMuI2V4cG9zZWRGdW5jdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFleHBvc2VkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZW1vdmUgcGFnZSBiaW5kaW5nIHdpdGggbmFtZSAke25hbWV9OiB3aW5kb3dbJyR7bmFtZX0nXSBkb2VzIG5vdCBleGlzdHMhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNleHBvc2VkRnVuY3Rpb25zLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGV4cG9zZWRGdW5jdGlvbltTeW1ib2wuYXN5bmNEaXNwb3NlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNyZWF0ZUNEUFNlc3Npb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFnZSgpLmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNkcENvbm5lY3Rpb24gPSB0aGlzLnBhZ2UoKS5icm93c2VyKCkuY2RwQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjZHBDb25uZWN0aW9uLl9jcmVhdGVTZXNzaW9uKHsgdGFyZ2V0SWQ6IHRoaXMuX2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCAjd2FpdEZvckxvYWQkKCkgeyByZXR1cm4gX3ByaXZhdGVfd2FpdEZvckxvYWQkX2Rlc2NyaXB0b3IudmFsdWU7IH1cbiAgICAgICAgZ2V0ICN3YWl0Rm9yTmV0d29ya0lkbGUkKCkgeyByZXR1cm4gX3ByaXZhdGVfd2FpdEZvck5ldHdvcmtJZGxlJF9kZXNjcmlwdG9yLnZhbHVlOyB9XG4gICAgICAgIGFzeW5jIHNldEZpbGVzKGVsZW1lbnQsIGZpbGVzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJyb3dzaW5nQ29udGV4dC5zZXRGaWxlcyhcbiAgICAgICAgICAgIC8vIFNBRkVUWTogRWxlbWVudEhhbmRsZXMgYXJlIGFsd2F5cyByZW1vdGUgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3RlVmFsdWUoKSwgZmlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGxvY2F0ZU5vZGVzKGVsZW1lbnQsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmJyb3dzaW5nQ29udGV4dC5sb2NhdGVOb2Rlcyhsb2NhdG9yLCBcbiAgICAgICAgICAgIC8vIFNBRkVUWTogRWxlbWVudEhhbmRsZXMgYXJlIGFsd2F5cyByZW1vdGUgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIFtlbGVtZW50LnJlbW90ZVZhbHVlKCldKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQmlkaUZyYW1lIH07XG5mdW5jdGlvbiBpc0NvbnNvbGVMb2dFbnRyeShldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnY29uc29sZSc7XG59XG5mdW5jdGlvbiBpc0phdmFTY3JpcHRMb2dFbnRyeShldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnamF2YXNjcmlwdCc7XG59XG5mdW5jdGlvbiBnZXRTdGFja1RyYWNlTG9jYXRpb25zKHN0YWNrVHJhY2UpIHtcbiAgICBjb25zdCBzdGFja1RyYWNlTG9jYXRpb25zID0gW107XG4gICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsRnJhbWUgb2Ygc3RhY2tUcmFjZS5jYWxsRnJhbWVzKSB7XG4gICAgICAgICAgICBzdGFja1RyYWNlTG9jYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogY2FsbEZyYW1lLnVybCxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBjYWxsRnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNhbGxGcmFtZS5jb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhY2tUcmFjZUxvY2F0aW9ucztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyYW1lLmpzLm1hcCIsInZhciBfYTtcbmltcG9ydCB7IEhUVFBSZXF1ZXN0LCBTVEFUVVNfVEVYVFMsIGhhbmRsZUVycm9yLCB9IGZyb20gJy4uL2FwaS9IVFRQUmVxdWVzdC5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgc3RyaW5nVG9CYXNlNjQgfSBmcm9tICcuLi91dGlsL2VuY29kaW5nLmpzJztcbmltcG9ydCB7IEJpZGlIVFRQUmVzcG9uc2UgfSBmcm9tICcuL0hUVFBSZXNwb25zZS5qcyc7XG5leHBvcnQgY29uc3QgcmVxdWVzdHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlIVFRQUmVxdWVzdCBleHRlbmRzIEhUVFBSZXF1ZXN0IHtcbiAgICBzdGF0aWMgZnJvbShiaWRpUmVxdWVzdCwgZnJhbWUsIHJlZGlyZWN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgX2EoYmlkaVJlcXVlc3QsIGZyYW1lLCByZWRpcmVjdCk7XG4gICAgICAgIHJlcXVlc3QuI2luaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgICNyZWRpcmVjdENoYWluO1xuICAgICNyZXNwb25zZSA9IG51bGw7XG4gICAgaWQ7XG4gICAgI2ZyYW1lO1xuICAgICNyZXF1ZXN0O1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QsIGZyYW1lLCByZWRpcmVjdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICByZXF1ZXN0cy5zZXQocmVxdWVzdCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0aW9uLmVuYWJsZWQgPSByZXF1ZXN0LmlzQmxvY2tlZDtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMuI3JlZGlyZWN0Q2hhaW4gPSByZWRpcmVjdCA/IHJlZGlyZWN0LiNyZWRpcmVjdENoYWluIDogW107XG4gICAgICAgIHRoaXMuaWQgPSByZXF1ZXN0LmlkO1xuICAgIH1cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUuY2xpZW50O1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy4jcmVxdWVzdC5vbigncmVkaXJlY3QnLCByZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBSZXF1ZXN0ID0gX2EuZnJvbShyZXF1ZXN0LCB0aGlzLiNmcmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLiNyZWRpcmVjdENoYWluLnB1c2godGhpcyk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uY2UoJ3N1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgLnBhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInJlcXVlc3RmaW5pc2hlZFwiIC8qIFBhZ2VFdmVudC5SZXF1ZXN0RmluaXNoZWQgKi8sIGh0dHBSZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmcmFtZVxuICAgICAgICAgICAgICAgICAgICAucGFnZSgpXG4gICAgICAgICAgICAgICAgICAgIC50cnVzdGVkRW1pdHRlci5lbWl0KFwicmVxdWVzdGZhaWxlZFwiIC8qIFBhZ2VFdmVudC5SZXF1ZXN0RmFpbGVkICovLCBodHRwUmVxdWVzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgaHR0cFJlcXVlc3QuZmluYWxpemVJbnRlcmNlcHRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0Lm9uY2UoJ3N1Y2Nlc3MnLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlID0gQmlkaUhUVFBSZXNwb25zZS5mcm9tKGRhdGEsIHRoaXMsIHRoaXMuI2ZyYW1lLnBhZ2UoKS5icm93c2VyKCkuY2RwU3VwcG9ydGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3Qub24oJ2F1dGhlbnRpY2F0ZScsIHRoaXMuI2hhbmRsZUF1dGhlbnRpY2F0aW9uKTtcbiAgICAgICAgdGhpcy4jZnJhbWUucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXF1ZXN0XCIgLyogUGFnZUV2ZW50LlJlcXVlc3QgKi8sIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy4jaGFzSW50ZXJuYWxIZWFkZXJPdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0aW9uLmhhbmRsZXJzLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udGludWUoe1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3QudXJsO1xuICAgIH1cbiAgICByZXNvdXJjZVR5cGUoKSB7XG4gICAgICAgIGlmICghdGhpcy4jZnJhbWUucGFnZSgpLmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy4jcmVxdWVzdC5yZXNvdXJjZVR5cGUgfHwgJ290aGVyJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgbWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdC5tZXRob2Q7XG4gICAgfVxuICAgIHBvc3REYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuI2ZyYW1lLnBhZ2UoKS5icm93c2VyKCkuY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdC5wb3N0RGF0YTtcbiAgICB9XG4gICAgaGFzUG9zdERhdGEoKSB7XG4gICAgICAgIGlmICghdGhpcy4jZnJhbWUucGFnZSgpLmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0Lmhhc1Bvc3REYXRhO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFBvc3REYXRhKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgZ2V0ICNoYXNJbnRlcm5hbEhlYWRlck92ZXJ3cml0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oT2JqZWN0LmtleXModGhpcy4jZXh0cmFIVFRQSGVhZGVycykubGVuZ3RoIHx8XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLiN1c2VyQWdlbnRIZWFkZXJzKS5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgI2V4dHJhSFRUUEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZT8ucGFnZSgpLl9leHRyYUhUVFBIZWFkZXJzID8/IHt9O1xuICAgIH1cbiAgICBnZXQgI3VzZXJBZ2VudEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZT8ucGFnZSgpLl91c2VyQWdlbnRIZWFkZXJzID8/IHt9O1xuICAgIH1cbiAgICBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIHRoaXMuI3JlcXVlc3QuaGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1toZWFkZXIubmFtZS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlci52YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgIC4uLnRoaXMuI2V4dHJhSFRUUEhlYWRlcnMsXG4gICAgICAgICAgICAuLi50aGlzLiN1c2VyQWdlbnRIZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlO1xuICAgIH1cbiAgICBmYWlsdXJlKCkge1xuICAgICAgICBpZiAodGhpcy4jcmVxdWVzdC5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlcnJvclRleHQ6IHRoaXMuI3JlcXVlc3QuZXJyb3IgfTtcbiAgICB9XG4gICAgaXNOYXZpZ2F0aW9uUmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3QubmF2aWdhdGlvbiAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpbml0aWF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0LmluaXRpYXRvcjtcbiAgICB9XG4gICAgcmVkaXJlY3RDaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlZGlyZWN0Q2hhaW4uc2xpY2UoKTtcbiAgICB9XG4gICAgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZTtcbiAgICB9XG4gICAgYXN5bmMgY29udGludWUob3ZlcnJpZGVzLCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuY29udGludWUoe1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy4jaGFzSW50ZXJuYWxIZWFkZXJPdmVyd3JpdGUgPyB0aGlzLmhlYWRlcnMoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICAgICAgfSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBhc3luYyBfY29udGludWUob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGdldEJpZGlIZWFkZXJzKG92ZXJyaWRlcy5oZWFkZXJzKTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRpb24uaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXF1ZXN0XG4gICAgICAgICAgICAuY29udGludWVSZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogb3ZlcnJpZGVzLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogb3ZlcnJpZGVzLm1ldGhvZCxcbiAgICAgICAgICAgIGJvZHk6IG92ZXJyaWRlcy5wb3N0RGF0YVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmFzZTY0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmluZ1RvQmFzZTY0KG92ZXJyaWRlcy5wb3N0RGF0YSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycy5sZW5ndGggPiAwID8gaGVhZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5oYW5kbGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2Fib3J0KCkge1xuICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3JlcXVlc3QuZmFpbFJlcXVlc3QoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5oYW5kbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZXNwb25kKHJlc3BvbnNlLCBfcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRpb24uaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIGxldCBwYXJzZWRCb2R5O1xuICAgICAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgcGFyc2VkQm9keSA9IEhUVFBSZXF1ZXN0LmdldFJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRCaWRpSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudExlbmd0aCA9IGhlYWRlcnMuc29tZShoZWFkZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5uYW1lID09PSAnY29udGVudC1sZW5ndGgnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50LXR5cGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzcG9uc2UuY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRCb2R5Py5jb250ZW50TGVuZ3RoICYmICFoYXNDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50LWxlbmd0aCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcocGFyc2VkQm9keS5jb250ZW50TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3JlcXVlc3RcbiAgICAgICAgICAgIC5wcm92aWRlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycy5sZW5ndGggPiAwID8gaGVhZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlYXNvblBocmFzZTogU1RBVFVTX1RFWFRTW3N0YXR1c10sXG4gICAgICAgICAgICBib2R5OiBwYXJzZWRCb2R5Py5iYXNlNjRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jhc2U2NCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRCb2R5Py5iYXNlNjQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0aW9uLmhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgI2F1dGhlbnRpY2F0aW9uSGFuZGxlZCA9IGZhbHNlO1xuICAgICNoYW5kbGVBdXRoZW50aWNhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLiNmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy4jZnJhbWUucGFnZSgpLl9jcmVkZW50aWFscztcbiAgICAgICAgaWYgKGNyZWRlbnRpYWxzICYmICF0aGlzLiNhdXRoZW50aWNhdGlvbkhhbmRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2F1dGhlbnRpY2F0aW9uSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB2b2lkIHRoaXMuI3JlcXVlc3QuY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncHJvdmlkZUNyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFzc3dvcmQnLFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogY3JlZGVudGlhbHMudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBjcmVkZW50aWFscy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuI3JlcXVlc3QuY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY2FuY2VsJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aW1pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0LnRpbWluZygpO1xuICAgIH1cbn1cbl9hID0gQmlkaUhUVFBSZXF1ZXN0O1xuZnVuY3Rpb24gZ2V0QmlkaUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmF3SGVhZGVycyA/PyBbXSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaXModmFsdWUsIHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRUUFJlcXVlc3QuanMubWFwIiwidmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xuaW1wb3J0IHsgSFRUUFJlc3BvbnNlIH0gZnJvbSAnLi4vYXBpL0hUVFBSZXNwb25zZS5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgU2VjdXJpdHlEZXRhaWxzIH0gZnJvbSAnLi4vY29tbW9uL1NlY3VyaXR5RGV0YWlscy5qcyc7XG5pbXBvcnQgeyBpbnZva2VBdE1vc3RPbmNlRm9yQXJndW1lbnRzIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmxldCBCaWRpSFRUUFJlc3BvbnNlID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBIVFRQUmVzcG9uc2U7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9yZW1vdGVBZGRyZXNzX2RlY29yYXRvcnM7XG4gICAgcmV0dXJuIGNsYXNzIEJpZGlIVFRQUmVzcG9uc2UgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX3JlbW90ZUFkZHJlc3NfZGVjb3JhdG9ycyA9IFtpbnZva2VBdE1vc3RPbmNlRm9yQXJndW1lbnRzXTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfcmVtb3RlQWRkcmVzc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicmVtb3RlQWRkcmVzc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVtb3RlQWRkcmVzc1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnJlbW90ZUFkZHJlc3MgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oZGF0YSwgcmVxdWVzdCwgY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBCaWRpSFRUUFJlc3BvbnNlKGRhdGEsIHJlcXVlc3QsIGNkcFN1cHBvcnRlZCk7XG4gICAgICAgICAgICByZXNwb25zZS4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgICNkYXRhID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAjcmVxdWVzdDtcbiAgICAgICAgI3NlY3VyaXR5RGV0YWlscztcbiAgICAgICAgI2NkcFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhLCByZXF1ZXN0LCBjZHBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgdGhpcy4jY2RwU3VwcG9ydGVkID0gY2RwU3VwcG9ydGVkO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub24tc3RhbmRhcmQgcHJvcGVydHkuXG4gICAgICAgICAgICBjb25zdCBzZWN1cml0eURldGFpbHMgPSBkYXRhWydnb29nOnNlY3VyaXR5RGV0YWlscyddO1xuICAgICAgICAgICAgaWYgKGNkcFN1cHBvcnRlZCAmJiBzZWN1cml0eURldGFpbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzZWN1cml0eURldGFpbHMgPSBuZXcgU2VjdXJpdHlEZXRhaWxzKHNlY3VyaXR5RGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jZGF0YS5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIC5mcmFtZSgpXG4gICAgICAgICAgICAgICAgICAgID8ucGFnZSgpXG4gICAgICAgICAgICAgICAgICAgIC50cnVzdGVkRW1pdHRlci5lbWl0KFwicmVxdWVzdHNlcnZlZGZyb21jYWNoZVwiIC8qIFBhZ2VFdmVudC5SZXF1ZXN0U2VydmVkRnJvbUNhY2hlICovLCB0aGlzLiNyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuZnJhbWUoKT8ucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXNwb25zZVwiIC8qIFBhZ2VFdmVudC5SZXNwb25zZSAqLywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3RlQWRkcmVzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXA6ICcnLFxuICAgICAgICAgICAgICAgIHBvcnQ6IC0xLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB1cmwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS51cmw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1c1RleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zdGF0dXNUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiB0aGlzLiNkYXRhLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIEJpbmFyeSBIZWFkZXJzXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyN0eXBlLW5ldHdvcmstSGVhZGVyXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci52YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlci5uYW1lLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBmcm9tQ2FjaGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5mcm9tQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgdGltaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgYmlkaVRpbWluZyA9IHRoaXMuI3JlcXVlc3QudGltaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUaW1lOiBiaWRpVGltaW5nLnJlcXVlc3RUaW1lLFxuICAgICAgICAgICAgICAgIHByb3h5U3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIHByb3h5RW5kOiAtMSxcbiAgICAgICAgICAgICAgICBkbnNTdGFydDogYmlkaVRpbWluZy5kbnNTdGFydCxcbiAgICAgICAgICAgICAgICBkbnNFbmQ6IGJpZGlUaW1pbmcuZG5zRW5kLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RTdGFydDogYmlkaVRpbWluZy5jb25uZWN0U3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdEVuZDogYmlkaVRpbWluZy5jb25uZWN0RW5kLFxuICAgICAgICAgICAgICAgIHNzbFN0YXJ0OiBiaWRpVGltaW5nLnRsc1N0YXJ0LFxuICAgICAgICAgICAgICAgIHNzbEVuZDogLTEsXG4gICAgICAgICAgICAgICAgd29ya2VyU3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIHdvcmtlclJlYWR5OiAtMSxcbiAgICAgICAgICAgICAgICB3b3JrZXJGZXRjaFN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICB3b3JrZXJSZXNwb25kV2l0aFNldHRsZWQ6IC0xLFxuICAgICAgICAgICAgICAgIHdvcmtlclJvdXRlckV2YWx1YXRpb25TdGFydDogLTEsXG4gICAgICAgICAgICAgICAgd29ya2VyQ2FjaGVMb29rdXBTdGFydDogLTEsXG4gICAgICAgICAgICAgICAgc2VuZFN0YXJ0OiBiaWRpVGltaW5nLnJlcXVlc3RTdGFydCxcbiAgICAgICAgICAgICAgICBzZW5kRW5kOiAtMSxcbiAgICAgICAgICAgICAgICBwdXNoU3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgIHB1c2hFbmQ6IC0xLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVIZWFkZXJzU3RhcnQ6IGJpZGlUaW1pbmcucmVzcG9uc2VTdGFydCxcbiAgICAgICAgICAgICAgICByZWNlaXZlSGVhZGVyc0VuZDogYmlkaVRpbWluZy5yZXNwb25zZUVuZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdC5mcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZyb21TZXJ2aWNlV29ya2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlY3VyaXR5RGV0YWlscygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jc2VjdXJpdHlEZXRhaWxzID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpSFRUUFJlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVFRQUmVzcG9uc2UuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IEtleWJvYXJkLCBNb3VzZSwgTW91c2VCdXR0b24sIFRvdWNoc2NyZWVuLCB9IGZyb20gJy4uL2FwaS9JbnB1dC5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xudmFyIFNvdXJjZUFjdGlvbnNUeXBlO1xuKGZ1bmN0aW9uIChTb3VyY2VBY3Rpb25zVHlwZSkge1xuICAgIFNvdXJjZUFjdGlvbnNUeXBlW1wiTm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIFNvdXJjZUFjdGlvbnNUeXBlW1wiS2V5XCJdID0gXCJrZXlcIjtcbiAgICBTb3VyY2VBY3Rpb25zVHlwZVtcIlBvaW50ZXJcIl0gPSBcInBvaW50ZXJcIjtcbiAgICBTb3VyY2VBY3Rpb25zVHlwZVtcIldoZWVsXCJdID0gXCJ3aGVlbFwiO1xufSkoU291cmNlQWN0aW9uc1R5cGUgfHwgKFNvdXJjZUFjdGlvbnNUeXBlID0ge30pKTtcbnZhciBBY3Rpb25UeXBlO1xuKGZ1bmN0aW9uIChBY3Rpb25UeXBlKSB7XG4gICAgQWN0aW9uVHlwZVtcIlBhdXNlXCJdID0gXCJwYXVzZVwiO1xuICAgIEFjdGlvblR5cGVbXCJLZXlEb3duXCJdID0gXCJrZXlEb3duXCI7XG4gICAgQWN0aW9uVHlwZVtcIktleVVwXCJdID0gXCJrZXlVcFwiO1xuICAgIEFjdGlvblR5cGVbXCJQb2ludGVyVXBcIl0gPSBcInBvaW50ZXJVcFwiO1xuICAgIEFjdGlvblR5cGVbXCJQb2ludGVyRG93blwiXSA9IFwicG9pbnRlckRvd25cIjtcbiAgICBBY3Rpb25UeXBlW1wiUG9pbnRlck1vdmVcIl0gPSBcInBvaW50ZXJNb3ZlXCI7XG4gICAgQWN0aW9uVHlwZVtcIlNjcm9sbFwiXSA9IFwic2Nyb2xsXCI7XG59KShBY3Rpb25UeXBlIHx8IChBY3Rpb25UeXBlID0ge30pKTtcbmNvbnN0IGdldEJpZGlLZXlWYWx1ZSA9IChrZXkpID0+IHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAga2V5ID0gJ0VudGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBNZWFzdXJlcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHJhdGhlciB0aGFuIFVURi0xNiBjb2RlIHVuaXRzLlxuICAgIGlmIChbLi4ua2V5XS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnQ2FuY2VsJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwMSc7XG4gICAgICAgIGNhc2UgJ0hlbHAnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDAyJztcbiAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwMyc7XG4gICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDQnO1xuICAgICAgICBjYXNlICdDbGVhcic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDUnO1xuICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDcnO1xuICAgICAgICBjYXNlICdTaGlmdCc6XG4gICAgICAgIGNhc2UgJ1NoaWZ0TGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDgnO1xuICAgICAgICBjYXNlICdDb250cm9sJzpcbiAgICAgICAgY2FzZSAnQ29udHJvbExlZnQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDA5JztcbiAgICAgICAgY2FzZSAnQWx0JzpcbiAgICAgICAgY2FzZSAnQWx0TGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMEEnO1xuICAgICAgICBjYXNlICdQYXVzZSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMEInO1xuICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDBDJztcbiAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwRSc7XG4gICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwRic7XG4gICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTAnO1xuICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxMSc7XG4gICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTInO1xuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxMyc7XG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDE0JztcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxNSc7XG4gICAgICAgIGNhc2UgJ0luc2VydCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTYnO1xuICAgICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDE3JztcbiAgICAgICAgY2FzZSAnTnVtcGFkRXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDE5JztcbiAgICAgICAgY2FzZSAnTnVtcGFkMCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMUEnO1xuICAgICAgICBjYXNlICdOdW1wYWQxJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxQic7XG4gICAgICAgIGNhc2UgJ051bXBhZDInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDFDJztcbiAgICAgICAgY2FzZSAnTnVtcGFkMyc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMUQnO1xuICAgICAgICBjYXNlICdOdW1wYWQ0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxRSc7XG4gICAgICAgIGNhc2UgJ051bXBhZDUnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDFGJztcbiAgICAgICAgY2FzZSAnTnVtcGFkNic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMjAnO1xuICAgICAgICBjYXNlICdOdW1wYWQ3JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAyMSc7XG4gICAgICAgIGNhc2UgJ051bXBhZDgnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDIyJztcbiAgICAgICAgY2FzZSAnTnVtcGFkOSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMjMnO1xuICAgICAgICBjYXNlICdOdW1wYWRNdWx0aXBseSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMjQnO1xuICAgICAgICBjYXNlICdOdW1wYWRBZGQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDI1JztcbiAgICAgICAgY2FzZSAnTnVtcGFkU3VidHJhY3QnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDI3JztcbiAgICAgICAgY2FzZSAnTnVtcGFkRGVjaW1hbCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMjgnO1xuICAgICAgICBjYXNlICdOdW1wYWREaXZpZGUnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDI5JztcbiAgICAgICAgY2FzZSAnRjEnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDMxJztcbiAgICAgICAgY2FzZSAnRjInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDMyJztcbiAgICAgICAgY2FzZSAnRjMnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDMzJztcbiAgICAgICAgY2FzZSAnRjQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM0JztcbiAgICAgICAgY2FzZSAnRjUnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM1JztcbiAgICAgICAgY2FzZSAnRjYnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM2JztcbiAgICAgICAgY2FzZSAnRjcnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM3JztcbiAgICAgICAgY2FzZSAnRjgnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM4JztcbiAgICAgICAgY2FzZSAnRjknOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDM5JztcbiAgICAgICAgY2FzZSAnRjEwJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzQSc7XG4gICAgICAgIGNhc2UgJ0YxMSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwM0InO1xuICAgICAgICBjYXNlICdGMTInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDNDJztcbiAgICAgICAgY2FzZSAnTWV0YSc6XG4gICAgICAgIGNhc2UgJ01ldGFMZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzRCc7XG4gICAgICAgIGNhc2UgJ1NoaWZ0UmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDUwJztcbiAgICAgICAgY2FzZSAnQ29udHJvbFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTA1MSc7XG4gICAgICAgIGNhc2UgJ0FsdFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTA1Mic7XG4gICAgICAgIGNhc2UgJ01ldGFSaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwNTMnO1xuICAgICAgICBjYXNlICdEaWdpdDAnOlxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgY2FzZSAnRGlnaXQxJzpcbiAgICAgICAgICAgIHJldHVybiAnMSc7XG4gICAgICAgIGNhc2UgJ0RpZ2l0Mic6XG4gICAgICAgICAgICByZXR1cm4gJzInO1xuICAgICAgICBjYXNlICdEaWdpdDMnOlxuICAgICAgICAgICAgcmV0dXJuICczJztcbiAgICAgICAgY2FzZSAnRGlnaXQ0JzpcbiAgICAgICAgICAgIHJldHVybiAnNCc7XG4gICAgICAgIGNhc2UgJ0RpZ2l0NSc6XG4gICAgICAgICAgICByZXR1cm4gJzUnO1xuICAgICAgICBjYXNlICdEaWdpdDYnOlxuICAgICAgICAgICAgcmV0dXJuICc2JztcbiAgICAgICAgY2FzZSAnRGlnaXQ3JzpcbiAgICAgICAgICAgIHJldHVybiAnNyc7XG4gICAgICAgIGNhc2UgJ0RpZ2l0OCc6XG4gICAgICAgICAgICByZXR1cm4gJzgnO1xuICAgICAgICBjYXNlICdEaWdpdDknOlxuICAgICAgICAgICAgcmV0dXJuICc5JztcbiAgICAgICAgY2FzZSAnS2V5QSc6XG4gICAgICAgICAgICByZXR1cm4gJ2EnO1xuICAgICAgICBjYXNlICdLZXlCJzpcbiAgICAgICAgICAgIHJldHVybiAnYic7XG4gICAgICAgIGNhc2UgJ0tleUMnOlxuICAgICAgICAgICAgcmV0dXJuICdjJztcbiAgICAgICAgY2FzZSAnS2V5RCc6XG4gICAgICAgICAgICByZXR1cm4gJ2QnO1xuICAgICAgICBjYXNlICdLZXlFJzpcbiAgICAgICAgICAgIHJldHVybiAnZSc7XG4gICAgICAgIGNhc2UgJ0tleUYnOlxuICAgICAgICAgICAgcmV0dXJuICdmJztcbiAgICAgICAgY2FzZSAnS2V5Ryc6XG4gICAgICAgICAgICByZXR1cm4gJ2cnO1xuICAgICAgICBjYXNlICdLZXlIJzpcbiAgICAgICAgICAgIHJldHVybiAnaCc7XG4gICAgICAgIGNhc2UgJ0tleUknOlxuICAgICAgICAgICAgcmV0dXJuICdpJztcbiAgICAgICAgY2FzZSAnS2V5Sic6XG4gICAgICAgICAgICByZXR1cm4gJ2onO1xuICAgICAgICBjYXNlICdLZXlLJzpcbiAgICAgICAgICAgIHJldHVybiAnayc7XG4gICAgICAgIGNhc2UgJ0tleUwnOlxuICAgICAgICAgICAgcmV0dXJuICdsJztcbiAgICAgICAgY2FzZSAnS2V5TSc6XG4gICAgICAgICAgICByZXR1cm4gJ20nO1xuICAgICAgICBjYXNlICdLZXlOJzpcbiAgICAgICAgICAgIHJldHVybiAnbic7XG4gICAgICAgIGNhc2UgJ0tleU8nOlxuICAgICAgICAgICAgcmV0dXJuICdvJztcbiAgICAgICAgY2FzZSAnS2V5UCc6XG4gICAgICAgICAgICByZXR1cm4gJ3AnO1xuICAgICAgICBjYXNlICdLZXlRJzpcbiAgICAgICAgICAgIHJldHVybiAncSc7XG4gICAgICAgIGNhc2UgJ0tleVInOlxuICAgICAgICAgICAgcmV0dXJuICdyJztcbiAgICAgICAgY2FzZSAnS2V5Uyc6XG4gICAgICAgICAgICByZXR1cm4gJ3MnO1xuICAgICAgICBjYXNlICdLZXlUJzpcbiAgICAgICAgICAgIHJldHVybiAndCc7XG4gICAgICAgIGNhc2UgJ0tleVUnOlxuICAgICAgICAgICAgcmV0dXJuICd1JztcbiAgICAgICAgY2FzZSAnS2V5Vic6XG4gICAgICAgICAgICByZXR1cm4gJ3YnO1xuICAgICAgICBjYXNlICdLZXlXJzpcbiAgICAgICAgICAgIHJldHVybiAndyc7XG4gICAgICAgIGNhc2UgJ0tleVgnOlxuICAgICAgICAgICAgcmV0dXJuICd4JztcbiAgICAgICAgY2FzZSAnS2V5WSc6XG4gICAgICAgICAgICByZXR1cm4gJ3knO1xuICAgICAgICBjYXNlICdLZXlaJzpcbiAgICAgICAgICAgIHJldHVybiAneic7XG4gICAgICAgIGNhc2UgJ1NlbWljb2xvbic6XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICBjYXNlICdFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gJz0nO1xuICAgICAgICBjYXNlICdDb21tYSc6XG4gICAgICAgICAgICByZXR1cm4gJywnO1xuICAgICAgICBjYXNlICdNaW51cyc6XG4gICAgICAgICAgICByZXR1cm4gJy0nO1xuICAgICAgICBjYXNlICdQZXJpb2QnOlxuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgY2FzZSAnU2xhc2gnOlxuICAgICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgICAgY2FzZSAnQmFja3F1b3RlJzpcbiAgICAgICAgICAgIHJldHVybiAnYCc7XG4gICAgICAgIGNhc2UgJ0JyYWNrZXRMZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiAnWyc7XG4gICAgICAgIGNhc2UgJ0JhY2tzbGFzaCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwnO1xuICAgICAgICBjYXNlICdCcmFja2V0UmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuICddJztcbiAgICAgICAgY2FzZSAnUXVvdGUnOlxuICAgICAgICAgICAgcmV0dXJuICdcIic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24ga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgfVxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpS2V5Ym9hcmQgZXh0ZW5kcyBLZXlib2FyZCB7XG4gICAgI3BhZ2U7XG4gICAgY29uc3RydWN0b3IocGFnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNwYWdlID0gcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgZG93bihrZXksIF9vcHRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5LZXksXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfa2V5Ym9hcmRcIiAvKiBJbnB1dElkLktleWJvYXJkICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5LZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldEJpZGlLZXlWYWx1ZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdXAoa2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5LZXksXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfa2V5Ym9hcmRcIiAvKiBJbnB1dElkLktleWJvYXJkICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5LZXlVcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRCaWRpS2V5VmFsdWUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHByZXNzKGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5RG93bixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0QmlkaUtleVZhbHVlKGtleSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUGF1c2UsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRlbGF5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5VXAsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0QmlkaUtleVZhbHVlKGtleSksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuS2V5LFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX2tleWJvYXJkXCIgLyogSW5wdXRJZC5LZXlib2FyZCAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHR5cGUodGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgICAvLyBUaGlzIHNwcmVhZCBzZXBhcmF0ZXMgdGhlIGNoYXJhY3RlcnMgaW50byBjb2RlIHBvaW50cyByYXRoZXIgdGhhbiBVVEYtMTZcbiAgICAgICAgLy8gY29kZSB1bml0cy5cbiAgICAgICAgY29uc3QgdmFsdWVzID0gWy4uLnRleHRdLm1hcChnZXRCaWRpS2V5VmFsdWUpO1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkZWxheSA8PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLktleVVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5LZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkZWxheSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5VXAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5LZXksXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfa2V5Ym9hcmRcIiAvKiBJbnB1dElkLktleWJvYXJkICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENoYXJhY3RlcihjaGFyKSB7XG4gICAgICAgIC8vIE1lYXN1cmVzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgcmF0aGVyIHRoYW4gVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICAgIGlmIChbLi4uY2hhcl0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2VuZCBtb3JlIHRoYW4gMSBjaGFyYWN0ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBhd2FpdCB0aGlzLiNwYWdlLmZvY3VzZWRGcmFtZSgpO1xuICAgICAgICBhd2FpdCBmcmFtZS5pc29sYXRlZFJlYWxtKCkuZXZhbHVhdGUoYXN5bmMgKGNoYXIpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JywgZmFsc2UsIGNoYXIpO1xuICAgICAgICB9LCBjaGFyKTtcbiAgICB9XG59XG5jb25zdCBnZXRCaWRpQnV0dG9uID0gKGJ1dHRvbikgPT4ge1xuICAgIHN3aXRjaCAoYnV0dG9uKSB7XG4gICAgICAgIGNhc2UgTW91c2VCdXR0b24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIE1vdXNlQnV0dG9uLk1pZGRsZTpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIE1vdXNlQnV0dG9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgTW91c2VCdXR0b24uQmFjazpcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICBjYXNlIE1vdXNlQnV0dG9uLkZvcndhcmQ6XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlNb3VzZSBleHRlbmRzIE1vdXNlIHtcbiAgICAjcGFnZTtcbiAgICAjbGFzdE1vdmVQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jcGFnZSA9IHBhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHJlc2V0KCkge1xuICAgICAgICB0aGlzLiNsYXN0TW92ZVBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnJlbGVhc2VBY3Rpb25zKCk7XG4gICAgfVxuICAgIGFzeW5jIG1vdmUoeCwgeSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLiNsYXN0TW92ZVBvaW50O1xuICAgICAgICBjb25zdCB0byA9IHtcbiAgICAgICAgICAgIHg6IE1hdGgucm91bmQoeCksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gb3B0aW9ucy5zdGVwcyA/PyAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyArK2kpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyTW92ZSxcbiAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyAodG8ueCAtIGZyb20ueCkgKiAoaSAvIHN0ZXBzKSxcbiAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyAodG8ueSAtIGZyb20ueSkgKiAoaSAvIHN0ZXBzKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9wdGlvbnMub3JpZ2luLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlck1vdmUsXG4gICAgICAgICAgICAuLi50byxcbiAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI2NvbW1hbmQtaW5wdXQtcGVyZm9ybUFjdGlvbnM6fjp0ZXh0PWlucHV0LlBvaW50ZXJNb3ZlQWN0aW9uJTIwJTNEJTIwJTdCJTBBJTIwJTIwdHlwZSUzQSUyMCUyMnBvaW50ZXJNb3ZlJTIyJTJDJTBBJTIwJTIweCUzQSUyMGpzJTJEaW50JTJDXG4gICAgICAgIHRoaXMuI2xhc3RNb3ZlUG9pbnQgPSB0bztcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfbW91c2VcIiAvKiBJbnB1dElkLk1vdXNlICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZG93bihvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfbW91c2VcIiAvKiBJbnB1dElkLk1vdXNlICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogZ2V0QmlkaUJ1dHRvbihvcHRpb25zLmJ1dHRvbiA/PyBNb3VzZUJ1dHRvbi5MZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVwKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuUG9pbnRlcixcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl9tb3VzZVwiIC8qIElucHV0SWQuTW91c2UgKi8sXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJVcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogZ2V0QmlkaUJ1dHRvbihvcHRpb25zLmJ1dHRvbiA/PyBNb3VzZUJ1dHRvbi5MZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGNsaWNrKHgsIHksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlck1vdmUsXG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZCh4KSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkpLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBwb2ludGVyRG93bkFjdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlckRvd24sXG4gICAgICAgICAgICBidXR0b246IGdldEJpZGlCdXR0b24ob3B0aW9ucy5idXR0b24gPz8gTW91c2VCdXR0b24uTGVmdCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50ZXJVcEFjdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlclVwLFxuICAgICAgICAgICAgYnV0dG9uOiBwb2ludGVyRG93bkFjdGlvbi5idXR0b24sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgKG9wdGlvbnMuY291bnQgPz8gMSk7ICsraSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHBvaW50ZXJEb3duQWN0aW9uLCBwb2ludGVyVXBBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMucHVzaChwb2ludGVyRG93bkFjdGlvbik7XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGF5KSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUGF1c2UsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZGVsYXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zLnB1c2gocG9pbnRlclVwQWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfbW91c2VcIiAvKiBJbnB1dElkLk1vdXNlICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgd2hlZWwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5XaGVlbCxcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl93aGVlbFwiIC8qIElucHV0SWQuV2hlZWwgKi8sXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlNjcm9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLiNsYXN0TW92ZVBvaW50ID8/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWDogb3B0aW9ucy5kZWx0YVggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWTogb3B0aW9ucy5kZWx0YVkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGRyYWcoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBkcmFnT3ZlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIGRyYWdFbnRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBkcmFnQW5kRHJvcCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlUb3VjaHNjcmVlbiBleHRlbmRzIFRvdWNoc2NyZWVuIHtcbiAgICAjcGFnZTtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI3BhZ2UgPSBwYWdlO1xuICAgIH1cbiAgICBhc3luYyB0b3VjaFN0YXJ0KHgsIHksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuUG9pbnRlcixcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl9maW5nZXJcIiAvKiBJbnB1dElkLkZpbmdlciAqLyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBcInRvdWNoXCIgLyogQmlkaS5JbnB1dC5Qb2ludGVyVHlwZS5Ub3VjaCAqLyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQoeCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcHRpb25zLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLjUgKiAyLCAvLyAyIHRpbWVzIGRlZmF1bHQgdG91Y2ggcmFkaXVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLjUgKiAyLCAvLyAyIHRpbWVzIGRlZmF1bHQgdG91Y2ggcmFkaXVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc3N1cmU6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGl0dWRlQW5nbGU6IE1hdGguUEkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdG91Y2hNb3ZlKHgsIHksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuUG9pbnRlcixcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl9maW5nZXJcIiAvKiBJbnB1dElkLkZpbmdlciAqLyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBcInRvdWNoXCIgLyogQmlkaS5JbnB1dC5Qb2ludGVyVHlwZS5Ub3VjaCAqLyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQoeCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcHRpb25zLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLjUgKiAyLCAvLyAyIHRpbWVzIGRlZmF1bHQgdG91Y2ggcmFkaXVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLjUgKiAyLCAvLyAyIHRpbWVzIGRlZmF1bHQgdG91Y2ggcmFkaXVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc3N1cmU6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGl0dWRlQW5nbGU6IE1hdGguUEkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdG91Y2hFbmQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5Qb2ludGVyLFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX2ZpbmdlclwiIC8qIElucHV0SWQuRmluZ2VyICovLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IFwidG91Y2hcIiAvKiBCaWRpLklucHV0LlBvaW50ZXJUeXBlLlRvdWNoICovLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJVcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5wdXQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IEpTSGFuZGxlIH0gZnJvbSAnLi4vYXBpL0pTSGFuZGxlLmpzJztcbmltcG9ydCB7IFVuc3VwcG9ydGVkT3BlcmF0aW9uIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBCaWRpRGVzZXJpYWxpemVyIH0gZnJvbSAnLi9EZXNlcmlhbGl6ZXIuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlKU0hhbmRsZSBleHRlbmRzIEpTSGFuZGxlIHtcbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSwgcmVhbG0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWRpSlNIYW5kbGUodmFsdWUsIHJlYWxtKTtcbiAgICB9XG4gICAgI3JlbW90ZVZhbHVlO1xuICAgIHJlYWxtO1xuICAgICNkaXNwb3NlZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZWFsbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNyZW1vdGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlYWxtID0gcmVhbG07XG4gICAgfVxuICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2VkO1xuICAgIH1cbiAgICBhc3luYyBqc29uVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV2YWx1YXRlKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFsbS5kZXN0cm95SGFuZGxlcyhbdGhpc10pO1xuICAgIH1cbiAgICBnZXQgaXNQcmltaXRpdmVWYWx1ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLiNyZW1vdGVWYWx1ZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pc1ByaW1pdGl2ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0pTSGFuZGxlOicgKyBCaWRpRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHRoaXMuI3JlbW90ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0pTSGFuZGxlQCcgKyB0aGlzLiNyZW1vdGVWYWx1ZS50eXBlO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiAnaGFuZGxlJyBpbiB0aGlzLiNyZW1vdGVWYWx1ZSA/IHRoaXMuI3JlbW90ZVZhbHVlLmhhbmRsZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmVtb3RlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZW1vdGVWYWx1ZTtcbiAgICB9XG4gICAgcmVtb3RlT2JqZWN0KCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oJ05vdCBhdmFpbGFibGUgaW4gV2ViRHJpdmVyIEJpRGknKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1KU0hhbmRsZS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlID0gKHRoaXMgJiYgdGhpcy5fX2FkZERpc3Bvc2FibGVSZXNvdXJjZSkgfHwgZnVuY3Rpb24gKGVudiwgdmFsdWUsIGFzeW5jKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XG4gICAgICAgIHZhciBkaXNwb3NlO1xuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICAgICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICAgICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2Rpc3Bvc2VSZXNvdXJjZXMgPSAodGhpcyAmJiB0aGlzLl9fZGlzcG9zZVJlc291cmNlcykgfHwgKGZ1bmN0aW9uIChTdXBwcmVzc2VkRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVudikge1xuICAgICAgICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICAgICAgICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBTdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgICAgICAgICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgd2hpbGUgKGVudi5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjID0gZW52LnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWMuZGlzcG9zZSAmJiByZWMuZGlzcG9zZS5jYWxsKHJlYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWMuYXN5bmMpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfTtcbn0pKHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59KTtcbmltcG9ydCB7IGZpcnN0VmFsdWVGcm9tLCBmcm9tLCByYWNlV2l0aCB9IGZyb20gJy4uLy4uL3RoaXJkX3BhcnR5L3J4anMvcnhqcy5qcyc7XG5pbXBvcnQgeyBQYWdlLCB9IGZyb20gJy4uL2FwaS9QYWdlLmpzJztcbmltcG9ydCB7IENvdmVyYWdlIH0gZnJvbSAnLi4vY2RwL0NvdmVyYWdlLmpzJztcbmltcG9ydCB7IEVtdWxhdGlvbk1hbmFnZXIgfSBmcm9tICcuLi9jZHAvRW11bGF0aW9uTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBUcmFjaW5nIH0gZnJvbSAnLi4vY2RwL1RyYWNpbmcuanMnO1xuaW1wb3J0IHsgVW5zdXBwb3J0ZWRPcGVyYXRpb24gfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgZXZhbHVhdGlvblN0cmluZywgaXNTdHJpbmcsIHBhcnNlUERGT3B0aW9ucywgdGltZW91dCwgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBidWJibGUgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgc3RyaW5nVG9UeXBlZEFycmF5IH0gZnJvbSAnLi4vdXRpbC9lbmNvZGluZy5qcyc7XG5pbXBvcnQgeyBpc0Vycm9yTGlrZSB9IGZyb20gJy4uL3V0aWwvRXJyb3JMaWtlLmpzJztcbmltcG9ydCB7IEJpZGlGcmFtZSB9IGZyb20gJy4vRnJhbWUuanMnO1xuaW1wb3J0IHsgQmlkaUtleWJvYXJkLCBCaWRpTW91c2UsIEJpZGlUb3VjaHNjcmVlbiB9IGZyb20gJy4vSW5wdXQuanMnO1xuaW1wb3J0IHsgcmV3cml0ZU5hdmlnYXRpb25FcnJvciB9IGZyb20gJy4vdXRpbC5qcyc7XG4vKipcbiAqIEltcGxlbWVudHMgUGFnZSB1c2luZyBXZWJEcml2ZXIgQmlEaS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlQYWdlID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBQYWdlO1xuICAgIGxldCBfdHJ1c3RlZEVtaXR0ZXJfZGVjb3JhdG9ycztcbiAgICBsZXQgX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfdHJ1c3RlZEVtaXR0ZXJfZXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICByZXR1cm4gY2xhc3MgQmlkaVBhZ2UgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnMgPSBbYnViYmxlKCldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwiYWNjZXNzb3JcIiwgbmFtZTogXCJ0cnVzdGVkRW1pdHRlclwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwidHJ1c3RlZEVtaXR0ZXJcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai50cnVzdGVkRW1pdHRlciwgc2V0OiAob2JqLCB2YWx1ZSkgPT4geyBvYmoudHJ1c3RlZEVtaXR0ZXIgPSB2YWx1ZTsgfSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIF90cnVzdGVkRW1pdHRlcl9pbml0aWFsaXplcnMsIF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oYnJvd3NlckNvbnRleHQsIGJyb3dzaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IG5ldyBCaWRpUGFnZShicm93c2VyQ29udGV4dCwgYnJvd3NpbmdDb250ZXh0KTtcbiAgICAgICAgICAgIHBhZ2UuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgICB9XG4gICAgICAgICN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycywgbmV3IEV2ZW50RW1pdHRlcigpKTtcbiAgICAgICAgZ2V0IHRydXN0ZWRFbWl0dGVyKCkgeyByZXR1cm4gdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZTsgfVxuICAgICAgICBzZXQgdHJ1c3RlZEVtaXR0ZXIodmFsdWUpIHsgdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9XG4gICAgICAgICNicm93c2VyQ29udGV4dCA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNmcmFtZTtcbiAgICAgICAgI3ZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgI3dvcmtlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGtleWJvYXJkO1xuICAgICAgICBtb3VzZTtcbiAgICAgICAgdG91Y2hzY3JlZW47XG4gICAgICAgIHRyYWNpbmc7XG4gICAgICAgIGNvdmVyYWdlO1xuICAgICAgICAjY2RwRW11bGF0aW9uTWFuYWdlcjtcbiAgICAgICAgI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnM7XG4gICAgICAgIF9jbGllbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUuY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGJyb3dzZXJDb250ZXh0LCBicm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyQ29udGV4dCA9IGJyb3dzZXJDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUgPSBCaWRpRnJhbWUuZnJvbSh0aGlzLCBicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlciA9IG5ldyBFbXVsYXRpb25NYW5hZ2VyKHRoaXMuI2ZyYW1lLmNsaWVudCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNpbmcgPSBuZXcgVHJhY2luZyh0aGlzLiNmcmFtZS5jbGllbnQpO1xuICAgICAgICAgICAgdGhpcy5jb3ZlcmFnZSA9IG5ldyBDb3ZlcmFnZSh0aGlzLiNmcmFtZS5jbGllbnQpO1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZCA9IG5ldyBCaWRpS2V5Ym9hcmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1vdXNlID0gbmV3IEJpZGlNb3VzZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2hzY3JlZW4gPSBuZXcgQmlkaVRvdWNoc2NyZWVuKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0Lm9uKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cnVzdGVkRW1pdHRlci5lbWl0KFwiY2xvc2VcIiAvKiBQYWdlRXZlbnQuQ2xvc2UgKi8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cnVzdGVkRW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cnVzdGVkRW1pdHRlci5vbihcIndvcmtlcmNyZWF0ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyQ3JlYXRlZCAqLywgd29ya2VyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiN3b3JrZXJzLmFkZCh3b3JrZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLm9uKFwid29ya2VyZGVzdHJveWVkXCIgLyogUGFnZUV2ZW50LldvcmtlckRlc3Ryb3llZCAqLywgd29ya2VyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiN3b3JrZXJzLmRlbGV0ZSh3b3JrZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX3VzZXJBZ2VudEhlYWRlcnMgPSB7fTtcbiAgICAgICAgI3VzZXJBZ2VudEludGVyY2VwdGlvbjtcbiAgICAgICAgI3VzZXJBZ2VudFByZWxvYWRTY3JpcHQ7XG4gICAgICAgIGFzeW5jIHNldFVzZXJBZ2VudCh1c2VyQWdlbnQsIHVzZXJBZ2VudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2Jyb3dzZXJDb250ZXh0LmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQgJiYgdXNlckFnZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oJ0N1cnJlbnQgQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGB1c2VyQWdlbnRNZXRhZGF0YWAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuI2Jyb3dzZXJDb250ZXh0LmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQgJiZcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9jbGllbnQoKS5zZW5kKCdOZXR3b3JrLnNldFVzZXJBZ2VudE92ZXJyaWRlJywge1xuICAgICAgICAgICAgICAgICAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgdXNlckFnZW50TWV0YWRhdGE6IHVzZXJBZ2VudE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5hYmxlID0gdXNlckFnZW50ICE9PSAnJztcbiAgICAgICAgICAgIHVzZXJBZ2VudCA9IHVzZXJBZ2VudCA/PyAoYXdhaXQgdGhpcy4jYnJvd3NlckNvbnRleHQuYnJvd3NlcigpLnVzZXJBZ2VudCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJBZ2VudEhlYWRlcnMgPSBlbmFibGVcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiB1c2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICB0aGlzLiN1c2VyQWdlbnRJbnRlcmNlcHRpb24gPSBhd2FpdCB0aGlzLiN0b2dnbGVJbnRlcmNlcHRpb24oW1wiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBCaWRpLk5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi9dLCB0aGlzLiN1c2VyQWdlbnRJbnRlcmNlcHRpb24sIGVuYWJsZSk7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VVc2VyQWdlbnQgPSAodXNlckFnZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3VzZXJBZ2VudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmcmFtZXMgPSBbdGhpcy4jZnJhbWVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmcmFtZXMucHVzaCguLi5mcmFtZS5jaGlsZEZyYW1lcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiN1c2VyQWdlbnRQcmVsb2FkU2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudCh0aGlzLiN1c2VyQWdlbnRQcmVsb2FkU2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtldmFsdWF0ZVRva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBlbmFibGVcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmV2YWx1YXRlT25OZXdEb2N1bWVudChjaGFuZ2VVc2VyQWdlbnQsIHVzZXJBZ2VudClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBkaXNhYmxlIHRoZSBVc2VyQWdlbnQgd2Ugd2FudCB0b1xuICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRlIHRoZSBvcmlnaW5hbCB2YWx1ZSBpbiBhbGwgQnJvd3NpbmcgQ29udGV4dHNcbiAgICAgICAgICAgICAgICBmcmFtZXMubWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLmV2YWx1YXRlKGNoYW5nZVVzZXJBZ2VudCwgdXNlckFnZW50KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy4jdXNlckFnZW50UHJlbG9hZFNjcmlwdCA9IGV2YWx1YXRlVG9rZW4/LmlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0QnlwYXNzQ1NQKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSBDRFAtc3BlY2lmaWMgY2FzZXMgc3VjaCBhcyBtcHJhY2guXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQoKS5zZW5kKCdQYWdlLnNldEJ5cGFzc0NTUCcsIHsgZW5hYmxlZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBxdWVyeU9iamVjdHMocHJvdG90eXBlSGFuZGxlKSB7XG4gICAgICAgICAgICBhc3NlcnQoIXByb3RvdHlwZUhhbmRsZS5kaXNwb3NlZCwgJ1Byb3RvdHlwZSBKU0hhbmRsZSBpcyBkaXNwb3NlZCEnKTtcbiAgICAgICAgICAgIGFzc2VydChwcm90b3R5cGVIYW5kbGUuaWQsICdQcm90b3R5cGUgSlNIYW5kbGUgbXVzdCBub3QgYmUgcmVmZXJlbmNpbmcgcHJpbWl0aXZlIHZhbHVlJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuI2ZyYW1lLmNsaWVudC5zZW5kKCdSdW50aW1lLnF1ZXJ5T2JqZWN0cycsIHtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGVPYmplY3RJZDogcHJvdG90eXBlSGFuZGxlLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUubWFpblJlYWxtKCkuY3JlYXRlSGFuZGxlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIGhhbmRsZTogcmVzcG9uc2Uub2JqZWN0cy5vYmplY3RJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyb3dzZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyQ29udGV4dCgpLmJyb3dzZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBtYWluRnJhbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZm9jdXNlZEZyYW1lKCkge1xuICAgICAgICAgICAgY29uc3QgZW52XzEgPSB7IHN0YWNrOiBbXSwgZXJyb3I6IHZvaWQgMCwgaGFzRXJyb3I6IGZhbHNlIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudl8xLCAoYXdhaXQgdGhpcy5tYWluRnJhbWUoKVxuICAgICAgICAgICAgICAgICAgICAuaXNvbGF0ZWRSZWFsbSgpXG4gICAgICAgICAgICAgICAgICAgIC5ldmFsdWF0ZUhhbmRsZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aW4gPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh3aW4uZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiB3aW4uSFRNTEZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi5kb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRlbnRXaW5kb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbiA9IHdpbi5kb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICB9KSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZS5yZW1vdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGFzc2VydCh2YWx1ZS50eXBlID09PSAnd2luZG93Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmZyYW1lcygpLmZpbmQoZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWUuX2lkID09PSB2YWx1ZS52YWx1ZS5jb250ZXh0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydChmcmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWVzKCkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gW3RoaXMuI2ZyYW1lXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVzLnB1c2goLi4uZnJhbWUuY2hpbGRGcmFtZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lLmRldGFjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNsb3NlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudl8yID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZ3VhcmQgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMiwgYXdhaXQgdGhpcy4jYnJvd3NlckNvbnRleHQud2FpdEZvclNjcmVlbnNob3RPcGVyYXRpb25zKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuY2xvc2Uob3B0aW9ucz8ucnVuQmVmb3JlVW5sb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMikge1xuICAgICAgICAgICAgICAgIGVudl8yLmVycm9yID0gZV8yO1xuICAgICAgICAgICAgICAgIGVudl8yLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVsb2FkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLiNmcmFtZS53YWl0Rm9yTmF2aWdhdGlvbihvcHRpb25zKSxcbiAgICAgICAgICAgICAgICB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQucmVsb2FkKCksXG4gICAgICAgICAgICBdKS5jYXRjaChyZXdyaXRlTmF2aWdhdGlvbkVycm9yKHRoaXMudXJsKCksIG9wdGlvbnMudGltZW91dCA/PyB0aGlzLl90aW1lb3V0U2V0dGluZ3MubmF2aWdhdGlvblRpbWVvdXQoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHNldERlZmF1bHROYXZpZ2F0aW9uVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0U2V0dGluZ3Muc2V0RGVmYXVsdE5hdmlnYXRpb25UaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldERlZmF1bHRUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRTZXR0aW5ncy5zZXREZWZhdWx0VGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBnZXREZWZhdWx0VGltZW91dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lb3V0U2V0dGluZ3MudGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlzSmF2YVNjcmlwdEVuYWJsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5qYXZhc2NyaXB0RW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRHZW9sb2NhdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5zZXRHZW9sb2NhdGlvbihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRKYXZhU2NyaXB0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5zZXRKYXZhU2NyaXB0RW5hYmxlZChlbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlbXVsYXRlTWVkaWFUeXBlKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVNZWRpYVR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZW11bGF0ZUNQVVRocm90dGxpbmcoZmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5lbXVsYXRlQ1BVVGhyb3R0bGluZyhmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVtdWxhdGVNZWRpYUZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5lbXVsYXRlTWVkaWFGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZW11bGF0ZVRpbWV6b25lKHRpbWV6b25lSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVUaW1lem9uZSh0aW1lem9uZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlbXVsYXRlSWRsZVN0YXRlKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NkcEVtdWxhdGlvbk1hbmFnZXIuZW11bGF0ZUlkbGVTdGF0ZShvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVtdWxhdGVWaXNpb25EZWZpY2llbmN5KHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVWaXNpb25EZWZpY2llbmN5KHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydD8ud2lkdGggJiYgdmlld3BvcnQ/LmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiB2aWV3cG9ydD8uZGV2aWNlU2NhbGVGYWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmlld3BvcnQuZGV2aWNlU2NhbGVGYWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLiN2aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5lZWRzUmVsb2FkID0gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5lbXVsYXRlVmlld3BvcnQodmlld3BvcnQpO1xuICAgICAgICAgICAgdGhpcy4jdmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGlmIChuZWVkc1JlbG9hZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlld3BvcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcGRmKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0OiBtcyA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCksIHBhdGggPSB1bmRlZmluZWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IHByaW50QmFja2dyb3VuZDogYmFja2dyb3VuZCwgbWFyZ2luLCBsYW5kc2NhcGUsIHdpZHRoLCBoZWlnaHQsIHBhZ2VSYW5nZXM6IHJhbmdlcywgc2NhbGUsIHByZWZlckNTU1BhZ2VTaXplLCB9ID0gcGFyc2VQREZPcHRpb25zKG9wdGlvbnMsICdjbScpO1xuICAgICAgICAgICAgY29uc3QgcGFnZVJhbmdlcyA9IHJhbmdlcyA/IHJhbmdlcy5zcGxpdCgnLCAnKSA6IFtdO1xuICAgICAgICAgICAgYXdhaXQgZmlyc3RWYWx1ZUZyb20oZnJvbSh0aGlzLm1haW5GcmFtZSgpXG4gICAgICAgICAgICAgICAgLmlzb2xhdGVkUmVhbG0oKVxuICAgICAgICAgICAgICAgIC5ldmFsdWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZvbnRzLnJlYWR5O1xuICAgICAgICAgICAgfSkpLnBpcGUocmFjZVdpdGgodGltZW91dChtcykpKSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZmlyc3RWYWx1ZUZyb20oZnJvbSh0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQucHJpbnQoe1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBsYW5kc2NhcGUgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCcsXG4gICAgICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFnZVJhbmdlcyxcbiAgICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgICBzaHJpbmtUb0ZpdDogIXByZWZlckNTU1BhZ2VTaXplLFxuICAgICAgICAgICAgfSkpLnBpcGUocmFjZVdpdGgodGltZW91dChtcykpKSk7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gc3RyaW5nVG9UeXBlZEFycmF5KGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWF5YmVXcml0ZVR5cGVkQXJyYXlUb0ZpbGUocGF0aCwgdHlwZWRBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjcmVhdGVQREZTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IGF3YWl0IHRoaXMucGRmKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodHlwZWRBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgX3NjcmVlbnNob3Qob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgeyBjbGlwLCB0eXBlLCBjYXB0dXJlQmV5b25kVmlld3BvcnQsIHF1YWxpdHkgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbWl0QmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMub21pdEJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oYEJpRGkgZG9lcyBub3Qgc3VwcG9ydCAnb21pdEJhY2tncm91bmQnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3B0aW1pemVGb3JTcGVlZCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMub3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbihgQmlEaSBkb2VzIG5vdCBzdXBwb3J0ICdvcHRpbWl6ZUZvclNwZWVkJy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZyb21TdXJmYWNlICE9PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuZnJvbVN1cmZhY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oYEJpRGkgZG9lcyBub3Qgc3VwcG9ydCAnZnJvbVN1cmZhY2UnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaXAgIT09IHVuZGVmaW5lZCAmJiBjbGlwLnNjYWxlICE9PSB1bmRlZmluZWQgJiYgY2xpcC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbihgQmlEaSBkb2VzIG5vdCBzdXBwb3J0ICdzY2FsZScgaW4gJ2NsaXAnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJveDtcbiAgICAgICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVCZXlvbmRWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBib3ggPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNsaXAgaXMgYWx3YXlzIHdpdGggcmVzcGVjdCB0byB0aGUgZG9jdW1lbnQgY29vcmRpbmF0ZXMsIHNvIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY29udmVydCB0aGlzIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHdoZW4gd2UgYXJlbid0IGNhcHR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcGFnZUxlZnQsIHBhZ2VUb3BdID0gYXdhaXQgdGhpcy5ldmFsdWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy52aXN1YWxWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd2luZG93LnZpc3VhbFZpZXdwb3J0IGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5wYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQucGFnZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jbGlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY2xpcC54IC0gcGFnZUxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjbGlwLnkgLSBwYWdlVG9wLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuY2FwdHVyZVNjcmVlbnNob3Qoe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogY2FwdHVyZUJleW9uZFZpZXdwb3J0ID8gJ2RvY3VtZW50JyA6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGBpbWFnZS8ke3R5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHF1YWxpdHkgIT09IHVuZGVmaW5lZCA/IHsgcXVhbGl0eTogcXVhbGl0eSAvIDEwMCB9IDoge30pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uKGJveCA/IHsgY2xpcDogeyB0eXBlOiAnYm94JywgLi4uYm94IH0gfSA6IHt9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlQ0RQU2Vzc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmcmFtZS5jcmVhdGVDRFBTZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgYnJpbmdUb0Zyb250KCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZXZhbHVhdGVPbk5ld0RvY3VtZW50KHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV2YWx1YXRpb25FeHByZXNzaW9uKHBhZ2VGdW5jdGlvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuYWRkUHJlbG9hZFNjcmlwdChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7IGlkZW50aWZpZXI6IHNjcmlwdCB9O1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbW92ZVNjcmlwdFRvRXZhbHVhdGVPbk5ld0RvY3VtZW50KGlkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQucmVtb3ZlUHJlbG9hZFNjcmlwdChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZXhwb3NlRnVuY3Rpb24obmFtZSwgcHB0ckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tYWluRnJhbWUoKS5leHBvc2VGdW5jdGlvbihuYW1lLCAnZGVmYXVsdCcgaW4gcHB0ckZ1bmN0aW9uID8gcHB0ckZ1bmN0aW9uLmRlZmF1bHQgOiBwcHRyRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlzRHJhZ0ludGVyY2VwdGlvbkVuYWJsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Q2FjaGVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jYnJvd3NlckNvbnRleHQuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5zZXRDYWNoZUJlaGF2aW9yKGVuYWJsZWQgPyAnZGVmYXVsdCcgOiAnYnlwYXNzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIENEUC1zcGVjaWZpYyBjYXNlcyBzdWNoIGFzIG1wcmFjaC5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudCgpLnNlbmQoJ05ldHdvcmsuc2V0Q2FjaGVEaXNhYmxlZCcsIHtcbiAgICAgICAgICAgICAgICBjYWNoZURpc2FibGVkOiAhZW5hYmxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvb2tpZXMoLi4udXJscykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybHMgPSAodXJscy5sZW5ndGggPyB1cmxzIDogW3RoaXMudXJsKCldKS5tYXAodXJsID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LmdldENvb2tpZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVzXG4gICAgICAgICAgICAgICAgLm1hcChjb29raWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaWRpVG9QdXBwZXRlZXJDb29raWUoY29va2llKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjb29raWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkVXJscy5zb21lKHVybCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0VXJsTWF0Y2hDb29raWUoY29va2llLCB1cmwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTZXJ2aWNlV29ya2VyQnlwYXNzZWQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB3YWl0Rm9yRmlsZUNob29zZXIoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLiN3b3JrZXJzXTtcbiAgICAgICAgfVxuICAgICAgICAjdXNlckludGVyY2VwdGlvbjtcbiAgICAgICAgYXN5bmMgc2V0UmVxdWVzdEludGVyY2VwdGlvbihlbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuI3VzZXJJbnRlcmNlcHRpb24gPSBhd2FpdCB0aGlzLiN0b2dnbGVJbnRlcmNlcHRpb24oW1wiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBCaWRpLk5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi9dLCB0aGlzLiN1c2VySW50ZXJjZXB0aW9uLCBlbmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIF9leHRyYUhUVFBIZWFkZXJzID0ge307XG4gICAgICAgICNleHRyYUhlYWRlcnNJbnRlcmNlcHRpb247XG4gICAgICAgIGFzeW5jIHNldEV4dHJhSFRUUEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgZXh0cmFIVFRQSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoaXNTdHJpbmcodmFsdWUpLCBgRXhwZWN0ZWQgdmFsdWUgb2YgaGVhZGVyIFwiJHtrZXl9XCIgdG8gYmUgU3RyaW5nLCBidXQgXCIke3R5cGVvZiB2YWx1ZX1cIiBpcyBmb3VuZC5gKTtcbiAgICAgICAgICAgICAgICBleHRyYUhUVFBIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZXh0cmFIVFRQSGVhZGVycyA9IGV4dHJhSFRUUEhlYWRlcnM7XG4gICAgICAgICAgICB0aGlzLiNleHRyYUhlYWRlcnNJbnRlcmNlcHRpb24gPSBhd2FpdCB0aGlzLiN0b2dnbGVJbnRlcmNlcHRpb24oW1wiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBCaWRpLk5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi9dLCB0aGlzLiNleHRyYUhlYWRlcnNJbnRlcmNlcHRpb24sIEJvb2xlYW4oT2JqZWN0LmtleXModGhpcy5fZXh0cmFIVFRQSGVhZGVycykubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2NyZWRlbnRpYWxzID0gbnVsbDtcbiAgICAgICAgI2F1dGhJbnRlcmNlcHRpb247XG4gICAgICAgIGFzeW5jIGF1dGhlbnRpY2F0ZShjcmVkZW50aWFscykge1xuICAgICAgICAgICAgdGhpcy4jYXV0aEludGVyY2VwdGlvbiA9IGF3YWl0IHRoaXMuI3RvZ2dsZUludGVyY2VwdGlvbihbXCJhdXRoUmVxdWlyZWRcIiAvKiBCaWRpLk5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovXSwgdGhpcy4jYXV0aEludGVyY2VwdGlvbiwgQm9vbGVhbihjcmVkZW50aWFscykpO1xuICAgICAgICAgICAgdGhpcy5fY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICBhc3luYyAjdG9nZ2xlSW50ZXJjZXB0aW9uKHBoYXNlcywgaW50ZXJjZXB0aW9uLCBleHBlY3RlZCkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkICYmICFpbnRlcmNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LmFkZEludGVyY2VwdCh7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleHBlY3RlZCAmJiBpbnRlcmNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5yZW1vdmVJbnRlcmNlcHQoaW50ZXJjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJjZXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHNldERyYWdJbnRlcmNlcHRpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRCeXBhc3NTZXJ2aWNlV29ya2VyKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0T2ZmbGluZU1vZGUoZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNicm93c2VyQ29udGV4dC5icm93c2VyKCkuY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLm9mZmxpbmUgPSBlbmFibGVkO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2FwcGx5TmV0d29ya0NvbmRpdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlbXVsYXRlTmV0d29ya0NvbmRpdGlvbnMobmV0d29ya0NvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jYnJvd3NlckNvbnRleHQuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgbGF0ZW5jeTogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy51cGxvYWQgPSBuZXR3b3JrQ29uZGl0aW9uc1xuICAgICAgICAgICAgICAgID8gbmV0d29ya0NvbmRpdGlvbnMudXBsb2FkXG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMuZG93bmxvYWQgPSBuZXR3b3JrQ29uZGl0aW9uc1xuICAgICAgICAgICAgICAgID8gbmV0d29ya0NvbmRpdGlvbnMuZG93bmxvYWRcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5sYXRlbmN5ID0gbmV0d29ya0NvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICA/IG5ldHdvcmtDb25kaXRpb25zLmxhdGVuY3lcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYXBwbHlOZXR3b3JrQ29uZGl0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jICNhcHBseU5ldHdvcmtDb25kaXRpb25zKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50KCkuc2VuZCgnTmV0d29yay5lbXVsYXRlTmV0d29ya0NvbmRpdGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgb2ZmbGluZTogdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5vZmZsaW5lLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMubGF0ZW5jeSxcbiAgICAgICAgICAgICAgICB1cGxvYWRUaHJvdWdocHV0OiB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLnVwbG9hZCxcbiAgICAgICAgICAgICAgICBkb3dubG9hZFRocm91Z2hwdXQ6IHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMuZG93bmxvYWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRDb29raWUoLi4uY29va2llcykge1xuICAgICAgICAgICAgY29uc3QgcGFnZVVSTCA9IHRoaXMudXJsKCk7XG4gICAgICAgICAgICBjb25zdCBwYWdlVXJsU3RhcnRzV2l0aEhUVFAgPSBwYWdlVVJMLnN0YXJ0c1dpdGgoJ2h0dHAnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29va2llVXJsID0gY29va2llLnVybCB8fCAnJztcbiAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZVVybCAmJiBwYWdlVXJsU3RhcnRzV2l0aEhUVFApIHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llVXJsID0gcGFnZVVSTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNvb2tpZVVybCAhPT0gJ2Fib3V0OmJsYW5rJywgYEJsYW5rIHBhZ2UgY2FuIG5vdCBoYXZlIGNvb2tpZSBcIiR7Y29va2llLm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aC5jYWxsKGNvb2tpZVVybCB8fCAnJywgJ2RhdGE6JyksIGBEYXRhIFVSTCBwYWdlIGNhbiBub3QgaGF2ZSBjb29raWUgXCIke2Nvb2tpZS5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9IFVSTC5jYW5QYXJzZShjb29raWVVcmwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IFVSTChjb29raWVVcmwpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGNvb2tpZS5kb21haW4gPz8gbm9ybWFsaXplZFVybD8uaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGRvbWFpbiAhPT0gdW5kZWZpbmVkLCBgQXQgbGVhc3Qgb25lIG9mIHRoZSB1cmwgYW5kIGRvbWFpbiBuZWVkcyB0byBiZSBzcGVjaWZpZWRgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWRpQ29va2llID0ge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY29va2llLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb29raWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb29raWUucGF0aCAhPT0gdW5kZWZpbmVkID8geyBwYXRoOiBjb29raWUucGF0aCB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oY29va2llLmh0dHBPbmx5ICE9PSB1bmRlZmluZWQgPyB7IGh0dHBPbmx5OiBjb29raWUuaHR0cE9ubHkgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvb2tpZS5zZWN1cmUgIT09IHVuZGVmaW5lZCA/IHsgc2VjdXJlOiBjb29raWUuc2VjdXJlIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb29raWUuc2FtZVNpdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHNhbWVTaXRlOiBjb252ZXJ0Q29va2llc1NhbWVTaXRlQ2RwVG9CaURpKGNvb2tpZS5zYW1lU2l0ZSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb29raWUuZXhwaXJlcyAhPT0gdW5kZWZpbmVkID8geyBleHBpcnk6IGNvb2tpZS5leHBpcmVzIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIC8vIENocm9tZS1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAuLi5jZHBTcGVjaWZpY0Nvb2tpZVByb3BlcnRpZXNGcm9tUHVwcGV0ZWVyVG9CaWRpKGNvb2tpZSwgJ3NhbWVQYXJ0eScsICdzb3VyY2VTY2hlbWUnLCAncHJpb3JpdHknLCAndXJsJyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29va2llLnBhcnRpdGlvbktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYnJvd3NlckNvbnRleHQoKS51c2VyQ29udGV4dC5zZXRDb29raWUoYmlkaUNvb2tpZSwgY29va2llLnBhcnRpdGlvbktleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuc2V0Q29va2llKGJpZGlDb29raWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBkZWxldGVDb29raWUoLi4uY29va2llcykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29va2llcy5tYXAoYXN5bmMgKGRlbGV0ZUNvb2tpZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29raWVVcmwgPSBkZWxldGVDb29raWVSZXF1ZXN0LnVybCA/PyB0aGlzLnVybCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBVUkwuY2FuUGFyc2UoY29va2llVXJsKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBVUkwoY29va2llVXJsKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBkZWxldGVDb29raWVSZXF1ZXN0LmRvbWFpbiA/PyBub3JtYWxpemVkVXJsPy5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZG9tYWluICE9PSB1bmRlZmluZWQsIGBBdCBsZWFzdCBvbmUgb2YgdGhlIHVybCBhbmQgZG9tYWluIG5lZWRzIHRvIGJlIHNwZWNpZmllZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRlbGV0ZUNvb2tpZVJlcXVlc3QubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGRlbGV0ZUNvb2tpZVJlcXVlc3QucGF0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgcGF0aDogZGVsZXRlQ29va2llUmVxdWVzdC5wYXRoIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LmRlbGV0ZUNvb2tpZShmaWx0ZXIpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbW92ZUV4cG9zZWRGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5yZW1vdmVFeHBvc2VkRnVuY3Rpb24obmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0cmljcygpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGdvQmFjayhvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNnbygtMSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZ29Gb3J3YXJkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2dvKDEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jICNnbyhkZWx0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0Rm9yTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC50cmF2ZXJzZUhpc3RvcnkoZGVsdGEpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvckxpa2UoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdubyBzdWNoIGhpc3RvcnkgZW50cnknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2FpdEZvckRldmljZVByb21wdCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpUGFnZSB9O1xuZnVuY3Rpb24gZXZhbHVhdGlvbkV4cHJlc3Npb24oZnVuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGAoKSA9PiB7JHtldmFsdWF0aW9uU3RyaW5nKGZ1biwgLi4uYXJncyl9fWA7XG59XG4vKipcbiAqIENoZWNrIGRvbWFpbnMgbWF0Y2guXG4gKiBBY2NvcmRpbmcgdG8gY29va2llcyBzcGVjLCB0aGlzIGNoZWNrIHNob3VsZCBtYXRjaCBzdWJkb21haW5zIGFzIHdlbGwsIGJ1dCBDRFBcbiAqIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGRvIHRoYXQsIHNvIHRoaXMgbWV0aG9kIG1hdGNoZXMgb25seSB0aGUgZXhhY3QgZG9tYWlucywgbm90XG4gKiB3aGF0IGlzIHdyaXR0ZW4gaW4gdGhlIHNwZWM6XG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzYyNjUjc2VjdGlvbi01LjEuM1xuICovXG5mdW5jdGlvbiB0ZXN0VXJsTWF0Y2hDb29raWVIb3N0bmFtZShjb29raWUsIG5vcm1hbGl6ZWRVcmwpIHtcbiAgICBjb25zdCBjb29raWVEb21haW4gPSBjb29raWUuZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdXJsSG9zdG5hbWUgPSBub3JtYWxpemVkVXJsLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGNvb2tpZURvbWFpbiA9PT0gdXJsSG9zdG5hbWU7XG59XG4vKipcbiAqIENoZWNrIHBhdGhzIG1hdGNoLlxuICogU3BlYzogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MjY1I3NlY3Rpb24tNS4xLjRcbiAqL1xuZnVuY3Rpb24gdGVzdFVybE1hdGNoQ29va2llUGF0aChjb29raWUsIG5vcm1hbGl6ZWRVcmwpIHtcbiAgICBjb25zdCB1cmlQYXRoID0gbm9ybWFsaXplZFVybC5wYXRobmFtZTtcbiAgICBjb25zdCBjb29raWVQYXRoID0gY29va2llLnBhdGg7XG4gICAgaWYgKHVyaVBhdGggPT09IGNvb2tpZVBhdGgpIHtcbiAgICAgICAgLy8gVGhlIGNvb2tpZS1wYXRoIGFuZCB0aGUgcmVxdWVzdC1wYXRoIGFyZSBpZGVudGljYWwuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodXJpUGF0aC5zdGFydHNXaXRoKGNvb2tpZVBhdGgpKSB7XG4gICAgICAgIC8vIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLlxuICAgICAgICBpZiAoY29va2llUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmlQYXRoW2Nvb2tpZVBhdGgubGVuZ3RoXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSByZXF1ZXN0LXBhdGggdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGNvb2tpZS1wYXRoXG4gICAgICAgICAgICAvLyBpcyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrcyB0aGUgY29va2llIG1hdGNoZXMgdGhlIFVSTCBhY2NvcmRpbmcgdG8gdGhlIHNwZWM6XG4gKi9cbmZ1bmN0aW9uIHRlc3RVcmxNYXRjaENvb2tpZShjb29raWUsIHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgYXNzZXJ0KGNvb2tpZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAoIXRlc3RVcmxNYXRjaENvb2tpZUhvc3RuYW1lKGNvb2tpZSwgbm9ybWFsaXplZFVybCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGVzdFVybE1hdGNoQ29va2llUGF0aChjb29raWUsIG5vcm1hbGl6ZWRVcmwpO1xufVxuZnVuY3Rpb24gYmlkaVRvUHVwcGV0ZWVyQ29va2llKGJpZGlDb29raWUpIHtcbiAgICBjb25zdCBwYXJ0aXRpb25LZXkgPSBiaWRpQ29va2llW0NEUF9TUEVDSUZJQ19QUkVGSVggKyAncGFydGl0aW9uS2V5J107XG4gICAgZnVuY3Rpb24gZ2V0UGFyaXRpb25LZXkoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydGl0aW9uS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFydGl0aW9uS2V5IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aXRpb25LZXkgPT09ICdvYmplY3QnICYmIHBhcnRpdGlvbktleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhIGJyZWFraW5nIGNoYW5nZSBpbiBQdXBwZXRlZXIgaXMgcmVxdWlyZWQgdG8gY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gcGFydGl0aW9uS2V5IHR5cGUgYW5kIHJlcG9ydCB0aGUgY29tcG9zaXRlIHBhcnRpdGlvbiBrZXkuXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uS2V5OiBwYXJ0aXRpb25LZXkudG9wTGV2ZWxTaXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGJpZGlDb29raWUubmFtZSxcbiAgICAgICAgLy8gUHJlc2VudHMgYmluYXJ5IHZhbHVlIGFzIGJhc2U2NCBzdHJpbmcuXG4gICAgICAgIHZhbHVlOiBiaWRpQ29va2llLnZhbHVlLnZhbHVlLFxuICAgICAgICBkb21haW46IGJpZGlDb29raWUuZG9tYWluLFxuICAgICAgICBwYXRoOiBiaWRpQ29va2llLnBhdGgsXG4gICAgICAgIHNpemU6IGJpZGlDb29raWUuc2l6ZSxcbiAgICAgICAgaHR0cE9ubHk6IGJpZGlDb29raWUuaHR0cE9ubHksXG4gICAgICAgIHNlY3VyZTogYmlkaUNvb2tpZS5zZWN1cmUsXG4gICAgICAgIHNhbWVTaXRlOiBjb252ZXJ0Q29va2llc1NhbWVTaXRlQmlEaVRvQ2RwKGJpZGlDb29raWUuc2FtZVNpdGUpLFxuICAgICAgICBleHBpcmVzOiBiaWRpQ29va2llLmV4cGlyeSA/PyAtMSxcbiAgICAgICAgc2Vzc2lvbjogYmlkaUNvb2tpZS5leHBpcnkgPT09IHVuZGVmaW5lZCB8fCBiaWRpQ29va2llLmV4cGlyeSA8PSAwLFxuICAgICAgICAvLyBFeHRlbmRpbmcgd2l0aCBDRFAtc3BlY2lmaWMgcHJvcGVydGllcyB3aXRoIGBnb29nOmAgcHJlZml4LlxuICAgICAgICAuLi5jZHBTcGVjaWZpY0Nvb2tpZVByb3BlcnRpZXNGcm9tQmlkaVRvUHVwcGV0ZWVyKGJpZGlDb29raWUsICdzYW1lUGFydHknLCAnc291cmNlU2NoZW1lJywgJ3BhcnRpdGlvbktleU9wYXF1ZScsICdwcmlvcml0eScpLFxuICAgICAgICAuLi5nZXRQYXJpdGlvbktleSgpLFxuICAgIH07XG59XG5jb25zdCBDRFBfU1BFQ0lGSUNfUFJFRklYID0gJ2dvb2c6Jztcbi8qKlxuICogR2V0cyBDRFAtc3BlY2lmaWMgcHJvcGVydGllcyBmcm9tIHRoZSBCaURpIGNvb2tpZSBhbmQgcmV0dXJucyB0aGVtIGFzIGEgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2RwU3BlY2lmaWNDb29raWVQcm9wZXJ0aWVzRnJvbUJpZGlUb1B1cHBldGVlcihiaWRpQ29va2llLCAuLi5wcm9wZXJ0eU5hbWVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIGlmIChiaWRpQ29va2llW0NEUF9TUEVDSUZJQ19QUkVGSVggKyBwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGJpZGlDb29raWVbQ0RQX1NQRUNJRklDX1BSRUZJWCArIHByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBHZXRzIENEUC1zcGVjaWZpYyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvb2tpZSwgYWRkcyBDRFAtc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHJldHVybnNcbiAqIHRoZW0gYXMgYSBuZXcgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIEJpRGkuXG4gKi9cbmZ1bmN0aW9uIGNkcFNwZWNpZmljQ29va2llUHJvcGVydGllc0Zyb21QdXBwZXRlZXJUb0JpZGkoY29va2llUGFyYW0sIC4uLnByb3BlcnR5TmFtZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgaWYgKGNvb2tpZVBhcmFtW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRbQ0RQX1NQRUNJRklDX1BSRUZJWCArIHByb3BlcnR5XSA9IGNvb2tpZVBhcmFtW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29udmVydENvb2tpZXNTYW1lU2l0ZUJpRGlUb0NkcChzYW1lU2l0ZSkge1xuICAgIHJldHVybiBzYW1lU2l0ZSA9PT0gJ3N0cmljdCcgPyAnU3RyaWN0JyA6IHNhbWVTaXRlID09PSAnbGF4JyA/ICdMYXgnIDogJ05vbmUnO1xufVxuZnVuY3Rpb24gY29udmVydENvb2tpZXNTYW1lU2l0ZUNkcFRvQmlEaShzYW1lU2l0ZSkge1xuICAgIHJldHVybiBzYW1lU2l0ZSA9PT0gJ1N0cmljdCdcbiAgICAgICAgPyBcInN0cmljdFwiIC8qIEJpZGkuTmV0d29yay5TYW1lU2l0ZS5TdHJpY3QgKi9cbiAgICAgICAgOiBzYW1lU2l0ZSA9PT0gJ0xheCdcbiAgICAgICAgICAgID8gXCJsYXhcIiAvKiBCaWRpLk5ldHdvcmsuU2FtZVNpdGUuTGF4ICovXG4gICAgICAgICAgICA6IFwibm9uZVwiIC8qIEJpZGkuTmV0d29yay5TYW1lU2l0ZS5Ob25lICovO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFnZS5qcy5tYXAiLCJ2YXIgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UgPSAodGhpcyAmJiB0aGlzLl9fYWRkRGlzcG9zYWJsZVJlc291cmNlKSB8fCBmdW5jdGlvbiAoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICAgICAgdmFyIGRpc3Bvc2U7XG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3luYykge1xuICAgICAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fZGlzcG9zZVJlc291cmNlcyA9ICh0aGlzICYmIHRoaXMuX19kaXNwb3NlUmVzb3VyY2VzKSB8fCAoZnVuY3Rpb24gKFN1cHByZXNzZWRFcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgICAgICAgICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IFN1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgICAgICAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYy5kaXNwb3NlICYmIHJlYy5kaXNwb3NlLmNhbGwocmVjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYy5hc3luYykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9O1xufSkodHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn0pO1xuaW1wb3J0IHsgUmVhbG0gfSBmcm9tICcuLi9hcGkvUmVhbG0uanMnO1xuaW1wb3J0IHsgQVJJQVF1ZXJ5SGFuZGxlciB9IGZyb20gJy4uL2NkcC9BcmlhUXVlcnlIYW5kbGVyLmpzJztcbmltcG9ydCB7IExhenlBcmcgfSBmcm9tICcuLi9jb21tb24vTGF6eUFyZy5qcyc7XG5pbXBvcnQgeyBzY3JpcHRJbmplY3RvciB9IGZyb20gJy4uL2NvbW1vbi9TY3JpcHRJbmplY3Rvci5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yLCBnZXRTb3VyY2VQdXBwZXRlZXJVUkxJZkF2YWlsYWJsZSwgZ2V0U291cmNlVXJsQ29tbWVudCwgaXNTdHJpbmcsIFB1cHBldGVlclVSTCwgU09VUkNFX1VSTF9SRUdFWCwgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlVXRpbCB9IGZyb20gJy4uL3V0aWwvQXN5bmNJdGVyYWJsZVV0aWwuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5RnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLmpzJztcbmltcG9ydCB7IEJpZGlEZXNlcmlhbGl6ZXIgfSBmcm9tICcuL0Rlc2VyaWFsaXplci5qcyc7XG5pbXBvcnQgeyBCaWRpRWxlbWVudEhhbmRsZSB9IGZyb20gJy4vRWxlbWVudEhhbmRsZS5qcyc7XG5pbXBvcnQgeyBFeHBvc2VhYmxlRnVuY3Rpb24gfSBmcm9tICcuL0V4cG9zZWRGdW5jdGlvbi5qcyc7XG5pbXBvcnQgeyBCaWRpSlNIYW5kbGUgfSBmcm9tICcuL0pTSGFuZGxlLmpzJztcbmltcG9ydCB7IEJpZGlTZXJpYWxpemVyIH0gZnJvbSAnLi9TZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUV2YWx1YXRpb25FcnJvciB9IGZyb20gJy4vdXRpbC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVJlYWxtIGV4dGVuZHMgUmVhbG0ge1xuICAgIHJlYWxtO1xuICAgIGNvbnN0cnVjdG9yKHJlYWxtLCB0aW1lb3V0U2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIodGltZW91dFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5yZWFsbSA9IHJlYWxtO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnJlYWxtLm9uKCdkZXN0cm95ZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrTWFuYWdlci50ZXJtaW5hdGVBbGwobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWxtLm9uKCd1cGRhdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFB1cHBldGVlclV0aWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2b2lkIHRoaXMudGFza01hbmFnZXIucmVydW5BbGwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludGVybmFsUHVwcGV0ZWVyVXRpbDtcbiAgICBnZXQgcHVwcGV0ZWVyVXRpbCgpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBzY3JpcHRJbmplY3Rvci5pbmplY3Qoc2NyaXB0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbCkge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5pbnRlcm5hbFB1cHBldGVlclV0aWwudGhlbihoYW5kbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbCA9IHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVIYW5kbGUoc2NyaXB0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAhdGhpcy5pbnRlcm5hbFB1cHBldGVlclV0aWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFB1cHBldGVlclV0aWw7XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlSGFuZGxlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZXZhbHVhdGUoZmFsc2UsIHBhZ2VGdW5jdGlvbiwgLi4uYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZXZhbHVhdGUodHJ1ZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgI2V2YWx1YXRlKHJldHVybkJ5VmFsdWUsIHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzb3VyY2VVcmxDb21tZW50ID0gZ2V0U291cmNlVXJsQ29tbWVudChnZXRTb3VyY2VQdXBwZXRlZXJVUkxJZkF2YWlsYWJsZShwYWdlRnVuY3Rpb24pPy50b1N0cmluZygpID8/XG4gICAgICAgICAgICBQdXBwZXRlZXJVUkwuSU5URVJOQUxfVVJMKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0T3duZXJzaGlwID0gcmV0dXJuQnlWYWx1ZVxuICAgICAgICAgICAgPyBcIm5vbmVcIiAvKiBCaWRpLlNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqL1xuICAgICAgICAgICAgOiBcInJvb3RcIiAvKiBCaWRpLlNjcmlwdC5SZXN1bHRPd25lcnNoaXAuUm9vdCAqLztcbiAgICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbk9wdGlvbnMgPSByZXR1cm5CeVZhbHVlXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBtYXhPYmplY3REZXB0aDogMCxcbiAgICAgICAgICAgICAgICBtYXhEb21EZXB0aDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmIChpc1N0cmluZyhwYWdlRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gU09VUkNFX1VSTF9SRUdFWC50ZXN0KHBhZ2VGdW5jdGlvbilcbiAgICAgICAgICAgICAgICA/IHBhZ2VGdW5jdGlvblxuICAgICAgICAgICAgICAgIDogYCR7cGFnZUZ1bmN0aW9ufVxcbiR7c291cmNlVXJsQ29tbWVudH1cXG5gO1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5yZWFsbS5ldmFsdWF0ZShleHByZXNzaW9uLCB0cnVlLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T3duZXJzaGlwLFxuICAgICAgICAgICAgICAgIHVzZXJBY3RpdmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHN0cmluZ2lmeUZ1bmN0aW9uKHBhZ2VGdW5jdGlvbik7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uID0gU09VUkNFX1VSTF9SRUdFWC50ZXN0KGZ1bmN0aW9uRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbkRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgOiBgJHtmdW5jdGlvbkRlY2xhcmF0aW9ufVxcbiR7c291cmNlVXJsQ29tbWVudH1cXG5gO1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5yZWFsbS5jYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgXG4gICAgICAgICAgICAvKiBhd2FpdFByb21pc2U9ICovIHRydWUsIHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5QXJncyBhcmUgdXNlZCBvbmx5IGludGVybmFsbHkgYW5kIHNob3VsZCBub3QgYWZmZWN0IHRoZSBvcmRlclxuICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRlIGNhbGxzIGZvciB0aGUgcHVibGljIEFQSXMuXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLnNvbWUoYXJnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIExhenlBcmc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbChhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplQXN5bmMoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIDogYXJncy5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZShhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZXN1bHRPd25lcnNoaXAsXG4gICAgICAgICAgICAgICAgdXNlckFjdGl2YXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZVByb21pc2U7XG4gICAgICAgIGlmICgndHlwZScgaW4gcmVzdWx0ICYmIHJlc3VsdC50eXBlID09PSAnZXhjZXB0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXZhbHVhdGlvbkVycm9yKHJlc3VsdC5leGNlcHRpb25EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuQnlWYWx1ZVxuICAgICAgICAgICAgPyBCaWRpRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdC5yZXN1bHQpXG4gICAgICAgICAgICA6IHRoaXMuY3JlYXRlSGFuZGxlKHJlc3VsdC5yZXN1bHQpO1xuICAgIH1cbiAgICBjcmVhdGVIYW5kbGUocmVzdWx0KSB7XG4gICAgICAgIGlmICgocmVzdWx0LnR5cGUgPT09ICdub2RlJyB8fCByZXN1bHQudHlwZSA9PT0gJ3dpbmRvdycpICYmXG4gICAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgQmlkaUZyYW1lUmVhbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBCaWRpRWxlbWVudEhhbmRsZS5mcm9tKHJlc3VsdCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZGlKU0hhbmRsZS5mcm9tKHJlc3VsdCwgdGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlcmlhbGl6ZUFzeW5jKGFyZykge1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTGF6eUFyZykge1xuICAgICAgICAgICAgYXJnID0gYXdhaXQgYXJnLmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoYXJnKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQmlkaUpTSGFuZGxlIHx8IGFyZyBpbnN0YW5jZW9mIEJpZGlFbGVtZW50SGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoYXJnLnJlYWxtICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXJnLnJlYWxtIGluc3RhbmNlb2YgQmlkaUZyYW1lUmVhbG0pIHx8XG4gICAgICAgICAgICAgICAgICAgICEodGhpcyBpbnN0YW5jZW9mIEJpZGlGcmFtZVJlYWxtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZXZhbHVhdGUgSlNIYW5kbGUgZnJvbSBkaWZmZXJlbnQgZ2xvYmFsIHR5cGVzLiBVc3VhbGx5IHRoaXMgbWVhbnMgeW91J3JlIHVzaW5nIGEgaGFuZGxlIGZyb20gYSB3b3JrZXIgaW4gYSBwYWdlIG9yIHZpY2UgdmVyc2EuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnLnJlYWxtLmVudmlyb25tZW50ICE9PSB0aGlzLmVudmlyb25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBldmFsdWF0ZSBKU0hhbmRsZSBmcm9tIGRpZmZlcmVudCBmcmFtZXMuIFVzdWFsbHkgdGhpcyBtZWFucyB5b3UncmUgdXNpbmcgYSBoYW5kbGUgZnJvbSBhIHBhZ2Ugb24gYSBkaWZmZXJlbnQgcGFnZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNIYW5kbGUgaXMgZGlzcG9zZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnLnJlbW90ZVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZGlTZXJpYWxpemVyLnNlcmlhbGl6ZShhcmcpO1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95SGFuZGxlcyhoYW5kbGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlSWRzID0gaGFuZGxlc1xuICAgICAgICAgICAgLm1hcCgoeyBpZCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFuZGxlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVhbG0uZGlzb3duKGhhbmRsZUlkcykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBtaWdodCBoYXBwZW4gaW4gY2FzZSBvZiBhIHBhZ2UgYmVlbiBuYXZpZ2F0ZWQgb3IgY2xvc2VkLlxuICAgICAgICAgICAgLy8gU3dhbGxvdyB0aGVzZSBzaW5jZSB0aGV5IGFyZSBoYXJtbGVzcyBhbmQgd2UgZG9uJ3QgbGVhayBhbnl0aGluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFkb3B0SGFuZGxlKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZXZhbHVhdGVIYW5kbGUobm9kZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSwgaGFuZGxlKSk7XG4gICAgfVxuICAgIGFzeW5jIHRyYW5zZmVySGFuZGxlKGhhbmRsZSkge1xuICAgICAgICBpZiAoaGFuZGxlLnJlYWxtID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZmVycmVkSGFuZGxlID0gdGhpcy5hZG9wdEhhbmRsZShoYW5kbGUpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdHJhbnNmZXJyZWRIYW5kbGU7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlGcmFtZVJlYWxtIGV4dGVuZHMgQmlkaVJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShyZWFsbSwgZnJhbWUpIHtcbiAgICAgICAgY29uc3QgZnJhbWVSZWFsbSA9IG5ldyBCaWRpRnJhbWVSZWFsbShyZWFsbSwgZnJhbWUpO1xuICAgICAgICBmcmFtZVJlYWxtLiNpbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBmcmFtZVJlYWxtO1xuICAgIH1cbiAgICAjZnJhbWU7XG4gICAgY29uc3RydWN0b3IocmVhbG0sIGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKHJlYWxtLCBmcmFtZS50aW1lb3V0U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBydW4gZmlyc3QuXG4gICAgICAgIHRoaXMucmVhbG0ub24oJ3VwZGF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVudmlyb25tZW50LmNsZWFyRG9jdW1lbnRIYW5kbGUoKTtcbiAgICAgICAgICAgIHRoaXMuI2JpbmRpbmdzSW5zdGFsbGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYmluZGluZ3NJbnN0YWxsZWQgPSBmYWxzZTtcbiAgICBnZXQgcHVwcGV0ZWVyVXRpbCgpIHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLiNiaW5kaW5nc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBFeHBvc2VhYmxlRnVuY3Rpb24uZnJvbSh0aGlzLmVudmlyb25tZW50LCAnX19hcmlhUXVlcnlTZWxlY3RvcicsIEFSSUFRdWVyeUhhbmRsZXIucXVlcnlPbmUsICEhdGhpcy5zYW5kYm94KSxcbiAgICAgICAgICAgICAgICBFeHBvc2VhYmxlRnVuY3Rpb24uZnJvbSh0aGlzLmVudmlyb25tZW50LCAnX19hcmlhUXVlcnlTZWxlY3RvckFsbCcsIGFzeW5jIChlbGVtZW50LCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gQVJJQVF1ZXJ5SGFuZGxlci5xdWVyeUFsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBlbGVtZW50LnJlYWxtLmV2YWx1YXRlSGFuZGxlKCguLi5lbGVtZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB9LCAuLi4oYXdhaXQgQXN5bmNJdGVyYWJsZVV0aWwuY29sbGVjdChyZXN1bHRzKSkpO1xuICAgICAgICAgICAgICAgIH0sICEhdGhpcy5zYW5kYm94KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy4jYmluZGluZ3NJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnB1cHBldGVlclV0aWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc2FuZGJveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbG0uc2FuZGJveDtcbiAgICB9XG4gICAgZ2V0IGVudmlyb25tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWU7XG4gICAgfVxuICAgIGFzeW5jIGFkb3B0QmFja2VuZE5vZGUoYmFja2VuZE5vZGVJZCkge1xuICAgICAgICBjb25zdCBlbnZfMSA9IHsgc3RhY2s6IFtdLCBlcnJvcjogdm9pZCAwLCBoYXNFcnJvcjogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2JqZWN0IH0gPSBhd2FpdCB0aGlzLiNmcmFtZS5jbGllbnQuc2VuZCgnRE9NLnJlc29sdmVOb2RlJywge1xuICAgICAgICAgICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiBhd2FpdCB0aGlzLnJlYWxtLnJlc29sdmVFeGVjdXRpb25Db250ZXh0SWQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIEJpZGlFbGVtZW50SGFuZGxlLmZyb20oe1xuICAgICAgICAgICAgICAgIGhhbmRsZTogb2JqZWN0Lm9iamVjdElkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdub2RlJyxcbiAgICAgICAgICAgIH0sIHRoaXMpLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRoZSBzaGFyZWRJZCwgc28gd2UgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHRvIG9idGFpbiBpdC5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGUuZXZhbHVhdGVIYW5kbGUoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xKSB7XG4gICAgICAgICAgICBlbnZfMS5lcnJvciA9IGVfMTtcbiAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVdvcmtlclJlYWxtIGV4dGVuZHMgQmlkaVJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShyZWFsbSwgd29ya2VyKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlclJlYWxtID0gbmV3IEJpZGlXb3JrZXJSZWFsbShyZWFsbSwgd29ya2VyKTtcbiAgICAgICAgd29ya2VyUmVhbG0uaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gd29ya2VyUmVhbG07XG4gICAgfVxuICAgICN3b3JrZXI7XG4gICAgY29uc3RydWN0b3IocmVhbG0sIGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKHJlYWxtLCBmcmFtZS50aW1lb3V0U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLiN3b3JrZXIgPSBmcmFtZTtcbiAgICB9XG4gICAgZ2V0IGVudmlyb25tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd29ya2VyO1xuICAgIH1cbiAgICBhc3luYyBhZG9wdEJhY2tlbmROb2RlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZG9wdCBET00gbm9kZXMgaW50byBhIHdvcmtlci4nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsbS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgaXNEYXRlLCBpc1BsYWluT2JqZWN0LCBpc1JlZ0V4cCB9IGZyb20gJy4uL2NvbW1vbi91dGlsLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFVuc2VyaWFsaXphYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXJpYWxpemUoYXJnKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zZXJpYWxpemFibGVFcnJvcihgVW5hYmxlIHRvIHNlcmlhbGl6YWJsZSAke3R5cGVvZiBhcmd9YCk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemVPYmplY3QoYXJnKTtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6ZU51bWJlcihhcmcpO1xuICAgICAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmlnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgI3NlcmlhbGl6ZU51bWJlcihhcmcpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoT2JqZWN0LmlzKGFyZywgLTApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmlzKGFyZywgSW5maW5pdHkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJbmZpbml0eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmlzKGFyZywgLUluZmluaXR5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnLUluZmluaXR5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QuaXMoYXJnLCBOYU4pKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdOYU4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyAjc2VyaWFsaXplT2JqZWN0KGFyZykge1xuICAgICAgICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdudWxsJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcnJheSA9IGFyZy5tYXAoc3ViQXJnID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoc3ViQXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRBcnJheSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSAnIFJlY3Vyc2l2ZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZC4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE9iamVjdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT2JqZWN0LnB1c2goW3RoaXMuc2VyaWFsaXplKGtleSksIHRoaXMuc2VyaWFsaXplKGFyZ1trZXldKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkT2JqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWdleHAnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGFyZy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBhcmcuZmxhZ3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFVuc2VyaWFsaXphYmxlRXJyb3IoJ0N1c3RvbSBvYmplY3Qgc2VyaWFsaXphdGlvbiBub3QgcG9zc2libGUuIFVzZSBwbGFpbiBvYmplY3RzIGluc3RlYWQuJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VyaWFsaXplci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgVGFyZ2V0LCBUYXJnZXRUeXBlIH0gZnJvbSAnLi4vYXBpL1RhcmdldC5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgQmlkaVBhZ2UgfSBmcm9tICcuL1BhZ2UuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlCcm93c2VyVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAjYnJvd3NlcjtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXIgPSBicm93c2VyO1xuICAgIH1cbiAgICBhc1BhZ2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICB1cmwoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY3JlYXRlQ0RQU2Vzc2lvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUYXJnZXRUeXBlLkJST1dTRVI7XG4gICAgfVxuICAgIGJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyO1xuICAgIH1cbiAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXIuZGVmYXVsdEJyb3dzZXJDb250ZXh0KCk7XG4gICAgfVxuICAgIG9wZW5lcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlQYWdlVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAjcGFnZTtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI3BhZ2UgPSBwYWdlO1xuICAgIH1cbiAgICBhc3luYyBwYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICByZXR1cm4gQmlkaVBhZ2UuZnJvbSh0aGlzLmJyb3dzZXJDb250ZXh0KCksIHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0KTtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZS51cmwoKTtcbiAgICB9XG4gICAgY3JlYXRlQ0RQU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhZ2UuY3JlYXRlQ0RQU2Vzc2lvbigpO1xuICAgIH1cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0VHlwZS5QQUdFO1xuICAgIH1cbiAgICBicm93c2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyQ29udGV4dCgpLmJyb3dzZXIoKTtcbiAgICB9XG4gICAgYnJvd3NlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYWdlLmJyb3dzZXJDb250ZXh0KCk7XG4gICAgfVxuICAgIG9wZW5lcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlGcmFtZVRhcmdldCBleHRlbmRzIFRhcmdldCB7XG4gICAgI2ZyYW1lO1xuICAgICNwYWdlO1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gZnJhbWU7XG4gICAgfVxuICAgIGFzeW5jIHBhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3BhZ2UgPSBCaWRpUGFnZS5mcm9tKHRoaXMuYnJvd3NlckNvbnRleHQoKSwgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICByZXR1cm4gQmlkaVBhZ2UuZnJvbSh0aGlzLmJyb3dzZXJDb250ZXh0KCksIHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dCk7XG4gICAgfVxuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lLnVybCgpO1xuICAgIH1cbiAgICBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUuY3JlYXRlQ0RQU2Vzc2lvbigpO1xuICAgIH1cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0VHlwZS5QQUdFO1xuICAgIH1cbiAgICBicm93c2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyQ29udGV4dCgpLmJyb3dzZXIoKTtcbiAgICB9XG4gICAgYnJvd3NlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZS5wYWdlKCkuYnJvd3NlckNvbnRleHQoKTtcbiAgICB9XG4gICAgb3BlbmVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVdvcmtlclRhcmdldCBleHRlbmRzIFRhcmdldCB7XG4gICAgI3dvcmtlcjtcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jd29ya2VyID0gd29ya2VyO1xuICAgIH1cbiAgICBhc3luYyBwYWdlKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd29ya2VyLnVybCgpO1xuICAgIH1cbiAgICBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldFR5cGUuT1RIRVI7XG4gICAgfVxuICAgIGJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb3dzZXJDb250ZXh0KCkuYnJvd3NlcigpO1xuICAgIH1cbiAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dvcmtlci5mcmFtZS5wYWdlKCkuYnJvd3NlckNvbnRleHQoKTtcbiAgICB9XG4gICAgb3BlbmVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYXJnZXQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IFdlYldvcmtlciB9IGZyb20gJy4uL2FwaS9XZWJXb3JrZXIuanMnO1xuaW1wb3J0IHsgVW5zdXBwb3J0ZWRPcGVyYXRpb24gfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IEJpZGlXb3JrZXJSZWFsbSB9IGZyb20gJy4vUmVhbG0uanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlXZWJXb3JrZXIgZXh0ZW5kcyBXZWJXb3JrZXIge1xuICAgIHN0YXRpYyBmcm9tKGZyYW1lLCByZWFsbSkge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgQmlkaVdlYldvcmtlcihmcmFtZSwgcmVhbG0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cbiAgICAjZnJhbWU7XG4gICAgI3JlYWxtO1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lLCByZWFsbSkge1xuICAgICAgICBzdXBlcihyZWFsbS5vcmlnaW4pO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLiNyZWFsbSA9IEJpZGlXb3JrZXJSZWFsbS5mcm9tKHJlYWxtLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWU7XG4gICAgfVxuICAgIG1haW5SZWFsbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxtO1xuICAgIH1cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJXb3JrZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vQmlkaU92ZXJDZHAuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Ccm93c2VyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQnJvd3NlckNvbnRleHQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db25uZWN0aW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vRWxlbWVudEhhbmRsZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0ZyYW1lLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vSFRUUFJlcXVlc3QuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9IVFRQUmVzcG9uc2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9JbnB1dC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0pTSGFuZGxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vUGFnZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1JlYWxtLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZGkuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGluZXJ0SWZEaXNwb3NlZCwgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgeyBTaGFyZWRXb3JrZXJSZWFsbSB9IGZyb20gJy4vUmVhbG0uanMnO1xuaW1wb3J0IHsgVXNlckNvbnRleHQgfSBmcm9tICcuL1VzZXJDb250ZXh0LmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmxldCBCcm93c2VyID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jbG9zZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfYWRkUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzO1xuICAgIGxldCBfcmVtb3ZlSW50ZXJjZXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9jcmVhdGVVc2VyQ29udGV4dF9kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBCcm93c2VyIGV4dGVuZHMgX2NsYXNzU3VwZXIge1xuICAgICAgICBzdGF0aWMge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUoX2NsYXNzU3VwZXJbU3ltYm9sLm1ldGFkYXRhXSA/PyBudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZGlzcG9zZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZGlzcG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiZGlzcG9zZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmRpc3Bvc2UgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Nsb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjbG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY2xvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jbG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWRkUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYWRkUHJlbG9hZFNjcmlwdFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiYWRkUHJlbG9hZFNjcmlwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFkZFByZWxvYWRTY3JpcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbW92ZUludGVyY2VwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicmVtb3ZlSW50ZXJjZXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJyZW1vdmVJbnRlcmNlcHRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZW1vdmVJbnRlcmNlcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbW92ZVByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbW92ZVByZWxvYWRTY3JpcHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInJlbW92ZVByZWxvYWRTY3JpcHRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZW1vdmVQcmVsb2FkU2NyaXB0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jcmVhdGVVc2VyQ29udGV4dF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY3JlYXRlVXNlckNvbnRleHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNyZWF0ZVVzZXJDb250ZXh0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY3JlYXRlVXNlckNvbnRleHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzeW5jIGZyb20oc2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKHNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgI2Nsb3NlZCA9IChfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyksIGZhbHNlKTtcbiAgICAgICAgI3JlYXNvbjtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjdXNlckNvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgICAgICBzZXNzaW9uO1xuICAgICAgICAjc2hhcmVkV29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3RydWN0b3Ioc2Vzc2lvbikge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub25jZSgnZW5kZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignc2NyaXB0LnJlYWxtQ3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdzaGFyZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3NoYXJlZFdvcmtlcnMuc2V0KGluZm8ucmVhbG0sIFNoYXJlZFdvcmtlclJlYWxtLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc3luY1VzZXJDb250ZXh0cygpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc3luY0Jyb3dzaW5nQ29udGV4dHMoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyAjc3luY1VzZXJDb250ZXh0cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IHVzZXJDb250ZXh0cyB9LCB9ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ2Jyb3dzZXIuZ2V0VXNlckNvbnRleHRzJywge30pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIHVzZXJDb250ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NyZWF0ZVVzZXJDb250ZXh0KGNvbnRleHQudXNlckNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jICNzeW5jQnJvd3NpbmdDb250ZXh0cygpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgY29udGV4dHMgYXJlIGNyZWF0ZWQgb3IgZGVzdHJveWVkIGR1cmluZyBgZ2V0VHJlZWAsIHdlIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyBzZXQgdG8gZGV0ZWN0IHRoZW0uXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0SWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHRzO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIG5ldyBFdmVudEVtaXR0ZXIodGhpcy5zZXNzaW9uKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmNvbnRleHRDcmVhdGVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0SWRzLmFkZChpbmZvLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuZ2V0VHJlZScsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dHMgPSByZXN1bHQuY29udGV4dHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW52XzEuZXJyb3IgPSBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2ltdWxhdGluZyBldmVudHMgc28gY29udGV4dHMgYXJlIGNyZWF0ZWQgbmF0dXJhbGx5LlxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIGNvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0SWRzLmhhcyhpbmZvLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5lbWl0KCdicm93c2luZ0NvbnRleHQuY29udGV4dENyZWF0ZWQnLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dHMucHVzaCguLi5pbmZvLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI2NyZWF0ZVVzZXJDb250ZXh0KGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29udGV4dCA9IFVzZXJDb250ZXh0LmNyZWF0ZSh0aGlzLCBpZCk7XG4gICAgICAgICAgICB0aGlzLiN1c2VyQ29udGV4dHMuc2V0KHVzZXJDb250ZXh0LmlkLCB1c2VyQ29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih1c2VyQ29udGV4dCkpO1xuICAgICAgICAgICAgdXNlckNvbnRleHRFbWl0dGVyLm9uY2UoJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB1c2VyQ29udGV4dEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jdXNlckNvbnRleHRzLmRlbGV0ZSh1c2VyQ29udGV4dC5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Nsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVmYXVsdFVzZXJDb250ZXh0KCkge1xuICAgICAgICAgICAgLy8gU0FGRVRZOiBBIFVzZXJDb250ZXh0IGlzIGFsd2F5cyBjcmVhdGVkIGZvciB0aGUgZGVmYXVsdCBjb250ZXh0LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3VzZXJDb250ZXh0cy5nZXQoVXNlckNvbnRleHQuREVGQVVMVCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFzb24gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHVzZXJDb250ZXh0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN1c2VyQ29udGV4dHMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24sIGNsb3NlZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLiNjbG9zZWQgPSBjbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdicm93c2VyLmNsb3NlJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCdCcm93c2VyIGFscmVhZHkgY2xvc2VkLicsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyBzY3JpcHQgfSwgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuYWRkUHJlbG9hZFNjcmlwdCcsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IG9wdGlvbnMuY29udGV4dHM/Lm1hcChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuaWQ7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlSW50ZXJjZXB0KGludGVyY2VwdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ25ldHdvcmsucmVtb3ZlSW50ZXJjZXB0Jywge1xuICAgICAgICAgICAgICAgIGludGVyY2VwdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbW92ZVByZWxvYWRTY3JpcHQoc2NyaXB0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZCgnc2NyaXB0LnJlbW92ZVByZWxvYWRTY3JpcHQnLCB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlckNvbnRleHQoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyB1c2VyQ29udGV4dDogY29udGV4dCB9LCB9ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ2Jyb3dzZXIuY3JlYXRlVXNlckNvbnRleHQnLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY3JlYXRlVXNlckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9jbG9zZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChicm93c2VyID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IEJ5IGRlZmluaXRpb24gb2YgYGRpc3Bvc2VkYCwgYCNyZWFzb25gIGlzIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXIuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2FkZFByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVJbnRlcmNlcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGJyb3dzZXIgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlci4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY3JlYXRlVXNlckNvbnRleHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIGRpc3Bvc2VTeW1ib2wpXSgpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA/Pz1cbiAgICAgICAgICAgICAgICAnQnJvd3NlciB3YXMgZGlzY29ubmVjdGVkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBzZXNzaW9uIGVuZGVkLic7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCcm93c2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGluZXJ0SWZEaXNwb3NlZCwgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uIH0gZnJvbSAnLi9OYXZpZ2F0aW9uLmpzJztcbmltcG9ydCB7IFdpbmRvd1JlYWxtIH0gZnJvbSAnLi9SZWFsbS5qcyc7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSAnLi9SZXF1ZXN0LmpzJztcbmltcG9ydCB7IFVzZXJQcm9tcHQgfSBmcm9tICcuL1VzZXJQcm9tcHQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJyb3dzaW5nQ29udGV4dCA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICBsZXQgX2FjdGl2YXRlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jYXB0dXJlU2NyZWVuc2hvdF9kZWNvcmF0b3JzO1xuICAgIGxldCBfY2xvc2VfZGVjb3JhdG9ycztcbiAgICBsZXQgX3RyYXZlcnNlSGlzdG9yeV9kZWNvcmF0b3JzO1xuICAgIGxldCBfbmF2aWdhdGVfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbG9hZF9kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0Q2FjaGVCZWhhdmlvcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfcHJpbnRfZGVjb3JhdG9ycztcbiAgICBsZXQgX2hhbmRsZVVzZXJQcm9tcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3NldFZpZXdwb3J0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9wZXJmb3JtQWN0aW9uc19kZWNvcmF0b3JzO1xuICAgIGxldCBfcmVsZWFzZUFjdGlvbnNfZGVjb3JhdG9ycztcbiAgICBsZXQgX2NyZWF0ZVdpbmRvd1JlYWxtX2RlY29yYXRvcnM7XG4gICAgbGV0IF9hZGRQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9hZGRJbnRlcmNlcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbW92ZVByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX2dldENvb2tpZXNfZGVjb3JhdG9ycztcbiAgICBsZXQgX3NldENvb2tpZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0RmlsZXNfZGVjb3JhdG9ycztcbiAgICBsZXQgX3N1YnNjcmliZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfYWRkSW50ZXJjZXB0aW9uX2RlY29yYXRvcnM7XG4gICAgbGV0IF9kZWxldGVDb29raWVfZGVjb3JhdG9ycztcbiAgICBsZXQgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnM7XG4gICAgcmV0dXJuIGNsYXNzIEJyb3dzaW5nQ29udGV4dCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfZGVsZXRlQ29va2llX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9kaXNwb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNwb3NlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkaXNwb3NlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZGlzcG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWN0aXZhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImFjdGl2YXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhY3RpdmF0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFjdGl2YXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jYXB0dXJlU2NyZWVuc2hvdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY2FwdHVyZVNjcmVlbnNob3RcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNhcHR1cmVTY3JlZW5zaG90XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY2FwdHVyZVNjcmVlbnNob3QgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Nsb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjbG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY2xvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jbG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfdHJhdmVyc2VIaXN0b3J5X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJ0cmF2ZXJzZUhpc3RvcnlcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInRyYXZlcnNlSGlzdG9yeVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnRyYXZlcnNlSGlzdG9yeSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfbmF2aWdhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcIm5hdmlnYXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJuYXZpZ2F0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLm5hdmlnYXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZWxvYWRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbG9hZFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVsb2FkXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVsb2FkIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRDYWNoZUJlaGF2aW9yX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZXRDYWNoZUJlaGF2aW9yXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRDYWNoZUJlaGF2aW9yXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0Q2FjaGVCZWhhdmlvciB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfcHJpbnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInByaW50XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJwcmludFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnByaW50IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9oYW5kbGVVc2VyUHJvbXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJoYW5kbGVVc2VyUHJvbXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJoYW5kbGVVc2VyUHJvbXB0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouaGFuZGxlVXNlclByb21wdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0Vmlld3BvcnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldFZpZXdwb3J0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRWaWV3cG9ydFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldFZpZXdwb3J0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9wZXJmb3JtQWN0aW9uc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicGVyZm9ybUFjdGlvbnNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInBlcmZvcm1BY3Rpb25zXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucGVyZm9ybUFjdGlvbnMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbGVhc2VBY3Rpb25zX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJyZWxlYXNlQWN0aW9uc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVsZWFzZUFjdGlvbnNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZWxlYXNlQWN0aW9ucyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfY3JlYXRlV2luZG93UmVhbG1fZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImNyZWF0ZVdpbmRvd1JlYWxtXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJjcmVhdGVXaW5kb3dSZWFsbVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmNyZWF0ZVdpbmRvd1JlYWxtIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9hZGRQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJhZGRQcmVsb2FkU2NyaXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhZGRQcmVsb2FkU2NyaXB0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouYWRkUHJlbG9hZFNjcmlwdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWRkSW50ZXJjZXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJhZGRJbnRlcmNlcHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImFkZEludGVyY2VwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFkZEludGVyY2VwdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfcmVtb3ZlUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicmVtb3ZlUHJlbG9hZFNjcmlwdFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVtb3ZlUHJlbG9hZFNjcmlwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnJlbW92ZVByZWxvYWRTY3JpcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2dldENvb2tpZXNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImdldENvb2tpZXNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImdldENvb2tpZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5nZXRDb29raWVzIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRDb29raWVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldENvb2tpZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwic2V0Q29va2llXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0Q29va2llIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRGaWxlc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic2V0RmlsZXNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldEZpbGVzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0RmlsZXMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3N1YnNjcmliZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic3Vic2NyaWJlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzdWJzY3JpYmVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5zdWJzY3JpYmUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2FkZEludGVyY2VwdGlvbl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYWRkSW50ZXJjZXB0aW9uXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhZGRJbnRlcmNlcHRpb25cIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5hZGRJbnRlcmNlcHRpb24gfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2RlbGV0ZUNvb2tpZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZGVsZXRlQ29va2llXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkZWxldGVDb29raWVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kZWxldGVDb29raWUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJsb2NhdGVOb2Rlc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwibG9jYXRlTm9kZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5sb2NhdGVOb2RlcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbSh1c2VyQ29udGV4dCwgcGFyZW50LCBpZCwgdXJsLCBvcmlnaW5hbE9wZW5lcikge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0ID0gbmV3IEJyb3dzaW5nQ29udGV4dCh1c2VyQ29udGV4dCwgcGFyZW50LCBpZCwgdXJsLCBvcmlnaW5hbE9wZW5lcik7XG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2luZ0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgI25hdmlnYXRpb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNyZWFzb247XG4gICAgICAgICN1cmw7XG4gICAgICAgICNjaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjcmVhbG1zID0gbmV3IE1hcCgpO1xuICAgICAgICAjcmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGRlZmF1bHRSZWFsbTtcbiAgICAgICAgaWQ7XG4gICAgICAgIHBhcmVudDtcbiAgICAgICAgdXNlckNvbnRleHQ7XG4gICAgICAgIG9yaWdpbmFsT3BlbmVyO1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwYXJlbnQsIGlkLCB1cmwsIG9yaWdpbmFsT3BlbmVyKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxPcGVuZXIgPSBvcmlnaW5hbE9wZW5lcjtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFJlYWxtID0gdGhpcy4jY3JlYXRlV2luZG93UmVhbG0oKTtcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMudXNlckNvbnRleHQpKTtcbiAgICAgICAgICAgIHVzZXJDb250ZXh0RW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShgQnJvd3NpbmcgY29udGV4dCBhbHJlYWR5IGNsb3NlZDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy4jc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC5jb250ZXh0Q3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBhcmVudCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dCA9IEJyb3dzaW5nQ29udGV4dC5mcm9tKHRoaXMudXNlckNvbnRleHQsIHRoaXMsIGluZm8uY29udGV4dCwgaW5mby51cmwsIGluZm8ub3JpZ2luYWxPcGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2NoaWxkcmVuLnNldChpbmZvLmNvbnRleHQsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKGJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIub25jZSgnY2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGlsZHJlbi5kZWxldGUoYnJvd3NpbmdDb250ZXh0LmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jyb3dzaW5nY29udGV4dCcsIHsgYnJvd3NpbmdDb250ZXh0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmNvbnRleHREZXN0cm95ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCdCcm93c2luZyBjb250ZXh0IGFscmVhZHkgY2xvc2VkLicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmRvbUNvbnRlbnRMb2FkZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jdXJsID0gaW5mby51cmw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdET01Db250ZW50TG9hZGVkJywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC5sb2FkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3VybCA9IGluZm8udXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZCcsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdicm93c2luZ0NvbnRleHQubmF2aWdhdGlvblN0YXJ0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkIG5vdCB1cGRhdGUgdGhpcy4jdXJsIGF0IHRoaXMgcG9pbnQgc2luY2UgdGhlIGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyBoYXMgbm90IGZpbmlzaGVkIG5hdmlnYXRpbmcgdG8gdGhlIGluZm8udXJsIHlldC5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgcmVxdWVzdF0gb2YgdGhpcy4jcmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gaGFzbid0IGZpbmlzaGVkLCB0aGVuIHRoaXMgaXMgbmVzdGVkIG5hdmlnYXRpb24uIFRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbmF2aWdhdGlvbiB3aWxsIGhhbmRsZSB0aGlzLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuYXZpZ2F0aW9uICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuI25hdmlnYXRpb24uZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoZSBuYXZpZ2F0aW9uIElEIGlzIG51bGwgZm9yIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiA9IE5hdmlnYXRpb24uZnJvbSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI25hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBbJ2ZyYWdtZW50JywgJ2ZhaWxlZCcsICdhYm9ydGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkVtaXR0ZXIub25jZShldmVudE5hbWUsICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRW1pdHRlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCduYXZpZ2F0aW9uJywgeyBuYXZpZ2F0aW9uOiB0aGlzLiNuYXZpZ2F0aW9uIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5iZWZvcmVSZXF1ZXN0U2VudCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNyZXF1ZXN0cy5oYXMoZXZlbnQucmVxdWVzdC5yZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZWFucyB0aGUgcmVxdWVzdCBpcyBhIHJlZGlyZWN0LiBUaGlzIGlzIGhhbmRsZWQgaW4gUmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3IgYW4gQXV0aCBldmVudCB3YXMgaXNzdWVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IFJlcXVlc3QuZnJvbSh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdHMuc2V0KHJlcXVlc3QuaWQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHsgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2xvZy5lbnRyeUFkZGVkJywgZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zb3VyY2UuY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9nJywgeyBlbnRyeSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC51c2VyUHJvbXB0T3BlbmVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBVc2VyUHJvbXB0LmZyb20odGhpcywgaW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1c2VycHJvbXB0JywgeyB1c2VyUHJvbXB0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNzZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjaGlsZHJlbi52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYXNvbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVhbG1zKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzIC0tIFJlcXVpcmVkXG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBzZWxmLmRlZmF1bHRSZWFsbTtcbiAgICAgICAgICAgICAgICB5aWVsZCogc2VsZi4jcmVhbG1zLnZhbHVlcygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgdG9wKCkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBwYXJlbnQgfSA9IGNvbnRleHQ7IHBhcmVudDsgeyBwYXJlbnQgfSA9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN1cmw7XG4gICAgICAgIH1cbiAgICAgICAgI2NyZWF0ZVdpbmRvd1JlYWxtKHNhbmRib3gpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gV2luZG93UmVhbG0uZnJvbSh0aGlzLCBzYW5kYm94KTtcbiAgICAgICAgICAgIHJlYWxtLm9uKCd3b3JrZXInLCByZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd3b3JrZXInLCB7IHJlYWxtIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmFjdGl2YXRlJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjYXB0dXJlU2NyZWVuc2hvdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGRhdGEgfSwgfSA9IGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmNhcHR1cmVTY3JlZW5zaG90Jywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UocHJvbXB0VW5sb2FkKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbLi4udGhpcy4jY2hpbGRyZW4udmFsdWVzKCldLm1hcChhc3luYyAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGlsZC5jbG9zZShwcm9tcHRVbmxvYWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuY2xvc2UnLCB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBwcm9tcHRVbmxvYWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB0cmF2ZXJzZUhpc3RvcnkoZGVsdGEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LnRyYXZlcnNlSGlzdG9yeScsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgbmF2aWdhdGUodXJsLCB3YWl0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0ZScsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVsb2FkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQucmVsb2FkJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENhY2hlQmVoYXZpb3IoY2FjaGVCZWhhdmlvcikge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgaW4gQmlEaSB0eXBlcyB5ZXQuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ25ldHdvcmsuc2V0Q2FjaGVCZWhhdmlvcicsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0czogW3RoaXMuaWRdLFxuICAgICAgICAgICAgICAgIGNhY2hlQmVoYXZpb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwcmludChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGRhdGEgfSwgfSA9IGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LnByaW50Jywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgaGFuZGxlVXNlclByb21wdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmhhbmRsZVVzZXJQcm9tcHQnLCB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Vmlld3BvcnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5zZXRWaWV3cG9ydCcsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwZXJmb3JtQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2lucHV0LnBlcmZvcm1BY3Rpb25zJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbGVhc2VBY3Rpb25zKCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdpbnB1dC5yZWxlYXNlQWN0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlV2luZG93UmVhbG0oc2FuZGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWF0ZVdpbmRvd1JlYWxtKHNhbmRib3gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyQ29udGV4dC5icm93c2VyLmFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IFt0aGlzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZEludGVyY2VwdChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyBpbnRlcmNlcHQgfSwgfSA9IGF3YWl0IHRoaXMudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uLnNlbmQoJ25ldHdvcmsuYWRkSW50ZXJjZXB0Jywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IFt0aGlzLmlkXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyByZW1vdmVQcmVsb2FkU2NyaXB0KHNjcmlwdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyQ29udGV4dC5icm93c2VyLnJlbW92ZVByZWxvYWRTY3JpcHQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXRDb29raWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQ6IHsgY29va2llcyB9LCB9ID0gYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdzdG9yYWdlLmdldENvb2tpZXMnLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVzO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENvb2tpZShjb29raWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnc3RvcmFnZS5zZXRDb29raWUnLCB7XG4gICAgICAgICAgICAgICAgY29va2llLFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29udGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldEZpbGVzKGVsZW1lbnQsIGZpbGVzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2lucHV0LnNldEZpbGVzJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBmaWxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHN1YnNjcmliZShldmVudHMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc3Vic2NyaWJlKGV2ZW50cywgW3RoaXMuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhZGRJbnRlcmNlcHRpb24oZXZlbnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnN1YnNjcmliZShldmVudHMsIFt0aGlzLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9hY3RpdmF0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2NhcHR1cmVTY3JlZW5zaG90X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY2xvc2VfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF90cmF2ZXJzZUhpc3RvcnlfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9uYXZpZ2F0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3JlbG9hZF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldENhY2hlQmVoYXZpb3JfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9wcmludF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2hhbmRsZVVzZXJQcm9tcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9zZXRWaWV3cG9ydF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3BlcmZvcm1BY3Rpb25zX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfcmVsZWFzZUFjdGlvbnNfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9jcmVhdGVXaW5kb3dSZWFsbV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2FkZFByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9hZGRJbnRlcmNlcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfZ2V0Q29va2llc19kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldENvb2tpZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldEZpbGVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfc3Vic2NyaWJlX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfYWRkSW50ZXJjZXB0aW9uX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ0Jyb3dzaW5nIGNvbnRleHQgYWxyZWFkeSBjbG9zZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIHVzZXIgY29udGV4dCBjbG9zZWQuJztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJywgeyByZWFzb246IHRoaXMuI3JlYXNvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHN1cGVyW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGVsZXRlQ29va2llKC4uLmNvb2tpZUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNvb2tpZUZpbHRlcnMubWFwKGFzeW5jIChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ3N0b3JhZ2UuZGVsZXRlQ29va2llcycsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBsb2NhdGVOb2Rlcyhsb2NhdG9yLCBzdGFydE5vZGVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgb3RoZXIgbG9jYXRlTm9kZXMgb3B0aW9ucyBpZiBuZWVkZWQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5sb2NhdGVOb2RlcycsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGxvY2F0b3IsXG4gICAgICAgICAgICAgICAgc3RhcnROb2Rlczogc3RhcnROb2Rlcy5sZW5ndGggPyBzdGFydE5vZGVzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdC5ub2RlcztcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQnJvd3NpbmdDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2luZ0NvbnRleHQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgaW5lcnRJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgTmF2aWdhdGlvbiA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb24gPSBuZXcgTmF2aWdhdGlvbihjb250ZXh0KTtcbiAgICAgICAgICAgIG5hdmlnYXRpb24uI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgICNyZXF1ZXN0ID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAjbmF2aWdhdGlvbjtcbiAgICAgICAgI2Jyb3dzaW5nQ29udGV4dDtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjaWQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI2Jyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0RW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy4jYnJvd3NpbmdDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLm9uKCdyZXF1ZXN0JywgKHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubmF2aWdhdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcmVxdWVzdCB3aXRoIGEgbmF2aWdhdGlvbiBJRCBjb21lcyBpbiwgdGhlbiB0aGUgbmF2aWdhdGlvbiBJRCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhpcyBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy4jbWF0Y2hlcyhyZXF1ZXN0Lm5hdmlnYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNyZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEVtaXR0ZXIub24oJ3JlZGlyZWN0JywgcmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI3Nlc3Npb24pKTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdicm93c2luZ0NvbnRleHQubmF2aWdhdGlvblN0YXJ0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiA9IE5hdmlnYXRpb24uZnJvbSh0aGlzLiNicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBbXG4gICAgICAgICAgICAgICAgJ2Jyb3dzaW5nQ29udGV4dC5kb21Db250ZW50TG9hZGVkJyxcbiAgICAgICAgICAgICAgICAnYnJvd3NpbmdDb250ZXh0LmxvYWQnLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKGV2ZW50TmFtZSwgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNvbnRleHQgIT09IHRoaXMuI2Jyb3dzaW5nQ29udGV4dC5pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5uYXZpZ2F0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy4jbWF0Y2hlcyhpbmZvLm5hdmlnYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudE5hbWUsIGV2ZW50XSBvZiBbXG4gICAgICAgICAgICAgICAgWydicm93c2luZ0NvbnRleHQuZnJhZ21lbnROYXZpZ2F0ZWQnLCAnZnJhZ21lbnQnXSxcbiAgICAgICAgICAgICAgICBbJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uRmFpbGVkJywgJ2ZhaWxlZCddLFxuICAgICAgICAgICAgICAgIFsnYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25BYm9ydGVkJywgJ2Fib3J0ZWQnXSxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbihldmVudE5hbWUsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgd2UgZG9uJ3QgY2hlY2sgaWYgYG5hdmlnYXRpb25gIGlzIG51bGwgc2luY2UgYG51bGxgIG1lYW5zIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgbmF2aWdhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuI21hdGNoZXMoaW5mby5uYXZpZ2F0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBpbmZvLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoaW5mby50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI21hdGNoZXMobmF2aWdhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI25hdmlnYXRpb24gIT09IHVuZGVmaW5lZCAmJiAhdGhpcy4jbmF2aWdhdGlvbi5kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaWQgPSBuYXZpZ2F0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2lkID09PSBuYXZpZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCAjc2Vzc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25hdmlnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgZGlzcG9zZVN5bWJvbCldKCkge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgTmF2aWdhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmF2aWdhdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9hO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2ssIGRpc3Bvc2VTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFJlYWxtID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9kaXNvd25fZGVjb3JhdG9ycztcbiAgICBsZXQgX2NhbGxGdW5jdGlvbl9kZWNvcmF0b3JzO1xuICAgIGxldCBfZXZhbHVhdGVfZGVjb3JhdG9ycztcbiAgICBsZXQgX3Jlc29sdmVFeGVjdXRpb25Db250ZXh0SWRfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgUmVhbG0gZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9kaXNwb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNwb3NlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkaXNwb3NlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZGlzcG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZGlzb3duX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNvd25cIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc293blwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmRpc293biB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfY2FsbEZ1bmN0aW9uX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjYWxsRnVuY3Rpb25cIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNhbGxGdW5jdGlvblwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmNhbGxGdW5jdGlvbiB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZXZhbHVhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImV2YWx1YXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJldmFsdWF0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmV2YWx1YXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJyZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJyZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVzb2x2ZUV4ZWN1dGlvbkNvbnRleHRJZCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICAjcmVhc29uID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICBkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgaWQ7XG4gICAgICAgIG9yaWdpbjtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkO1xuICAgICAgICBjb25zdHJ1Y3RvcihpZCwgb3JpZ2luKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYXNvbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWFsbTogdGhpcy5pZCB9O1xuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGlzb3duKGhhbmRsZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuZGlzb3duJywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNhbGxGdW5jdGlvbihmdW5jdGlvbkRlY2xhcmF0aW9uLCBhd2FpdFByb21pc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuY2FsbEZ1bmN0aW9uJywge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBldmFsdWF0ZShleHByZXNzaW9uLCBhd2FpdFByb21pc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuZXZhbHVhdGUnLCB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBhd2FpdFByb21pc2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlc29sdmVFeGVjdXRpb25Db250ZXh0SWQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uQ29udGV4dElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5jb25uZWN0aW9uLnNlbmQoJ2NkcC5yZXNvbHZlUmVhbG0nLCB7IHJlYWxtOiB0aGlzLmlkIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uQ29udGV4dElkID0gcmVzdWx0LmV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgX2Rpc293bl9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY2FsbEZ1bmN0aW9uX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHJlYWxtID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxtLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9ldmFsdWF0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfcmVzb2x2ZUV4ZWN1dGlvbkNvbnRleHRJZF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLCBwcm9iYWJseSBiZWNhdXNlIGFsbCBhc3NvY2lhdGVkIGJyb3dzaW5nIGNvbnRleHRzIGNsb3NlZC4nO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95ZWQnLCB7IHJlYXNvbjogdGhpcy4jcmVhc29uIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBSZWFsbSB9O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFdpbmRvd1JlYWxtIGV4dGVuZHMgUmVhbG0ge1xuICAgIHN0YXRpYyBmcm9tKGNvbnRleHQsIHNhbmRib3gpIHtcbiAgICAgICAgY29uc3QgcmVhbG0gPSBuZXcgV2luZG93UmVhbG0oY29udGV4dCwgc2FuZGJveCk7XG4gICAgICAgIHJlYWxtLiNpbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiByZWFsbTtcbiAgICB9XG4gICAgYnJvd3NpbmdDb250ZXh0O1xuICAgIHNhbmRib3g7XG4gICAgI3dvcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgc2FuZGJveCkge1xuICAgICAgICBzdXBlcignJywgJycpO1xuICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuc2FuZGJveCA9IHNhbmRib3g7XG4gICAgfVxuICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICBjb25zdCBicm93c2luZ0NvbnRleHRFbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLmJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLm9uKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy5zZXNzaW9uKSk7XG4gICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdzY3JpcHQucmVhbG1DcmVhdGVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAoaW5mby50eXBlICE9PSAnd2luZG93JyB8fFxuICAgICAgICAgICAgICAgIGluZm8uY29udGV4dCAhPT0gdGhpcy5icm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICBpbmZvLnNhbmRib3ggIT09IHRoaXMuc2FuZGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWQgPSBpbmZvLnJlYWxtO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBpbmZvLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uQ29udGV4dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignc2NyaXB0LnJlYWxtQ3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSAhPT0gJ2RlZGljYXRlZC13b3JrZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmZvLm93bmVycy5pbmNsdWRlcyh0aGlzLmlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gRGVkaWNhdGVkV29ya2VyUmVhbG0uZnJvbSh0aGlzLCBpbmZvLnJlYWxtLCBpbmZvLm9yaWdpbik7XG4gICAgICAgICAgICB0aGlzLiN3b3JrZXJzLnNldChyZWFsbS5pZCwgcmVhbG0pO1xuICAgICAgICAgICAgY29uc3QgcmVhbG1FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcihyZWFsbSkpO1xuICAgICAgICAgICAgcmVhbG1FbWl0dGVyLm9uY2UoJ2Rlc3Ryb3llZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWFsbUVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4geyBjb250ZXh0OiB0aGlzLmJyb3dzaW5nQ29udGV4dC5pZCwgc2FuZGJveDogdGhpcy5zYW5kYm94IH07XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIERlZGljYXRlZFdvcmtlclJlYWxtIGV4dGVuZHMgUmVhbG0ge1xuICAgIHN0YXRpYyBmcm9tKG93bmVyLCBpZCwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gbmV3IF9hKG93bmVyLCBpZCwgb3JpZ2luKTtcbiAgICAgICAgcmVhbG0uI2luaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHJlYWxtO1xuICAgIH1cbiAgICAjd29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICBvd25lcnM7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIGlkLCBvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoaWQsIG9yaWdpbik7XG4gICAgICAgIHRoaXMub3duZXJzID0gbmV3IFNldChbb3duZXJdKTtcbiAgICB9XG4gICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLnNlc3Npb24pKTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbURlc3Ryb3llZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8ucmVhbG0gIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLicpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbUNyZWF0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdkZWRpY2F0ZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mby5vd25lcnMuaW5jbHVkZXModGhpcy5pZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IF9hLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pO1xuICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5zZXQocmVhbG0uaWQsIHJlYWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIocmVhbG0pKTtcbiAgICAgICAgICAgIHJlYWxtRW1pdHRlci5vbmNlKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICAvLyBTQUZFVFk6IEF0IGxlYXN0IG9uZSBvd25lciB3aWxsIGV4aXN0LlxuICAgICAgICByZXR1cm4gdGhpcy5vd25lcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlLnNlc3Npb247XG4gICAgfVxufVxuX2EgPSBEZWRpY2F0ZWRXb3JrZXJSZWFsbTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFyZWRXb3JrZXJSZWFsbSBleHRlbmRzIFJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShicm93c2VyLCBpZCwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gbmV3IFNoYXJlZFdvcmtlclJlYWxtKGJyb3dzZXIsIGlkLCBvcmlnaW4pO1xuICAgICAgICByZWFsbS4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgfVxuICAgICN3b3JrZXJzID0gbmV3IE1hcCgpO1xuICAgIGJyb3dzZXI7XG4gICAgY29uc3RydWN0b3IoYnJvd3NlciwgaWQsIG9yaWdpbikge1xuICAgICAgICBzdXBlcihpZCwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5icm93c2VyID0gYnJvd3NlcjtcbiAgICB9XG4gICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLnNlc3Npb24pKTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbURlc3Ryb3llZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8ucmVhbG0gIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLicpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbUNyZWF0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdkZWRpY2F0ZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mby5vd25lcnMuaW5jbHVkZXModGhpcy5pZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IERlZGljYXRlZFdvcmtlclJlYWxtLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pO1xuICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5zZXQocmVhbG0uaWQsIHJlYWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIocmVhbG0pKTtcbiAgICAgICAgICAgIHJlYWxtRW1pdHRlci5vbmNlKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyLnNlc3Npb247XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbG0uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgaW5lcnRJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgUmVxdWVzdCA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgUmVxdWVzdCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGJyb3dzaW5nQ29udGV4dCwgZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChicm93c2luZ0NvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJlcXVlc3QuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgICNlcnJvciA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI3JlZGlyZWN0O1xuICAgICAgICAjcmVzcG9uc2U7XG4gICAgICAgICNicm93c2luZ0NvbnRleHQ7XG4gICAgICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgI2V2ZW50O1xuICAgICAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHQsIGV2ZW50KSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0ID0gYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy4jZXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNicm93c2luZ0NvbnRleHQpKTtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIub25jZSgnY2xvc2VkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNlcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcy4jZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI3Nlc3Npb24pKTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCduZXR3b3JrLmJlZm9yZVJlcXVlc3RTZW50JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlZGlyZWN0Q291bnQgIT09IHRoaXMuI2V2ZW50LnJlZGlyZWN0Q291bnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVkaXJlY3QgPSBSZXF1ZXN0LmZyb20odGhpcy4jYnJvd3NpbmdDb250ZXh0LCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWRpcmVjdCcsIHRoaXMuI3JlZGlyZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ25ldHdvcmsuYXV0aFJlcXVpcmVkJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHRyeSB0byBhdXRoZW50aWNhdGUgZm9yIGV2ZW50cyB0aGF0IGFyZSBub3QgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAhZXZlbnQuaXNCbG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdXRoZW50aWNhdGUnLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5mZXRjaEVycm9yJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2ZW50LnJlZGlyZWN0Q291bnQgIT09IGV2ZW50LnJlZGlyZWN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNlcnJvciA9IGV2ZW50LmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcy4jZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5yZXNwb25zZUNvbXBsZXRlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29udGV4dCAhPT0gdGhpcy4jYnJvd3NpbmdDb250ZXh0LmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlcXVlc3QucmVxdWVzdCAhPT0gdGhpcy5pZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNldmVudC5yZWRpcmVjdENvdW50ICE9PSBldmVudC5yZWRpcmVjdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UgPSBldmVudC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLiNldmVudC5yZXF1ZXN0LnRpbWluZ3MgPSBldmVudC5yZXF1ZXN0LnRpbWluZ3M7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdWNjZXNzJywgdGhpcy4jcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhpcyBpcyBhIHJlZGlyZWN0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNyZXNwb25zZS5zdGF0dXMgPj0gMzAwICYmIHRoaXMuI3Jlc3BvbnNlLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNzZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dC51c2VyQ29udGV4dC5icm93c2VyLnNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2FibGVzLmRpc3Bvc2VkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNldmVudC5yZXF1ZXN0LmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3QucmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaW5pdGlhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LmluaXRpYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3QubWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50Lm5hdmlnYXRpb24gPz8gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCByZWRpcmVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWRpcmVjdDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgbGFzdFJlZGlyZWN0KCkge1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0ID0gdGhpcy4jcmVkaXJlY3Q7XG4gICAgICAgICAgICB3aGlsZSAocmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3QgJiYgIXJlZGlyZWN0LiNyZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVkaXJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZGlyZWN0ID0gcmVkaXJlY3QuI3JlZGlyZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgICAgICB9XG4gICAgICAgIGdldCByZXNwb25zZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgdXJsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3QudXJsO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc0Jsb2NrZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQuaXNCbG9ja2VkO1xuICAgICAgICB9XG4gICAgICAgIGdldCByZXNvdXJjZVR5cGUoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vbi1zdGFuZGFyZCBhdHRyaWJ1dGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQucmVxdWVzdFsnZ29vZzpyZXNvdXJjZVR5cGUnXSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHBvc3REYXRhKCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub24tc3RhbmRhcmQgYXR0cmlidXRlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3RbJ2dvb2c6cG9zdERhdGEnXSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGhhc1Bvc3REYXRhKCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub24tc3RhbmRhcmQgYXR0cmlidXRlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3RbJ2dvb2c6aGFzUG9zdERhdGEnXSA/PyBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb250aW51ZVJlcXVlc3QoeyB1cmwsIG1ldGhvZCwgaGVhZGVycywgY29va2llcywgYm9keSwgfSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCduZXR3b3JrLmNvbnRpbnVlUmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGNvb2tpZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmYWlsUmVxdWVzdCgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnbmV0d29yay5mYWlsUmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcHJvdmlkZVJlc3BvbnNlKHsgc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBoZWFkZXJzLCBib2R5LCB9KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ25ldHdvcmsucHJvdmlkZVJlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICByZWFzb25QaHJhc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY29udGludWVXaXRoQXV0aChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5hY3Rpb24gPT09ICdwcm92aWRlQ3JlZGVudGlhbHMnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCduZXR3b3JrLmNvbnRpbnVlV2l0aEF1dGgnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogcGFyYW1ldGVycy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBwYXJhbWV0ZXJzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCduZXR3b3JrLmNvbnRpbnVlV2l0aEF1dGgnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogcGFyYW1ldGVycy5hY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgZGlzcG9zZVN5bWJvbCldKCkge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1pbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQucmVxdWVzdC50aW1pbmdzO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBSZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXF1ZXN0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGJ1YmJsZSwgaW5lcnRJZkRpc3Bvc2VkLCB0aHJvd0lmRGlzcG9zZWQsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgeyBCcm93c2VyIH0gZnJvbSAnLi9Ccm93c2VyLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmxldCBTZXNzaW9uID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9jb25uZWN0aW9uX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jb25uZWN0aW9uX2luaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfY29ubmVjdGlvbl9leHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfZGlzcG9zZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfc2VuZF9kZWNvcmF0b3JzO1xuICAgIGxldCBfc3Vic2NyaWJlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9hZGRJbnRlcmNlcHRzX2RlY29yYXRvcnM7XG4gICAgbGV0IF9lbmRfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgU2Vzc2lvbiBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Nvbm5lY3Rpb25fZGVjb3JhdG9ycywgeyBraW5kOiBcImFjY2Vzc29yXCIsIG5hbWU6IFwiY29ubmVjdGlvblwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY29ubmVjdGlvblwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmNvbm5lY3Rpb24sIHNldDogKG9iaiwgdmFsdWUpID0+IHsgb2JqLmNvbm5lY3Rpb24gPSB2YWx1ZTsgfSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIF9jb25uZWN0aW9uX2luaXRpYWxpemVycywgX2Nvbm5lY3Rpb25fZXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9kaXNwb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNwb3NlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkaXNwb3NlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZGlzcG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2VuZF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic2VuZFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwic2VuZFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNlbmQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3N1YnNjcmliZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic3Vic2NyaWJlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzdWJzY3JpYmVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5zdWJzY3JpYmUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2FkZEludGVyY2VwdHNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImFkZEludGVyY2VwdHNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImFkZEludGVyY2VwdHNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5hZGRJbnRlcmNlcHRzIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9lbmRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImVuZFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiZW5kXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZW5kIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhc3luYyBmcm9tKGNvbm5lY3Rpb24sIGNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZCgnc2Vzc2lvbi5uZXcnLCB7XG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24oY29ubmVjdGlvbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGF3YWl0IHNlc3Npb24uI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgICNyZWFzb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgI2luZm87XG4gICAgICAgIGJyb3dzZXI7XG4gICAgICAgICNjb25uZWN0aW9uX2FjY2Vzc29yX3N0b3JhZ2UgPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfY29ubmVjdGlvbl9pbml0aWFsaXplcnMsIHZvaWQgMCk7XG4gICAgICAgIGdldCBjb25uZWN0aW9uKCkgeyByZXR1cm4gdGhpcy4jY29ubmVjdGlvbl9hY2Nlc3Nvcl9zdG9yYWdlOyB9XG4gICAgICAgIHNldCBjb25uZWN0aW9uKHZhbHVlKSB7IHRoaXMuI2Nvbm5lY3Rpb25fYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGluZm8pIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfY29ubmVjdGlvbl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICB0aGlzLiNpbmZvID0gaW5mbztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICAvLyBTQUZFVFk6IFdlIHVzZSBgYW55YCB0byBhbGxvdyBhc3NpZ25tZW50IG9mIHRoZSByZWFkb25seSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIHRoaXMuYnJvd3NlciA9IGF3YWl0IEJyb3dzZXIuZnJvbSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXJFbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKHRoaXMuYnJvd3Nlcik7XG4gICAgICAgICAgICBicm93c2VyRW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHksIHNvbWUgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBlbWl0IG5hdmlnYXRpb25TdGFydGVkIGV2ZW50XG4gICAgICAgICAgICAvLyBmb3IgZnJhZ21lbnQgbmF2aWdhdGlvbnMgKGFzIHBlciBzcGVjKSBhbmQgc29tZSBkby4gVGhpcyBjb3VsZCBlbWl0cyBhXG4gICAgICAgICAgICAvLyBzeW50aGV0aWMgbmF2aWdhdGlvblN0YXJ0ZWQgdG8gd29yayBhcm91bmQgdGhpcyBpbmNvbnNpc3RlbmN5LlxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdicm93c2luZ0NvbnRleHQuZnJhZ21lbnROYXZpZ2F0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXMoaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWVuLmFkZChpbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uU3RhcnRlZCcsIGluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYnJvd3NpbmdDb250ZXh0LmZyYWdtZW50TmF2aWdhdGVkJywgaW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2FwYWJpbGl0aWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2luZm8uY2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZGVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBlbmRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFzb24gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jaW5mby5zZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5LCB0aGVyZSBpcyBhIDE6MSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgc2Vzc2lvbiBhbmQgdGhlXG4gICAgICAgICAqIHNlc3Npb24uIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IHN1cHBvcnQgbXVsdGlwbGUgc2Vzc2lvbnMgYW5kIGluIHRoYXRcbiAgICAgICAgICogY2FzZSB3ZSBhbHdheXMgbmVlZHMgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHNlc3Npb24gZm9yIHRoZSByaWdodCBzZXNzaW9uXG4gICAgICAgICAqIG9iamVjdCBpcyB1c2VkLCBzbyB3ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgaGVyZSwgYWx0aG91Z2ggaXQncyBub3QgZGVmaW5lZFxuICAgICAgICAgKiBpbiB0aGUgc3BlYy5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc3Vic2NyaWJlKGV2ZW50cywgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCgnc2Vzc2lvbi5zdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRleHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgYWRkSW50ZXJjZXB0cyhldmVudHMsIGNvbnRleHRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoJ3Nlc3Npb24uc3Vic2NyaWJlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICAgICBjb250ZXh0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVuZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKCdzZXNzaW9uLmVuZCcsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShgU2Vzc2lvbiBhbHJlYWR5IGVuZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFsoX2Nvbm5lY3Rpb25fZGVjb3JhdG9ycyA9IFtidWJibGUoKV0sIF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgX3NlbmRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoc2Vzc2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9zdWJzY3JpYmVfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoc2Vzc2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9hZGRJbnRlcmNlcHRzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfZW5kX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1Nlc3Npb24gYWxyZWFkeSBkZXN0cm95ZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gYnJva2UuJztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kZWQnLCB7IHJlYXNvbjogdGhpcy4jcmVhc29uIH0pO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgU2Vzc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Vzc2lvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi8uLi91dGlsL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2ssIGRpc3Bvc2VTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHsgQnJvd3NpbmdDb250ZXh0IH0gZnJvbSAnLi9Ccm93c2luZ0NvbnRleHQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFVzZXJDb250ZXh0ID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jcmVhdGVCcm93c2luZ0NvbnRleHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbW92ZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfZ2V0Q29va2llc19kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0Q29va2llX2RlY29yYXRvcnM7XG4gICAgbGV0IF9zZXRQZXJtaXNzaW9uc19kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBVc2VyQ29udGV4dCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jcmVhdGVCcm93c2luZ0NvbnRleHRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImNyZWF0ZUJyb3dzaW5nQ29udGV4dFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY3JlYXRlQnJvd3NpbmdDb250ZXh0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY3JlYXRlQnJvd3NpbmdDb250ZXh0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZW1vdmVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbW92ZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVtb3ZlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVtb3ZlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9nZXRDb29raWVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJnZXRDb29raWVzXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJnZXRDb29raWVzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZ2V0Q29va2llcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0Q29va2llX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZXRDb29raWVcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldENvb2tpZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldENvb2tpZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0UGVybWlzc2lvbnNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldFBlcm1pc3Npb25zXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRQZXJtaXNzaW9uc1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldFBlcm1pc3Npb25zIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBERUZBVUxUID0gJ2RlZmF1bHQnO1xuICAgICAgICBzdGF0aWMgY3JlYXRlKGJyb3dzZXIsIGlkKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFVzZXJDb250ZXh0KGJyb3dzZXIsIGlkKTtcbiAgICAgICAgICAgIGNvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICNyZWFzb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgIC8vIE5vdGUgdGhlc2UgYXJlIG9ubHkgdG9wLWxldmVsIGNvbnRleHRzLlxuICAgICAgICAjYnJvd3NpbmdDb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjaWQ7XG4gICAgICAgIGJyb3dzZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJyb3dzZXIsIGlkKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlciA9IGJyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuYnJvd3NlcikpO1xuICAgICAgICAgICAgYnJvd3NlckVtaXR0ZXIub25jZSgnY2xvc2VkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoYFVzZXIgY29udGV4dCB3YXMgY2xvc2VkOiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJvd3NlckVtaXR0ZXIub25jZSgnZGlzY29ubmVjdGVkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoYFVzZXIgY29udGV4dCB3YXMgY2xvc2VkOiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNzZXNzaW9uKSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmNvbnRleHRDcmVhdGVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8udXNlckNvbnRleHQgIT09IHRoaXMuI2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0ID0gQnJvd3NpbmdDb250ZXh0LmZyb20odGhpcywgdW5kZWZpbmVkLCBpbmZvLmNvbnRleHQsIGluZm8udXJsLCBpbmZvLm9yaWdpbmFsT3BlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRzLnNldChicm93c2luZ0NvbnRleHQuaWQsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKGJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIub24oJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0cy5kZWxldGUoYnJvd3NpbmdDb250ZXh0LmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jyb3dzaW5nY29udGV4dCcsIHsgYnJvd3NpbmdDb250ZXh0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNzZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBicm93c2luZ0NvbnRleHRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dHMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFzb24gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlQnJvd3NpbmdDb250ZXh0KHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQ6IHsgY29udGV4dDogY29udGV4dElkIH0sIH0gPSBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5jcmVhdGUnLCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUNvbnRleHQ6IG9wdGlvbnMucmVmZXJlbmNlQ29udGV4dD8uaWQsXG4gICAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBicm93c2luZ0NvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRzLmdldChjb250ZXh0SWQpO1xuICAgICAgICAgICAgYXNzZXJ0KGJyb3dzaW5nQ29udGV4dCwgJ1RoZSBXZWJEcml2ZXIgQmlEaSBpbXBsZW1lbnRhdGlvbiBpcyBmYWlsaW5nIHRvIGNyZWF0ZSBhIGJyb3dzaW5nIGNvbnRleHQgY29ycmVjdGx5LicpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIGFuIGFycmF5IHRvIGF2b2lkIHRoZSBwcm9taXNlIGZyb20gYmVpbmcgYXdhaXRlZC5cbiAgICAgICAgICAgIHJldHVybiBicm93c2luZ0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzZXIucmVtb3ZlVXNlckNvbnRleHQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLiNpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgnVXNlciBjb250ZXh0IGFscmVhZHkgY2xvc2VkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGdldENvb2tpZXMob3B0aW9ucyA9IHt9LCBzb3VyY2VPcmlnaW4gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGNvb2tpZXMgfSwgfSA9IGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnc3RvcmFnZS5nZXRDb29raWVzJywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdG9yYWdlS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VPcmlnaW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Q29va2llKGNvb2tpZSwgc291cmNlT3JpZ2luKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ3N0b3JhZ2Uuc2V0Q29va2llJywge1xuICAgICAgICAgICAgICAgIGNvb2tpZSxcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0b3JhZ2VLZXknLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRQZXJtaXNzaW9ucyhvcmlnaW4sIGRlc2NyaXB0b3IsIHN0YXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ3Blcm1pc3Npb25zLnNldFBlcm1pc3Npb24nLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9jcmVhdGVCcm93c2luZ0NvbnRleHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9nZXRDb29raWVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfc2V0Q29va2llX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfc2V0UGVybWlzc2lvbnNfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIGRpc3Bvc2VTeW1ib2wpXSgpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA/Pz1cbiAgICAgICAgICAgICAgICAnVXNlciBjb250ZXh0IGFscmVhZHkgY2xvc2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIGRpc2Nvbm5lY3RlZC9jbG9zZWQuJztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJywgeyByZWFzb246IHRoaXMuI3JlYXNvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHN1cGVyW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmV4cG9ydCB7IFVzZXJDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vc2VyQ29udGV4dC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2ssIGRpc3Bvc2VTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFVzZXJQcm9tcHQgPSAoKCkgPT4ge1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICBsZXQgX2hhbmRsZV9kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBVc2VyUHJvbXB0IGV4dGVuZHMgX2NsYXNzU3VwZXIge1xuICAgICAgICBzdGF0aWMge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUoX2NsYXNzU3VwZXJbU3ltYm9sLm1ldGFkYXRhXSA/PyBudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZGlzcG9zZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZGlzcG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiZGlzcG9zZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmRpc3Bvc2UgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2hhbmRsZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiaGFuZGxlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJoYW5kbGVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5oYW5kbGUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oYnJvd3NpbmdDb250ZXh0LCBpbmZvKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbXB0ID0gbmV3IFVzZXJQcm9tcHQoYnJvd3NpbmdDb250ZXh0LCBpbmZvKTtcbiAgICAgICAgICAgIHVzZXJQcm9tcHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvbXB0O1xuICAgICAgICB9XG4gICAgICAgICNyZWFzb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNyZXN1bHQ7XG4gICAgICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICBpbmZvO1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBpbmZvKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXJDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuYnJvd3NpbmdDb250ZXh0KSk7XG4gICAgICAgICAgICBicm93c2VyQ29udGV4dEVtaXR0ZXIub25jZSgnY2xvc2VkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoYFVzZXIgcHJvbXB0IGFscmVhZHkgY2xvc2VkOiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNzZXNzaW9uKSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LnVzZXJQcm9tcHRDbG9zZWQnLCBwYXJhbWV0ZXJzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycy5jb250ZXh0ICE9PSB0aGlzLmJyb3dzaW5nQ29udGV4dC5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3Jlc3VsdCA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdoYW5kbGVkJywgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCdVc2VyIHByb21wdCBhbHJlYWR5IGhhbmRsZWQuJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgI3Nlc3Npb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5icm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhc29uICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBoYW5kbGVkKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mby5oYW5kbGVyID09PSBcImFjY2VwdFwiIC8qIEJpZGkuU2Vzc2lvbi5Vc2VyUHJvbXB0SGFuZGxlclR5cGUuQWNjZXB0ICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmhhbmRsZXIgPT09IFwiZGlzbWlzc1wiIC8qIEJpZGkuU2Vzc2lvbi5Vc2VyUHJvbXB0SGFuZGxlclR5cGUuRGlzbWlzcyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3VsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCByZXN1bHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgaGFuZGxlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuaGFuZGxlVXNlclByb21wdCcsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaW5mby5jb250ZXh0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTQUZFVFk6IGBoYW5kbGVkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBhYm92ZSBwcm9taXNlIHJlc29sdmVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgX2hhbmRsZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChwcm9tcHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbXB0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIGRpc3Bvc2VTeW1ib2wpXSgpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA/Pz1cbiAgICAgICAgICAgICAgICAnVXNlciBwcm9tcHQgYWxyZWFkeSBjbG9zZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGFzc29jaWF0ZWQgYnJvd3NpbmcgY29udGV4dCB3YXMgZGVzdHJveWVkLic7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBVc2VyUHJvbXB0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vc2VyUHJvbXB0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5pbXBvcnQgeyBQcm90b2NvbEVycm9yLCBUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IFB1cHBldGVlclVSTCB9IGZyb20gJy4uL2NvbW1vbi91dGlsLmpzJztcbmltcG9ydCB7IEJpZGlEZXNlcmlhbGl6ZXIgfSBmcm9tICcuL0Rlc2VyaWFsaXplci5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZhbHVhdGlvbkVycm9yKGRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy5leGNlcHRpb24udHlwZSAhPT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm4gQmlkaURlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShkZXRhaWxzLmV4Y2VwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IFtuYW1lID0gJycsIC4uLnBhcnRzXSA9IGRldGFpbHMudGV4dC5zcGxpdCgnOiAnKTtcbiAgICBjb25zdCBtZXNzYWdlID0gcGFydHMuam9pbignOiAnKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5uYW1lID0gbmFtZTtcbiAgICAvLyBUaGUgZmlyc3QgbGluZSBpcyB0aGlzIGZ1bmN0aW9uIHdoaWNoIHdlIGlnbm9yZS5cbiAgICBjb25zdCBzdGFja0xpbmVzID0gW107XG4gICAgaWYgKGRldGFpbHMuc3RhY2tUcmFjZSAmJiBzdGFja0xpbmVzLmxlbmd0aCA8IEVycm9yLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgICAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGRldGFpbHMuc3RhY2tUcmFjZS5jYWxsRnJhbWVzLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKFB1cHBldGVlclVSTC5pc1B1cHBldGVlclVSTChmcmFtZS51cmwpICYmXG4gICAgICAgICAgICAgICAgZnJhbWUudXJsICE9PSBQdXBwZXRlZXJVUkwuSU5URVJOQUxfVVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gUHVwcGV0ZWVyVVJMLnBhcnNlKGZyYW1lLnVybCk7XG4gICAgICAgICAgICAgICAgc3RhY2tMaW5lcy51bnNoaWZ0KGAgICAgYXQgJHtmcmFtZS5mdW5jdGlvbk5hbWUgfHwgdXJsLmZ1bmN0aW9uTmFtZX0gKCR7dXJsLmZ1bmN0aW9uTmFtZX0gYXQgJHt1cmwuc2l0ZVN0cmluZ30sIDxhbm9ueW1vdXM+OiR7ZnJhbWUubGluZU51bWJlcn06JHtmcmFtZS5jb2x1bW5OdW1iZXJ9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2tMaW5lcy5wdXNoKGAgICAgYXQgJHtmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJzxhbm9ueW1vdXM+J30gKCR7ZnJhbWUudXJsfToke2ZyYW1lLmxpbmVOdW1iZXJ9OiR7ZnJhbWUuY29sdW1uTnVtYmVyfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja0xpbmVzLmxlbmd0aCA+PSBFcnJvci5zdGFja1RyYWNlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvci5zdGFjayA9IFtkZXRhaWxzLnRleHQsIC4uLnN0YWNrTGluZXNdLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlTmF2aWdhdGlvbkVycm9yKG1lc3NhZ2UsIG1zKSB7XG4gICAgcmV0dXJuIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSBgIGF0ICR7bWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVGltZW91dEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYE5hdmlnYXRpb24gdGltZW91dCBvZiAke21zfSBtcyBleGNlZWRlZGA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9